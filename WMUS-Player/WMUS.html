<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Audio Sequencer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-main: #121212;
            --bg-container: #1E1E1E;
            --bg-track: #2A2A2A;
            --bg-element: #404040;
            --bg-element-hover: #555555;
            --text-primary: #E0E0E0;
            --text-secondary: #A0A0A0;
            --border-color: #383838;
            --accent-cyan: #22D3EE;
            --accent-cyan-glow: rgba(34, 211, 238, 0.3);
            --accent-amber: #FBBF24;
        }

        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            background-color: var(--bg-main);
            color: var(--text-primary);
        }
        
        /* Main container */
        .main-container {
            background-color: var(--bg-container);
            border: 1px solid var(--border-color);
        }

        /* Scrollbar */
        .scroll-container::-webkit-scrollbar { height: 8px; width: 8px; }
        .scroll-container::-webkit-scrollbar-track { background: var(--bg-container); border-radius: 4px; }
        .scroll-container::-webkit-scrollbar-thumb { background: var(--bg-element); border-radius: 4px; }
        .scroll-container::-webkit-scrollbar-thumb:hover { background: var(--bg-element-hover); }

        /* Buttons */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-weight: 500;
            transition: all 0.2s ease-in-out;
            border: 1px solid transparent;
        }
        .btn-primary {
            background-color: var(--accent-cyan);
            color: var(--bg-main);
            box-shadow: 0 2px 10px rgba(34, 211, 238, 0.2);
        }
        .btn-primary:hover {
            filter: brightness(1.1);
        }
        .btn-secondary {
            background-color: var(--bg-element);
            border-color: var(--border-color);
        }
        .btn-secondary:hover {
            background-color: var(--bg-element-hover);
            border-color: #606060;
        }
        .btn-ghost {
            background-color: transparent;
        }
        .btn-ghost:hover {
            background-color: var(--bg-element);
        }
        .btn.active {
            background-color: var(--accent-cyan);
            color: var(--bg-main);
            border-color: var(--accent-cyan);
        }


        /* Controls */
        .custom-slider { -webkit-appearance: none; appearance: none; width: 100%; height: 4px; background: var(--bg-element); border-radius: 2px; outline: none; }
        .custom-slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 16px; height: 16px; background: var(--text-primary); border-radius: 50%; cursor: pointer; border: 2px solid var(--bg-container); }
        .custom-slider::-moz-range-thumb { width: 16px; height: 16px; background: var(--text-primary); border-radius: 50%; cursor: pointer; border: 2px solid var(--bg-container); }
        
        .custom-select {
            -webkit-appearance: none; appearance: none;
            background-color: var(--bg-element);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 0.25rem 2rem 0.25rem 0.5rem;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%23A0A0A0' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 0.5rem center;
            background-repeat: no-repeat;
            background-size: 1.5em 1.5em;
        }

        /* Sequencer Elements */
        .step-button, .arranger-step {
            transition: all 0.1s ease-in-out;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
            cursor: pointer;
            -webkit-user-select: none; user-select: none;
            background-color: var(--bg-element);
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.3);
        }
        .step-button { width: 100%; height: 32px; }
        .step-button.beat-marker { background-color: #52525B; } /* Enhanced visibility for beat markers */
        
        .step-button.active {
            background-color: var(--accent-cyan);
            box-shadow: 0 0 12px var(--accent-cyan-glow);
        }
        .step-button.beat-marker.active { filter: brightness(0.9); }

        .playing {
             outline: 2px solid var(--accent-cyan);
             outline-offset: 2px;
             box-shadow: 0 0 12px var(--accent-cyan-glow) !important;
        }

        .indicator {
            position: absolute; bottom: 0; width: 50%; pointer-events: none; transition: height 0.05s linear, filter 0.1s ease-in-out;
            background-blend-mode: overlay;
        }
        .gain-indicator { left: 0; background-color: var(--accent-amber); opacity: 0.6; }
        .pitch-indicator { right: 0; background-color: var(--accent-cyan); opacity: 0.6; }
        
        /* Enhance indicator visibility on active steps. */
        .step-button.active .indicator {
            filter: brightness(1.5);
            opacity: 0.8;
        }

        .arranger-step, .add-arrangement-btn {
            width: 60px; height: 40px; display: flex; align-items: center; justify-content: center;
            font-size: 14px; font-weight: 500; border: 1px solid var(--border-color);
        }
        .arranger-step:not(:empty) {
            background-color: var(--accent-cyan);
            color: var(--bg-main);
            border-color: transparent;
            filter: saturate(0.5);
        }
        .add-arrangement-btn {
            font-size: 20px;
            color: var(--text-secondary);
        }

        .pattern-btn.selected {
            background-color: var(--accent-cyan);
            color: var(--bg-main);
            transform: scale(1.05);
        }
        
        .spinner {
            border: 2px solid var(--bg-element); border-top: 2px solid var(--accent-cyan);
            border-radius: 50%; width: 16px; height: 16px; animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body class="bg-gray-800/50">

    <!-- Modal Container -->
    <div class="fixed inset-0 flex items-center justify-center p-4">
        <div class="w-full max-w-7xl h-full max-h-[95vh] main-container rounded-xl shadow-2xl p-4 flex flex-col">
            <!-- Header & Global Controls -->
            <header class="flex-shrink-0 flex flex-col sm:flex-row justify-between items-center pb-4 border-b border-gray-700">
                <h1 class="text-2xl sm:text-3xl font-bold text-white mb-4 sm:mb-0">Web Sequencer</h1>
                <div class="flex items-center space-x-6">
                    <div class="flex flex-col items-center">
                        <label class="text-xs font-medium text-gray-400 mb-1">Tempo</label>
                        <div class="flex items-center space-x-2">
                             <button id="metronome-toggle-btn" class="btn btn-secondary p-2" title="Toggle Metronome">
                                 <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 12H3M21 12h-9m-9 0a9 9 0 0 0 18 0a9 9 0 0 0-18 0Z"/></svg>
                             </button>
                            <input type="range" id="tempo" min="40" max="240" value="120" class="w-24 sm:w-32 custom-slider">
                            <span id="tempo-value" class="font-mono text-base sm:text-lg w-12 text-center text-gray-300">120</span>
                        </div>
                    </div>
                    <div class="flex items-center space-x-2">
                        <button id="loop-toggle-btn" class="btn btn-secondary p-2 active" title="Toggle Loop">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12a9 9 0 1 1-6.219-8.56"/></svg>
                        </button>
                        <button id="play-stop-btn" class="btn btn-primary px-4 py-2 sm:px-6 sm:py-3 text-sm sm:text-base">
                            Play
                        </button>
                    </div>
                </div>
            </header>

            <!-- Song Arrangement Section -->
            <section class="flex-shrink-0 pt-4">
                <h2 class="text-sm font-semibold text-gray-400 mb-2">Song Arrangement</h2>
                <div id="arrangement-container" class="scroll-container flex space-x-1 overflow-x-auto pb-2 items-center"></div>
            </section>

            <!-- Sequencer Tracks -->
            <main id="sequencer-tracks" class="flex-grow flex space-x-3 overflow-x-auto py-4 border-t border-b border-gray-700/50 my-2">
            </main>

            <div class="flex-shrink-0 flex flex-col sm:flex-row justify-between items-center pt-4 border-t border-gray-700">
                <div class="flex items-center space-x-2">
                    <button id="add-track-btn" class="btn btn-secondary text-sm">
                        + Add Track
                    </button>
                </div>

                <!-- Pattern Management -->
                <div class="flex items-center space-x-2 my-4 sm:my-0">
                    <span class="text-sm font-semibold text-gray-400">Patterns:</span>
                    <div id="pattern-list" class="flex items-center space-x-1"></div>
                    <button id="add-pattern-btn" class="btn btn-secondary px-2 py-1 text-xs font-bold">+</button>
                    <button id="dup-pattern-btn" class="btn btn-ghost px-2 py-1 text-xs">Dup</button>
                </div>

                <!-- Save/Load Buttons -->
                <div class="flex space-x-2">
                    <button id="save-project-btn" class="btn btn-secondary text-sm">Save Project</button>
                    <button id="load-project-btn" class="btn btn-secondary text-sm">Load Project</button>
                    <input type="file" id="load-project-input" class="hidden" accept=".wmus">
                </div>
            </div>
        </div>
    </div>
    
    <!-- Track Template -->
    <template id="track-template">
        <div class="track p-2 rounded-lg flex flex-col space-y-3 w-40 flex-shrink-0" style="background-color: var(--bg-track);">
            <div class="track-controls w-full flex flex-col space-y-2">
                <div class="relative w-full">
                    <input type="file" class="hidden file-input" accept="audio/*">
                    <button class="w-full text-left p-2 text-xs sm:text-sm rounded-md truncate btn btn-secondary load-sound-btn">Load Sound</button>
                </div>
                <div class="flex items-center justify-between w-full">
                    <div class="flex items-center space-x-1">
                        <label class="text-xs sm:text-sm text-gray-400">Div:</label>
                        <select class="division-select custom-select text-xs sm:text-sm">
                            <option value="8">1/8</option>
                            <option value="16" selected>1/16</option>
                            <option value="32">1/32</option>
                        </select>
                    </div>
                     <button class="remove-track-btn text-gray-500 hover:text-red-400 font-bold text-lg sm:text-xl px-1">&times;</button>
                </div>
                <div class="flex items-center justify-between w-full text-xs text-gray-400">
                    <label>Swing</label>
                    <span class="swing-value font-mono">50%</span>
                </div>
                <input type="range" min="50" max="75" value="50" class="swing-slider custom-slider w-full">
            </div>
            <div class="steps-container flex-grow flex flex-col gap-1"></div>
        </div>
    </template>


    <script>
        // --- PREAMBLE ---
        // Placeholder encoder/decoder. Does not perform real compression but ensures functionality.
        const OpusEncoder = { encode: async (buffer) => new Blob([buffer.getChannelData(0)], { type: 'audio/opus' }) };
        const OpusDecoder = { decode: async (blob) => new Float32Array(await blob.arrayBuffer()) };

        document.addEventListener('DOMContentLoaded', () => {
            // --- APPLICATION STATE & CONSTANTS ---
            let audioContext;
            let sequencerNode;
            let isPlaying = false;
            let isLooping = true;
            let isMetronomeOn = false;
            let tempo = 120;
            let patterns = [];
            let currentPatternId = null;
            let patternIdCounter = 0;
            let arrangement = [];
            
            // --- Pre-calculated Look-Up Tables for Optimization ---
            const gainToDbLut = new Float32Array(101);
            const MIN_DB = -60.0;
            for (let i = 0; i < 101; i++) {
                const gain = Math.pow(i / 100, 2); // Perceptual (power) curve.
                const db = gain > 0 ? 20 * Math.log10(gain) : MIN_DB;
                gainToDbLut[i] = Math.max(MIN_DB, db);
            }

            // A single, cached object for all DOM element references.
            const dom = {
                playStopBtn: document.getElementById('play-stop-btn'),
                loopToggleBtn: document.getElementById('loop-toggle-btn'),
                metronomeToggleBtn: document.getElementById('metronome-toggle-btn'),
                tempoSlider: document.getElementById('tempo'),
                tempoValue: document.getElementById('tempo-value'),
                addTrackBtn: document.getElementById('add-track-btn'),
                sequencerTracks: document.getElementById('sequencer-tracks'),
                trackTemplate: document.getElementById('track-template'),
                arrangementContainer: document.getElementById('arrangement-container'),
                patternList: document.getElementById('pattern-list'),
                addPatternBtn: document.getElementById('add-pattern-btn'),
                dupPatternBtn: document.getElementById('dup-pattern-btn'),
                saveProjectBtn: document.getElementById('save-project-btn'),
                loadProjectBtn: document.getElementById('load-project-btn'),
                loadProjectInput: document.getElementById('load-project-input'),
            };
            
            // --- AUDIO WORKLET PROCESSOR ---
            const sequencerWorkletCode = `
                class SequencerProcessor extends AudioWorkletProcessor {
                    constructor() {
                        super();
                        this.isPlaying = false;
                        this.tempo = 120;
                        this.stepDuration = 0;
                        this.nextStepTime = 0;
                        this.currentStep = 0;
                        this.port.onmessage = this.handleMessage.bind(this);
                        this._updateStepDuration();
                    }
                    handleMessage(event) {
                        const { type, value } = event.data;
                        if (type === 'start') { this.isPlaying = true; this.currentStep = 0; this.nextStepTime = currentTime; }
                        else if (type === 'stop') { this.isPlaying = false; }
                        else if (type === 'setTempo') { this.tempo = value; this._updateStepDuration(); }
                    }
                    _updateStepDuration() {
                        const secondsPerBeat = 60.0 / this.tempo;
                        this.stepDuration = secondsPerBeat / 8; // 32nd note resolution
                    }
                    process(inputs, outputs, parameters) {
                        if (!this.isPlaying) return true;
                        while (this.nextStepTime < currentTime + 0.1) {
                            this.port.postMessage({ type: 'tick', step: this.currentStep });
                            this.nextStepTime += this.stepDuration;
                            this.currentStep++;
                        }
                        return true;
                    }
                }
                registerProcessor('sequencer-processor', SequencerProcessor);
            `;

            // --- AUDIO ENGINE ---
            async function initAudio() {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    if (audioContext.state === 'suspended') await audioContext.resume();
                    const blob = new Blob([sequencerWorkletCode.trim()], { type: 'application/javascript' });
                    const url = URL.createObjectURL(blob);
                    await audioContext.audioWorklet.addModule(url);
                    sequencerNode = new AudioWorkletNode(audioContext, 'sequencer-processor');
                    sequencerNode.port.onmessage = e => e.data.type === 'tick' && handleTick(e.data.step);
                    sequencerNode.connect(audioContext.destination);
                }
            }
            
            function handleTick(step) {
                if (arrangement.length === 0) { if (isPlaying) togglePlayback(); return; }
                const totalSongSteps = arrangement.length * 32;
                if (!isLooping && step >= totalSongSteps) { if(isPlaying) togglePlayback(); return; }
                const currentStepInLoop = isLooping ? (step % totalSongSteps) : step;
                const arrangementIndex = Math.floor(currentStepInLoop / 32);
                const patternIdToPlay = arrangement[arrangementIndex];
                updatePlayhead(currentStepInLoop, arrangementIndex);
                if (isMetronomeOn && (currentStepInLoop % 8 === 0)) { scheduleMetronomeClick(audioContext.currentTime); }
                if (patternIdToPlay === null) return;
                const patternToPlay = patterns.find(p => p.id === patternIdToPlay);
                if (!patternToPlay) return;
                const stepInPattern = currentStepInLoop % 32;
                patternToPlay.tracks.forEach(track => scheduleNote(track, stepInPattern, audioContext.currentTime));
            }
            
            function findNextStep(track, startStep) {
                for (let i = 1; i < 32; i++) {
                    const nextStepIndex = (startStep + i) % 32;
                    if (track.steps[nextStepIndex].active) { return { index: nextStepIndex, stepsAway: i }; }
                }
                return null;
            }

            function scheduleNote(track, stepInPattern, time) {
                const stepData = track.steps[stepInPattern];
                if (!track.audioBuffer || !stepData.active) return;
                
                let releaseDuration = 0.01;
                const nextStepInfo = findNextStep(track, stepInPattern);
                if (nextStepInfo) {
                    const thirtySecondNoteDuration = (60 / tempo) / 8;
                    releaseDuration = (nextStepInfo.stepsAway * thirtySecondNoteDuration) * 0.98;
                }

                if (track.playingNode) {
                    track.playingNode.gain.cancelScheduledValues(time);
                    track.playingNode.gain.setValueAtTime(track.playingNode.gain.value, time);
                    track.playingNode.gain.exponentialRampToValueAtTime(0.0001, time + releaseDuration);
                }
                
                let scheduledTime = time;
                if (track.swing > 50) {
                    if (stepInPattern % 8 !== 0 && stepInPattern % 4 === 0) {
                        const eighthNoteDuration = (60 / tempo) / 2;
                        const delayRatio = (track.swing - 50) / 25;
                        const swingDelay = (eighthNoteDuration / 3) * delayRatio;
                        scheduledTime += swingDelay;
                    }
                }

                const source = audioContext.createBufferSource();
                source.buffer = track.audioBuffer;
                const panner = audioContext.createStereoPanner();
                const panValue = (track.balanceFactor * 2) - 1;
                panner.pan.setValueAtTime(panValue, scheduledTime);
                const gainNode = audioContext.createGain();
                const stepGainDb = gainToDbLut[Math.round(stepData.gain)];
                // Apply normalization compensation. A positive normalizationGainDb means the sample was quiet.
                const finalDb = stepGainDb - track.normalizationGainDb;
                const finalLinearGain = Math.pow(10, finalDb / 20);
                gainNode.gain.setValueAtTime(finalLinearGain, scheduledTime);
                source.playbackRate.setValueAtTime(Math.pow(2, (stepData.pitch - 50) / 50), scheduledTime);
                source.connect(panner).connect(gainNode).connect(audioContext.destination);
                source.start(scheduledTime);
                track.playingNode = gainNode;
            }

            function scheduleMetronomeClick(time) {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(1000, time);
                gain.gain.setValueAtTime(1, time);
                gain.gain.exponentialRampToValueAtTime(0.001, time + 0.05);
                osc.connect(gain).connect(audioContext.destination);
                osc.start(time);
                osc.stop(time + 0.05);
            }

            // --- UI RENDERING ---
            function renderAll() {
                renderPatternList();
                renderArrangement();
                renderTracksForCurrentPattern();
            }
            
            function updatePlayhead(currentStepInLoop, currentArrangementIndex) {
                 requestAnimationFrame(() => {
                     document.querySelectorAll('.arranger-step.playing').forEach(el => el.classList.remove('playing'));
                     if (currentArrangementIndex !== null && currentArrangementIndex < arrangement.length) {
                         const arrangerStepEl = document.querySelectorAll('.arranger-step')[currentArrangementIndex];
                         if(arrangerStepEl) arrangerStepEl.classList.add('playing');
                     }
                      const patternIdToPlay = arrangement[currentArrangementIndex];
                      const patternToPlay = patterns.find(p => p.id === patternIdToPlay);
                      document.querySelectorAll('.step-button.playing').forEach(el => el.classList.remove('playing'));
                      if (!patternToPlay) return;
                      const stepInPattern = currentStepInLoop % 32;
                      patternToPlay.tracks.forEach(track => {
                          if (!track.element) return;
                          const visibleSteps = track.division;
                          const divisionFactor = 32 / visibleSteps;
                          const stepIndexToLight = Math.floor(stepInPattern / divisionFactor);
                          if ((stepInPattern % divisionFactor) === 0) {
                              const nextStepButton = track.element.querySelectorAll('.step-button')[stepIndexToLight];
                              if (nextStepButton) nextStepButton.classList.add('playing');
                          }
                      });
                 });
            }

            function renderPatternList() {
                dom.patternList.innerHTML = '';
                patterns.forEach(pattern => {
                    const btn = document.createElement('button');
                    btn.textContent = pattern.name;
                    btn.className = 'pattern-btn btn btn-secondary px-3 py-1 text-xs';
                    if (pattern.id === currentPatternId) btn.classList.add('selected');
                    btn.onclick = () => switchPattern(pattern.id);
                    dom.patternList.appendChild(btn);
                });
            }

            function renderArrangement() {
                dom.arrangementContainer.innerHTML = '';
                arrangement.forEach((patternId, index) => {
                    const stepEl = document.createElement('button');
                    stepEl.className = 'arranger-step';
                    const pattern = patterns.find(p => p.id === patternId);
                    if (pattern) { stepEl.textContent = pattern.name; }
                    stepEl.onclick = () => {
                        if (patterns.length === 0) return;
                        const currentPatternIndex = patternId === null ? -1 : patterns.findIndex(p => p.id === patternId);
                        const nextPatternIndex = (currentPatternIndex + 1);
                        arrangement[index] = (nextPatternIndex >= patterns.length) ? null : patterns[nextPatternIndex].id;
                        renderArrangement();
                    };
                    dom.arrangementContainer.appendChild(stepEl);
                });
                const addBtn = document.createElement('button');
                addBtn.className = 'add-arrangement-btn btn btn-ghost';
                addBtn.textContent = '+';
                addBtn.onclick = () => {
                    arrangement.push(null);
                    renderArrangement();
                };
                dom.arrangementContainer.appendChild(addBtn);
            }
            
            function renderTracksForCurrentPattern() {
                dom.sequencerTracks.innerHTML = '';
                const currentPattern = patterns.find(p => p.id === currentPatternId);
                if (!currentPattern) return;
                currentPattern.tracks.forEach(track => {
                    const trackElement = dom.trackTemplate.content.cloneNode(true).firstElementChild;
                    track.element = trackElement;
                    track.element.dataset.id = track.id;
                    dom.sequencerTracks.appendChild(trackElement);
                    setupTrackUI(track);
                });
            }

            function setupTrackUI(track) {
                const stepsContainer = track.element.querySelector('.steps-container');
                stepsContainer.innerHTML = '';
                const stepsToShow = track.division;
                let groupContainer = null;
                for (let i = 0; i < stepsToShow; i++) {
                    if (i % 4 === 0) {
                        groupContainer = document.createElement('div');
                        groupContainer.className = 'flex flex-col gap-1';
                        if (i > 0) { groupContainer.classList.add('mt-2'); }
                        stepsContainer.appendChild(groupContainer);
                    }
                    const stepDataIndex = i * (32 / track.division);
                    const stepBtn = document.createElement('button');
                    stepBtn.dataset.stepIndex = stepDataIndex;
                    const stepData = track.steps[stepDataIndex];
                    stepBtn.className = 'step-button';
                    if (i % (stepsToShow / 4) === 0) {
                        stepBtn.classList.add('beat-marker');
                    }
                    if (stepData.active) stepBtn.classList.add('active');
                    const gainIndicator = document.createElement('div');
                    gainIndicator.className = 'indicator gain-indicator';
                    const pitchIndicator = document.createElement('div');
                    pitchIndicator.className = 'indicator pitch-indicator';
                    const updateIndicators = () => {
                        gainIndicator.style.height = `${stepData.gain}%`;
                        pitchIndicator.style.height = `${stepData.pitch}%`;
                    };
                    stepBtn.append(gainIndicator, pitchIndicator);
                    updateIndicators();
                    stepBtn.addEventListener('mousedown', e => {
                        if (e.button !== 0) return;
                        let isDragging = false;
                        const initialY = e.clientY, rect = e.target.getBoundingClientRect();
                        const dragTarget = (e.clientX - rect.left < rect.width / 2) ? 'gain' : 'pitch';
                        const initialValue = track.steps[stepDataIndex][dragTarget];
                        const onMouseMove = moveEvent => {
                            const deltaY = initialY - moveEvent.clientY;
                            if (!isDragging && Math.abs(deltaY) > 4) isDragging = true;
                            if (isDragging) {
                                track.steps[stepDataIndex][dragTarget] = Math.max(0, Math.min(100, initialValue + deltaY * 0.5));
                                updateIndicators();
                            }
                        };
                        const onMouseUp = () => {
                            window.removeEventListener('mousemove', onMouseMove);
                            window.removeEventListener('mouseup', onMouseUp);
                            if (!isDragging) {
                                track.steps[stepDataIndex].active = !track.steps[stepDataIndex].active;
                                stepBtn.classList.toggle('active');
                            }
                        };
                        window.addEventListener('mousemove', onMouseMove);
                        window.addEventListener('mouseup', onMouseUp);
                    });
                    stepBtn.addEventListener('dblclick', e => {
                        e.preventDefault();
                        const rect = e.target.getBoundingClientRect();
                        if (e.clientX - rect.left < rect.width / 2) track.steps[stepDataIndex].gain = 100;
                        else track.steps[stepDataIndex].pitch = 50;
                        updateIndicators();
                    });
                    groupContainer.appendChild(stepBtn);
                }
                const loadBtn = track.element.querySelector('.load-sound-btn');
                if (track.audioBuffer) { loadBtn.textContent = track.fileName || 'Loaded Sample'; }
                const fileInput = track.element.querySelector('.file-input');
                loadBtn.addEventListener('click', () => fileInput.click());
                fileInput.addEventListener('change', async e => {
                    const file = e.target.files[0];
                    if (!file) return;
                    loadBtn.textContent = 'Loading...';
                    await initAudio();
                    const arrayBuffer = await file.arrayBuffer();
                    track.audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    track.fileName = file.name;
                    track.normalizationGainDb = 0;
                    track.balanceFactor = 0.5;
                    track.originalOpusBlob = null;
                    loadBtn.textContent = file.name;
                });
                const divisionSelect = track.element.querySelector('.division-select');
                divisionSelect.value = track.division;
                divisionSelect.addEventListener('change', e => {
                    track.division = parseInt(e.target.value);
                    setupTrackUI(track);
                });
                const swingSlider = track.element.querySelector('.swing-slider');
                const swingValue = track.element.querySelector('.swing-value');
                swingSlider.value = track.swing;
                swingValue.textContent = `${track.swing}%`;
                swingSlider.addEventListener('input', e => {
                    track.swing = parseInt(e.target.value);
                    swingValue.textContent = `${track.swing}%`;
                });
                track.element.querySelector('.remove-track-btn').addEventListener('click', () => removeTrack(track.id));
            }

            function addPattern(duplicate = false) {
                const newPatternId = patternIdCounter++;
                let newTracksData = [];
                if (duplicate && currentPatternId !== null) {
                    const sourcePattern = patterns.find(p => p.id === currentPatternId);
                    if (sourcePattern) {
                        newTracksData = sourcePattern.tracks.map((sourceTrack, index) => ({ ...sourceTrack, id: `${newPatternId}-${index}`, element: null, steps: JSON.parse(JSON.stringify(sourceTrack.steps)), playingNode: null }));
                    }
                }
                patterns.push({ id: newPatternId, name: `P${newPatternId + 1}`, tracks: newTracksData });
                if (patterns.length === 1 && arrangement.length === 0) { arrangement.push(newPatternId); }
                switchPattern(newPatternId);
                renderArrangement();
            }

            function switchPattern(patternId) {
                currentPatternId = patternId;
                renderTracksForCurrentPattern();
                renderPatternList();
            }

            function addTrack() {
                const currentPattern = patterns.find(p => p.id === currentPatternId);
                if (!currentPattern) { return; }
                const trackId = `${currentPatternId}-${currentPattern.tracks.length}`;
                const newTrack = { id: trackId, element: null, audioBuffer: null, fileName: null, division: 16, swing: 50, playingNode: null, normalizationGainDb: 0, balanceFactor: 0.5, originalOpusBlob: null, steps: Array(32).fill(null).map(() => ({ active: false, pitch: 50, gain: 100 })) };
                currentPattern.tracks.push(newTrack);
                renderTracksForCurrentPattern();
            }

            function removeTrack(trackId) {
                const currentPattern = patterns.find(p => p.id === currentPatternId);
                if (!currentPattern) return;
                const trackIndex = currentPattern.tracks.findIndex(t => t.id === trackId);
                if (trackIndex > -1) {
                    currentPattern.tracks.splice(trackIndex, 1);
                    renderTracksForCurrentPattern();
                }
            }
            
            async function togglePlayback() {
                if(isPlaying){
                    sequencerNode.port.postMessage({ type: 'stop' });
                    patterns.forEach(p => p.tracks.forEach(t => t.playingNode = null));
                    dom.playStopBtn.textContent = 'Play';
                    dom.playStopBtn.classList.add('btn-primary');
                    dom.playStopBtn.style.backgroundColor = '';
                    dom.playStopBtn.style.color = '';
                    document.querySelectorAll('.playing').forEach(el => el.classList.remove('playing'));
                    isPlaying = false;
                } else {
                    await initAudio();
                    sequencerNode.port.postMessage({ type: 'setTempo', value: tempo });
                    sequencerNode.port.postMessage({ type: 'start' });
                    dom.playStopBtn.textContent = 'Stop';
                    dom.playStopBtn.classList.remove('btn-primary');
                    dom.playStopBtn.style.backgroundColor = 'var(--accent-cyan)';
                    dom.playStopBtn.style.color = 'var(--bg-main)';
                    isPlaying = true;
                }
            }
            
            // --- SAVE & LOAD ---

            /**
             * [FIXED] This function was missing. It processes an audio buffer by
             * trimming silence and calculating normalization gain.
             */
            function processAudioForSaving(audioBuffer) {
                if (!audioContext || !audioBuffer) {
                    const emptyBuf = audioContext ? audioContext.createBuffer(1, 1, 44100) : null;
                    return { buffer: emptyBuf, normalizationGainDb: 0, balanceFactor: 0.5 };
                }

                // For simplicity, we process as mono, taking the first channel.
                const channelData = audioBuffer.getChannelData(0);
                let firstActiveSample = 0;
                let lastActiveSample = channelData.length - 1;
                const threshold = 0.001; // Silence threshold

                // Pruning: find the first sample above the threshold
                for (let i = 0; i < channelData.length; i++) {
                    if (Math.abs(channelData[i]) > threshold) {
                        firstActiveSample = i;
                        break;
                    }
                }

                // Pruning: find the last sample above the threshold
                for (let i = channelData.length - 1; i >= 0; i--) {
                    if (Math.abs(channelData[i]) > threshold) {
                        lastActiveSample = i;
                        break;
                    }
                }
                
                // Handle completely silent clips to avoid errors
                if (firstActiveSample >= lastActiveSample) {
                    const emptyBuffer = audioContext.createBuffer(1, 1, audioBuffer.sampleRate);
                    return { buffer: emptyBuffer, normalizationGainDb: 0, balanceFactor: 0.5 };
                }

                const trimmedLength = lastActiveSample - firstActiveSample + 1;
                const trimmedData = channelData.slice(firstActiveSample, lastActiveSample + 1);

                // Conditioning: Calculate gain needed to normalize the peak to 0 dBFS.
                // This value is used as a *compensation* during playback.
                let peak = 0;
                for (let i = 0; i < trimmedData.length; i++) {
                    const absSample = Math.abs(trimmedData[i]);
                    if (absSample > peak) {
                        peak = absSample;
                    }
                }
                const normalizationGainDb = peak > 0 ? 20 * Math.log10(1 / peak) : 0;
                
                // Create a new, trimmed audio buffer.
                const newBuffer = audioContext.createBuffer(1, trimmedLength, audioBuffer.sampleRate);
                newBuffer.copyToChannel(trimmedData, 0);

                return {
                    buffer: newBuffer,
                    normalizationGainDb: normalizationGainDb,
                    balanceFactor: 0.5 // Default to center pan as we're converting to mono
                };
            }

            function serializeState(audioAssets, audioBufferMap) {
                // This pre-calculation is fragile but memory-efficient. It must perfectly
                // match the write operations below.
                let totalSize = 5; // Header: tempo(2), arrLen(1), patLen(1), audLen(1)
                totalSize += arrangement.length;
                totalSize += audioAssets.length * (4 + 4 + 4); // sampleRate, normGain, balanceFactor
                const textEncoder = new TextEncoder();
                patterns.forEach(p => {
                    const nameBytes = textEncoder.encode(p.name);
                    totalSize += 3 + nameBytes.length; 
                    p.tracks.forEach(t => {
                        totalSize += 3; // audioIndex, division, swing
                        totalSize += 96; // 32 steps * 3 bytes/step
                    });
                });

                const buffer = new ArrayBuffer(totalSize);
                const view = new DataView(buffer);
                let offset = 0;

                view.setUint16(offset, tempo); offset += 2;
                view.setUint8(offset, arrangement.length); offset += 1;
                view.setUint8(offset, patterns.length); offset += 1;
                view.setUint8(offset, audioAssets.length); offset += 1;
                arrangement.forEach(pId => { view.setUint8(offset, pId === null ? 255 : pId); offset += 1; });
                
                audioAssets.forEach(asset => {
                    view.setUint32(offset, asset.buffer.sampleRate); offset += 4;
                    view.setFloat32(offset, asset.normalizationGainDb); offset += 4;
                    view.setFloat32(offset, asset.balanceFactor); offset += 4;
                });

                patterns.forEach(p => {
                    const nameBytes = textEncoder.encode(p.name);
                    view.setUint8(offset, p.id); offset += 1;
                    view.setUint8(offset, p.tracks.length); offset += 1;
                    view.setUint8(offset, nameBytes.length); offset += 1;
                    nameBytes.forEach(byte => { view.setUint8(offset, byte); offset += 1; });
                    
                    p.tracks.forEach(t => {
                        const audioIndex = t.audioBuffer ? audioBufferMap.get(t.audioBuffer) : 255;
                        view.setUint8(offset, audioIndex); offset += 1;
                        view.setUint8(offset, t.division); offset += 1;
                        view.setUint8(offset, t.swing); offset += 1;
                        
                        t.steps.forEach(step => {
                            view.setUint8(offset, step.active ? 1 : 0); offset += 1;
                            view.setUint8(offset, Math.round(step.pitch)); offset += 1;
                            view.setUint8(offset, Math.round(step.gain)); offset += 1;
                        });
                    });
                });
                return new Blob([buffer]);
            }

            function parseState(buffer, decodedAudios) {
                const view = new DataView(buffer);
                const textDecoder = new TextDecoder();
                let offset = 0;

                tempo = view.getUint16(offset); offset += 2;
                const arrangementLength = view.getUint8(offset); offset += 1;
                const patternCount = view.getUint8(offset); offset += 1;
                const audioAssetCount = view.getUint8(offset); offset += 1;
                dom.tempoSlider.value = tempo;
                dom.tempoValue.textContent = tempo;
                if (sequencerNode) sequencerNode.port.postMessage({ type: 'setTempo', value: tempo });

                arrangement = [];
                for (let i = 0; i < arrangementLength; i++) {
                    const pId = view.getUint8(offset); offset += 1;
                    arrangement.push(pId === 255 ? null : pId);
                }

                const audioMap = [];
                const metadataMap = [];
                for (let i = 0; i < audioAssetCount; i++) {
                    const sampleRate = view.getUint32(offset); offset += 4;
                    const normalizationGainDb = view.getFloat32(offset); offset += 4;
                    const balanceFactor = view.getFloat32(offset); offset += 4;
                    metadataMap[i] = { normalizationGainDb, balanceFactor };
                    const audioData = decodedAudios.find(a => a.index === i);
                    if (audioData) {
                        const audioBuffer = audioContext.createBuffer(1, audioData.pcmData.length, sampleRate);
                        audioBuffer.copyToChannel(audioData.pcmData, 0);
                        audioMap.push({buffer: audioBuffer, originalBlob: audioData.blob});
                    }
                }

                patterns = [];
                let maxId = -1;
                for (let i = 0; i < patternCount; i++) {
                    const pId = view.getUint8(offset); offset += 1;
                    if (pId > maxId) maxId = pId;
                    const trackCount = view.getUint8(offset); offset += 1;
                    const nameLength = view.getUint8(offset); offset += 1;
                    const nameBytes = new Uint8Array(buffer, offset, nameLength);
                    const name = textDecoder.decode(nameBytes); offset += nameLength;
                    
                    const newPattern = { id: pId, name, tracks: [] };
                    for (let j = 0; j < trackCount; j++) {
                        const audioIndex = view.getUint8(offset); offset += 1;
                        const division = view.getUint8(offset); offset += 1;
                        const swing = view.getUint8(offset); offset += 1;
                        
                        const audioAsset = audioIndex === 255 ? null : audioMap[audioIndex];
                        const metadata = audioIndex === 255 ? {} : metadataMap[audioIndex];

                        const newTrack = {
                            id: `${pId}-${j}`, element: null, playingNode: null,
                            audioBuffer: audioAsset ? audioAsset.buffer : null,
                            originalOpusBlob: audioAsset ? audioAsset.originalBlob : null,
                            fileName: audioIndex === 255 ? null : `audio_${audioIndex}.opus`,
                            normalizationGainDb: metadata.normalizationGainDb || 0,
                            balanceFactor: metadata.balanceFactor || 0.5,
                            division, swing, steps: []
                        };
                        
                        for (let k = 0; k < 32; k++) {
                            const active = view.getUint8(offset) === 1; offset += 1;
                            const pitch = view.getUint8(offset); offset += 1;
                            const gain = view.getUint8(offset); offset += 1;
                            newTrack.steps.push({ active, pitch, gain });
                        }
                        newPattern.tracks.push(newTrack);
                    }
                    patterns.push(newPattern);
                }
                patternIdCounter = maxId + 1;
                currentPatternId = patterns[0]?.id ?? null;
            }
            
            async function saveProject() {
                setButtonLoading(dom.saveProjectBtn, true);
                try {
                    const zip = new JSZip();
                    const audioAssets = [];
                    const audioBufferMap = new Map();
                    
                    // Collect unique audio buffers from all tracks and process them.
                    for (const p of patterns) {
                        for (const t of p.tracks) {
                            if (t.audioBuffer && !audioBufferMap.has(t.audioBuffer)) {
                                audioBufferMap.set(t.audioBuffer, audioAssets.length);
                                // [FIXED] Always process the audio on save to apply pruning/conditioning.
                                const processed = processAudioForSaving(t.audioBuffer);
                                audioAssets.push({ 
                                    buffer: processed.buffer, 
                                    normalizationGainDb: processed.normalizationGainDb, 
                                    balanceFactor: processed.balanceFactor,
                                });
                            }
                        }
                    }

                    // [FIXED] Always re-encode the processed audio buffers.
                    const encodedAudioPromises = audioAssets.map(asset => OpusEncoder.encode(asset.buffer));
                    const encodedAudioBlobs = await Promise.all(encodedAudioPromises);
                    encodedAudioBlobs.forEach((blob, i) => zip.file(`audio_${i}.opus`, blob));

                    const stateBlob = serializeState(audioAssets, audioBufferMap);
                    zip.file('project.bin', stateBlob);

                    const content = await zip.generateAsync({ type: 'blob' });
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(content);
                    a.download = `project.wmus`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(a.href);

                } catch (error) {
                    console.error("Failed to save project:", error);
                    alert("Error saving project. Check console for details.");
                } finally {
                    setButtonLoading(dom.saveProjectBtn, false);
                }
            }
            
            async function loadProject(file) {
                 if (!file) return;
                 setButtonLoading(dom.loadProjectBtn, true);
                 try {
                     await initAudio();
                     const zip = await JSZip.loadAsync(file);
                     const projectFile = zip.file('project.bin');
                     if (!projectFile) throw new Error('Invalid project file.');
                     
                     const projectBuffer = await projectFile.async('arraybuffer');

                     const audioFilePromises = Object.values(zip.files)
                         .filter(f => f.name.startsWith('audio_') && !f.dir)
                         .map(async (f) => {
                             const index = parseInt(f.name.split('_')[1].split('.')[0]);
                             const blob = await f.async('blob');
                             const pcmData = await OpusDecoder.decode(blob);
                             return { index, pcmData, blob };
                         });
                     
                     const decodedAudios = await Promise.all(audioFilePromises);
                     decodedAudios.sort((a,b) => a.index - b.index);
                     
                     parseState(projectBuffer, decodedAudios);
                     renderAll();
                 } catch (error) {
                     console.error("Failed to load project:", error);
                 } finally {
                     setButtonLoading(dom.loadProjectBtn, false);
                     dom.loadProjectInput.value = '';
                 }
            }
            
            function setButtonLoading(button, isLoading) {
                const originalText = button.dataset.originalText || button.textContent;
                if (!button.dataset.originalText) { button.dataset.originalText = originalText; }
                if (isLoading) {
                    button.disabled = true;
                    button.innerHTML = `<div class="spinner mr-2"></div><span>Loading...</span>`;
                } else {
                    button.disabled = false;
                    button.innerHTML = originalText;
                }
            }

            // --- EVENT LISTENERS & INITIALIZATION ---
            dom.playStopBtn.addEventListener('click', togglePlayback);
            dom.loopToggleBtn.addEventListener('click', () => { isLooping = !isLooping; dom.loopToggleBtn.classList.toggle('active', isLooping); });
            dom.metronomeToggleBtn.addEventListener('click', () => { isMetronomeOn = !isMetronomeOn; dom.metronomeToggleBtn.classList.toggle('active', isMetronomeOn); });
            dom.tempoSlider.addEventListener('input', e => { tempo = parseInt(e.target.value); dom.tempoValue.textContent = tempo; if (sequencerNode) sequencerNode.port.postMessage({ type: 'setTempo', value: tempo }); });
            dom.addTrackBtn.addEventListener('click', addTrack);
            dom.addPatternBtn.addEventListener('click', () => addPattern(false));
            dom.dupPatternBtn.addEventListener('click', () => addPattern(true));
            dom.saveProjectBtn.addEventListener('click', saveProject);
            dom.loadProjectBtn.addEventListener('click', () => dom.loadProjectInput.click());
            dom.loadProjectInput.addEventListener('change', (e) => loadProject(e.target.files[0]));

            addPattern();
        });
    </script>
</body>
</html>
