<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fiducial Point</title>
    <!--
    ## Fiducial Point - Interactive Visualization ##

    A sophisticated, production-ready interactive splash screen.
    - Node field distribution via Bridson's Algorithm for Blue Noise.
    - Dynamic, orbiting node field with a 3D parallax effect.
    - Hybrid network topology with Delaunay Triangulation in dense regions.
    - High-performance via Time-Decoupled network updates.
    - Optimized nearest-neighbor searches using a Quadtree data structure.
    - Procedural text engine generates unique company principles.
    -->
    <style>
        /* === Core Setup === */
        :root {
            --primary-color: #00aeff;
            --secondary-color: #f0f0f0;
            --background-color: #0a0a1a;
            --container-bg: #1a1a2acc;
            --text-color: #e0e0e0;
            --header-color: #ffffff;
            --border-color: #0077b3;
            --vignette-speed: 1.7s;
            --vignette-opacity: 0.30;
            --vignette-size: 54%;
        }
        html {
            font-size: 16px;
        }
        @media (min-width: 2560px) {
            html { font-size: 18px; }
        }
        @media (min-width: 3840px) {
            html { font-size: 20px; }
        }
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--background-color);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            cursor: pointer;
        }

        /* === UI Elements === */
        .overlay-text {
            position: absolute;
            top: 20px;
            left: 20px;
            color: var(--primary-color);
            opacity: 0.8;
            font-size: 0.875rem;
            pointer-events: none;
            z-index: 2;
        }
        #protocol-toggle {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 3.125rem;
            height: 3.125rem;
            background-color: var(--primary-color);
            border-radius: 50%;
            cursor: pointer;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 10px rgba(0, 174, 255, 0.5);
            transition: transform 0.3s, box-shadow 0.3s;
        }
        #protocol-toggle:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(0, 174, 255, 0.75);
        }
        #protocol-toggle svg {
            width: 1.5rem;
            height: 1.5rem;
            fill: var(--background-color);
        }
        #protocol-panel, #synthesis-panel {
            position: absolute;
            background-color: var(--container-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1.5em;
            color: var(--text-color);
            pointer-events: none;
            text-align: left;
            backdrop-filter: blur(4px);
            box-sizing: border-box;
        }
        #protocol-panel {
            bottom: 5.625rem;
            right: 1.25rem;
            width: 28.125rem;
            max-width: 90vw;
            z-index: 9;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.4s ease, transform 0.4s ease;
            max-height: 80vh;
            overflow-y: auto;
        }
        #protocol-panel.visible {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }
        #protocol-panel h2 {
            color: var(--header-color);
            margin-top: 0;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.5em;
        }
        .protocol-item {
            margin-bottom: 1em;
        }
        .protocol-item strong {
            color: var(--header-color);
            display: block;
        }
        .protocol-item code {
            color: var(--primary-color);
            white-space: pre-wrap;
            font-size: 0.9em;
            display: block;
            background: #00000055;
            padding: 5px;
            border-radius: 4px;
            margin-top: 5px;
        }
        #synthesis-panel {
            min-width: 280px;
            max-width: 90vw;
            border-color: var(--primary-color);
            z-index: 20;
            box-shadow: 0 0 20px #00aeff44;
            word-wrap: break-word;
            line-height: 1.6;
            opacity: 0;
            transform: scale(0.95);
            transition: opacity 0.5s ease, 
                        transform 0.5s ease, 
                        width 0.5s ease;
            pointer-events: none;
            left: -1000px; 
        }
        #synthesis-panel.visible {
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
        }
        #vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, 
                rgba(0,0,0,0) 0%, 
                rgba(0,0,0,0) var(--vignette-size), 
                rgba(0,0,0, var(--vignette-opacity)) 100%);
            pointer-events: none;
            z-index: 5;
            opacity: 0;
            transition: opacity var(--vignette-speed) ease;
        }
        #vignette.visible {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="overlay-text">
        <p>// FIDUCIAL POINT</p>
    </div>

    <div id="vignette"></div>
    <canvas id="unificationCanvas"></canvas>

    <div id="protocol-toggle">
        <svg viewBox="0 0 24 24">
            <path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M11,16.5V14.5H13V16.5H11M11,12.5V7.5H13V12.5H11Z" />
        </svg>
    </div>

    <div id="protocol-panel">
        <h2>About Fiducial Point</h2>
        <div class="protocol-item">
            <strong>Founder</strong>
            <code>David Cache // david@fiducialpoint.com</code>
        </div>
        <div class="protocol-item">
            <strong>Core Competencies</strong>
            <code>Modern Hardware and Software development. Professional Electronics Design, Custom Hardware Engineering, and Advanced Systems Programming.</code>
        </div>
        <div class="protocol-item">
            <strong>Mission</strong>
            <code>Pioneering bleeding-edge electronics solutions by transforming complex engineering challenges into significant market opportunities.</code>
        </div>
    </div>
    
    <div id="synthesis-panel"></div>

    <script>
        // =================================================================
        // Fiducial Point :: Core Application Logic
        // =================================================================

        // --- DOM Elements ---
        const canvas = document.getElementById('unificationCanvas');
        const ctx = canvas.getContext('2d');
        const protocolToggle = document.getElementById('protocol-toggle');
        const protocolPanel = document.getElementById('protocol-panel');
        const synthesisPanel = document.getElementById('synthesis-panel');
        const vignette = document.getElementById('vignette');
        
        // --- Generative Text Engine (Self-Contained) ---
        let themeDeck = [];
        let templateDecks = {};
        let wordBankDecks = {};
        const commonWordBanks = { industry: [ { text: "aerospace and defense" }, { text: "medical technology" }, { text: "robotics" }, { text: "semiconductors" }, { text: "industrial manufacturing" }, { text: "scientific research" }, { text: "automotive" }, { text: "telecommunications" } ], application: [ { text: "mission-specific IoT deployments" }, { text: "industrial automation" }, { text: "robotics and control systems" }, { text: "scientific instrumentation" }, { text: "next-generation consumer electronics" }, { text: "custom test and measurement equipment" } ], hardware_domain: [ { text: "programmable logic (FPGA/CPLD)" }, { text: "high-speed digital systems" }, { text: "low-noise analog front-ends" }, { text: "power electronics and management" }, { text: "embedded SoC integration" }, { text: "RF and wireless design" }, { text: "photonic integrated circuits" }, { text: "gate-level logic design" } ], software_domain: [ { text: "bare-metal firmware" }, { text: "real-time operating systems (RTOS)" }, { text: "edge AI and ML deployment" }, { text: "secure IoT connectivity stacks" }, { text: "hardware abstraction layers (HAL)" }, { text: "hand-rolled OS kernels and drivers" }, { text: "quantum-resistant cryptography" } ], unified_expertise: [ { text: "programmable logic and bare-metal system firmware" }, { text: "high-speed digital systems and RTOS development" }, { text: "embedded SoC integration and secure connectivity stacks" }, { text: "low-noise analog and hardware abstraction layers" }, { text: "power electronics and real-time operating systems" }, { text: "RF and wireless design and secure IoT connectivity stacks" }, { text: "photonic circuits and quantum-resistant cryptography" }, { text: "gate-level logic design and hard real-time scheduling" } ] };
        const themes = [ { name: "Innovation and Pioneering", templates: [ "{action_verb} solutions for the {industry} sector, leveraging deep expertise in {hardware_domain} to solve the challenge of {technical_challenge}.", "The principle of {guiding_principle} delivers {client_advantage} on complex {application} projects.", "Unified expertise in {unified_expertise} directly architects {key_deliverable}, providing {client_advantage}.", "The principle of {guiding_principle} translates client needs in the {application} space into {client_advantage}.", "Solving {technical_challenge} is the direct path to achieving {client_advantage} in the {industry} sector.", "The fusion of {hardware_domain} and {software_domain} makes {key_deliverable} possible.", "{action_verb} the approach to {application} unlocks {client_advantage}.", "Expertise in {unified_expertise} is foundational to creating {key_deliverable}.", "To pioneer in {application}, it takes a mastery of {unified_expertise}.", "By {action_verb} the state-of-the-art in {hardware_domain}, we unlock {client_advantage}.", "The future of the {industry} sector depends on solving challenges like {technical_challenge}.", "We bridge the gap between {hardware_domain} and {software_domain}, creating {key_deliverable} for the {industry} sector.", "Our approach to {technical_challenge} redefines what's possible in {application}.", "By applying {guiding_principle}, we deconstruct {technical_challenge}, resulting in {key_deliverable}.", "True innovation in {application} is achieved by {action_verb} the physics of {hardware_domain}.", "From first principles to final netlist, our mastery of {hardware_domain} results in {key_deliverable}." ], wordBanks: { action_verb: [ { text: "Pioneering" }, { text: "Unifying" }, { text: "Accelerating" }, { text: "Architecting" }, { text: "Redefining" }, { text: "Synthesizing" }, { text: "Deciphering" }, { text: "Instrumenting" }], technical_challenge: [ { text: "complex edge AI deployment" }, { text: "nanosecond-level timing closure" }, { text: "novel system-on-chip integration" }, { text: "ultra-low latency communication" }, { text: "a heterogeneous compute architecture" }, { text: "signal integrity at the physical limit" }, { text: "logic optimization for power and area" }, { text: "implementing emerging compute paradigms on constrained hardware" }], key_deliverable: [ { text: "a first-to-market solution" }, { text: "a highly scalable platform" }, { text: "an unparalleled user experience" }, { text: "a category-defining product" }, { text: "a paradigm-shifting technology" }, { text: "a power-efficient silicon IP block" }], client_advantage: [ { text: "a decisive competitive edge" }, { text: "an accelerated time-to-market" }, { text: "new market opportunities" }, { text: "a foundational technology patent" }, { text: "the creation of a new IP portfolio" }], guiding_principle: [ { text: "first-principles engineering" }, { text: "iterative design and rapid prototyping" }, { text: "a systems-thinking methodology" }, { text: "domain-specific architectural modeling" }, { text: "a register-transfer level (RTL) methodology" }, { text: "model-based systems engineering (MBSE)" }], } }, { name: "Reliability and Mission-Critical Systems", templates: [ "Fiducial Point provides {core_service}, turning the challenge of {technical_challenge} into {key_deliverable}.", "Excellence in {core_service} means solving {technical_challenge} to give clients {client_advantage}.", "Mastery of {unified_expertise} is the cornerstone of every project, resulting in {key_deliverable}.", "Mastering the prototype-to-production path means tackling {technical_challenge} to deliver {key_deliverable}.", "For mission-critical {application}, the principle of {guiding_principle} ensures {key_deliverable}.", "{core_service} directly mitigates project risk, providing {client_advantage}.", "Deep knowledge of {unified_expertise} results in {client_advantage} for high-stakes systems.", "Adherence to {guiding_principle} is non-negotiable when engineering for the {industry} sector.", "For the {industry} sector, {core_service} is a guarantee of {client_advantage}.", "A commitment to {guiding_principle} is how we deliver {key_deliverable} that performs under pressure.", "Navigating {technical_challenge} for mission-critical systems requires deep, unified expertise in {unified_expertise}.", "Our execution of {core_service} provides the {client_advantage} needed for mission-critical {application}.", "Our deep understanding of {hardware_domain} is how we guarantee {key_deliverable} at a gate level.", "For systems deployed in hostile environments, our expertise in {core_service} delivers {key_deliverable} with guaranteed operational integrity." ], wordBanks: { core_service: [ { text: "expert hardware bringup" }, { text: "full-stack system integration" }, { text: "end-to-end electronic design" }, { text: "rigorous design verification" }, { text: "exhaustive failure mode analysis" }, { text: "formal logic verification" }, { text: "worst-case circuit analysis (WCCA)" }, { text: "low-level firmware development from datasheet to deployment" }, { text: "cycle-accurate real-time system design" }, { text: "radiation-hardened SoC architecture" }], technical_challenge: [ { text: "real-time determinism" }, { text: "stringent regulatory compliance" }, { text: "complex silicon bringup" }, { text: "robust system-level integration" }, { text: "a fail-safe system architecture" }, { text: "environmental hardening" }, { text: "electronic design for shock and vibration resilience" }, { text: "single-event upset (SEU) mitigation" }, { text: "metastability avoidance in asynchronous crossings" }, { text: "JTAG-level silicon debug and validation" }, { text: "guaranteeing cycle-level execution" }], key_deliverable: [ { text: "a fault-tolerant system" }, { text: "a mission-critical system" }, { text: "production-ready hardware" }, { text: "a fully-validated and compliant system" }, { text: "a certifiably robust system" }, { text: "a five-nines availability platform" }, { text: "a radiation-tolerant digital design" }, { text: "a fully radiation-hardened system-on-chip" }], client_advantage: [ { text: "reduced development risk" }, { text: "uncompromised system performance" }, { text: "a clear path to mass production" }, { text: "long-term system reliability" }, { text: "predictable project outcomes" }, { text: "unimpeachable system integrity" }, { text: "a provably correct logic implementation" }, { text: "absolute execution predictability" }], guiding_principle: [ { text: "end-to-end ownership" }, { text: "mastery of the full stack" }, { text: "a deep respect for physics" }, { text: "transforming complexity into reliability" }, { text: "design for manufacturability (DFM)" }, { text: "a zero-defect manufacturing protocol" }, { text: "design for testability (DFT)" }, { text: "full-stack ownership from schematic to firmware" }, { text: "an obsession with deterministic behavior" }], } }, { name: "Strategic Partnership and Turnkey Solutions", templates: [ "We offer {partnership_service}, providing clients with {client_advantage} from concept to production.", "Our philosophy of {guiding_principle} ensures a seamless development journey for {application}.", "By providing {partnership_service}, we transform the challenge of {technical_challenge} into {key_deliverable}.", "The value of {partnership_service} is {client_advantage} for our partners in the {industry} sector.", "A commitment to {guiding_principle} builds the trust needed for complex {application} development.", "Expertise in {unified_expertise} enables us to offer true {partnership_service}.", "From initial architecture to final production, our principle of {guiding_principle} delivers {client_advantage}.", "Our {partnership_service} model streamlines the path from initial concept to a scalable {key_deliverable}.", "Navigating the journey to market requires {guiding_principle}, the core of our client partnerships.", "Through {partnership_service}, we convert the problem of {technical_challenge} into {client_advantage}.", "A successful {application} requires more than technology; it demands {guiding_principle}." ], wordBanks: { partnership_service: [ { text: "turnkey product development" }, { text: "a dedicated engineering partnership" }, { text: "end-to-end project management" }, { text: "a transparent development process" }, { text: "strategic technical advisement" }, { text: "BOM lifecycle management" }, { text: "full product lifecycle engineering" } ], technical_challenge: [ { text: "complex supply chain navigation" }, { text: "mass production scaling" }, { text: "multi-vendor technology integration" }, { text: "global certification and compliance" }, { text: "component lifecycle management" }, { text: "semiconductor fab lead time negotiation" } ], key_deliverable: [ { text: "a fully-managed production pipeline" }, { text: "a market-ready product ecosystem" }, { text: "a robust and scalable architecture" }, { text: "a strategically-sourced bill of materials" }, { text: "a vertically-integrated solution" }], client_advantage: [ { text: "a single point of accountability" }, { text: "a de-risked product launch" }, { text: "complete intellectual property ownership" }, { text: "a resilient and future-proof supply chain" }, { text: "an optimized bill-of-materials cost-down" }, { text: "a streamlined path to profitability" }, { text: "a defensible technology moat" }], guiding_principle: [ { text: "radical transparency" }, { text: "a collaborative engineering process" }, { text: "a focus on the entire product lifecycle" }, { text: "a proactive risk mitigation strategy" }, { text: "an agile hardware development methodology" }, { text: "a stage-gate development process" }], } } ];
        function shuffleArray(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[array[i], array[j]] = [array[j], array[i]]; } return array; }
        function getNextUniquePhrase() { if (themeDeck.length === 0) { themeDeck = shuffleArray(Array.from(themes.keys())); } const themeIndex = themeDeck.pop(); const theme = themes[themeIndex]; if (!templateDecks[themeIndex] || templateDecks[themeIndex].length === 0) { templateDecks[themeIndex] = shuffleArray(Array.from(theme.templates.keys())); } const templateIndex = templateDecks[themeIndex].pop(); let phrase = theme.templates[templateIndex]; const placeholders = [...new Set(phrase.match(/{(\w+)}/g))]; placeholders.forEach(placeholder => { const key = placeholder.substring(1, placeholder.length - 1); let originalBank = theme.wordBanks[key] || commonWordBanks[key]; if (!originalBank) return; if (!wordBankDecks[key] || wordBankDecks[key].length === 0) { wordBankDecks[key] = shuffleArray([...originalBank]); } let wordObject = null; const initialDeckSize = wordBankDecks[key].length; for (let i = 0; i < initialDeckSize; i++) { let candidateObject = wordBankDecks[key][wordBankDecks[key].length - 1]; if (!phrase.toLowerCase().includes(candidateObject.text.toLowerCase().split(" ")[0])) { wordObject = wordBankDecks[key].pop(); break; } else { wordBankDecks[key].unshift(wordBankDecks[key].pop()); } } if (wordObject === null) { wordObject = wordBankDecks[key].pop(); } const regex = new RegExp(placeholder, 'g'); phrase = phrase.replace(regex, wordObject.text); }); return phrase.charAt(0).toUpperCase() + phrase.slice(1); }

        // --- Simulation State ---
        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;
        let scalingFactor = Math.max(1, Math.pow(width / 1920, 0.5));
        let nodes = [];
        let edgeMap = new Map();
        let quadtree;
        const maxNodes = 150; 
        let selectedNode = null;
        let hoveredNode = null;
        let globalSpeedMultiplier = 0.2;
        let modalSide = 'right';
        const glowBrightnessMultiplier = 0.90;
        const centralCoreMultiplier = 0.30;
        const pulseSpeedMultiplier = 750;
        const pulseSizeMultiplier = 1.6;
        const minPulseSize = 0.8;

        // --- Final Aesthetic Parameters ---
        const lineThicknessMultiplier = 0.13;
        const edgeFadeSpeed = 0.070;
        const DENSITY_THRESHOLD = 1;
        
        // --- Dynamic Time Scale Parameters ---
        let timeScale = 1.0;
        const baseTimeScale = 0.6;
        const zoomTimeEffect = 3.1;
        const nodeTimeEffect = 0.3;
        const MIN_ZOOM_FOR_EFFECT = 1.5;
        const MAX_ZOOM_FOR_EFFECT = 8.0;

        // --- Performance Optimization: Temporal Decoupling ---
        const networkUpdateInterval = 100; // ms, for 10 updates per second
        let lastNetworkUpdateTime = 0;

        // --- Network Model Parameters ---
        const DENSITY_RADIUS_FACTOR = 0.14; 
        let densityRadius;

        // --- Viewport Camera State ---
        let viewX = width / 2;
        let viewY = height / 2;
        let targetViewX = width / 2;
        let targetViewY = height / 2;
        let zoom = 1.5;
        let targetZoom = 1.5;
        
        // --- Modal Physics State ---
        let modalX = -1000, modalY = -1000;
        let modalVelX = 0, modalVelY = 0;
        let targetModalX = -1000, targetModalY = -1000;
        const springStiffness = 0.04;
        const springDamping = 0.4;

        // --- Quadtree Implementation ---
        class Quadtree {
            constructor(boundary, capacity = 4) {
                this.boundary = boundary; this.capacity = capacity;
                this.points = []; this.divided = false;
            }
            subdivide() {
                const { x, y, width, height } = this.boundary;
                const hw = width / 2, hh = height / 2;
                this.northeast = new Quadtree(createBoundary(x + hw, y, hw, hh), this.capacity);
                this.northwest = new Quadtree(createBoundary(x, y, hw, hh), this.capacity);
                this.southeast = new Quadtree(createBoundary(x + hw, y + hh, hw, hh), this.capacity);
                this.southwest = new Quadtree(createBoundary(x, y + hh, hw, hh), this.capacity);
                this.divided = true;
            }
            insert(point) {
                if (!this.boundary.contains(point)) return false;
                if (this.points.length < this.capacity) { this.points.push(point); return true; }
                if (!this.divided) this.subdivide();
                return this.northeast.insert(point) || this.northwest.insert(point) ||
                       this.southeast.insert(point) || this.southwest.insert(point);
            }
            query(range, found = []) {
                if (!this.boundary.intersects(range)) return found;
                for (const p of this.points) { if (range.contains(p)) found.push(p); }
                if (this.divided) {
                    this.northwest.query(range, found); this.northeast.query(range, found);
                    this.southwest.query(range, found); this.southeast.query(range, found);
                }
                return found;
            }
        }
        function createBoundary(x, y, w, h) {
            return {
                x, y, width: w, height: h,
                contains: point => (point.x >= x && point.x <= x + w && point.y >= y && point.y <= y + h),
                intersects: range => !(range.x > x + w || range.x + range.width < x || range.y > y + h || range.y + range.height < y)
            };
        }

        // --- Delaunay Triangulation Utility ---
        const Delaunay = (() => {
            const EPSILON = 1.0 / 1048576.0;
            function supertriangle(vertices) {
                let xmin = Number.POSITIVE_INFINITY, ymin = Number.POSITIVE_INFINITY,
                    xmax = Number.NEGATIVE_INFINITY, ymax = Number.NEGATIVE_INFINITY,
                    i, dx, dy, dmax, xmid, ymid;
                for (i = vertices.length; i--;) {
                    if (vertices[i].x < xmin) xmin = vertices[i].x;
                    if (vertices[i].x > xmax) xmax = vertices[i].x;
                    if (vertices[i].y < ymin) ymin = vertices[i].y;
                    if (vertices[i].y > ymax) ymax = vertices[i].y;
                }
                dx = xmax - xmin, dy = ymax - ymin, dmax = Math.max(dx, dy);
                xmid = xmin + dx * 0.5, ymid = ymin + dy * 0.5;
                return [{ x: xmid - 20 * dmax, y: ymid - dmax }, { x: xmid, y: ymid + 20 * dmax }, { x: xmid + 20 * dmax, y: ymid - dmax }];
            }
            function circumcircle(vertices, i, j, k) {
                let x1 = vertices[i].x, y1 = vertices[i].y, x2 = vertices[j].x, y2 = vertices[j].y, x3 = vertices[k].x, y3 = vertices[k].y,
                    fabsy1y2 = Math.abs(y1 - y2), fabsy2y3 = Math.abs(y2 - y3),
                    xc, yc, m1, m2, mx1, mx2, my1, my2;
                if (fabsy1y2 < EPSILON && fabsy2y3 < EPSILON) return null;
                if (fabsy1y2 < EPSILON) {
                    m2 = -((x3 - x2) / (y3 - y2)); mx2 = (x2 + x3) / 2.0; my2 = (y2 + y3) / 2.0;
                    xc = (x2 + x1) / 2.0; yc = m2 * (xc - mx2) + my2;
                } else if (fabsy2y3 < EPSILON) {
                    m1 = -((x2 - x1) / (y2 - y1)); mx1 = (x1 + x2) / 2.0; my1 = (y1 + y2) / 2.0;
                    xc = (x3 + x2) / 2.0; yc = m1 * (xc - mx1) + my1;
                } else {
                    m1 = -((x2 - x1) / (y2 - y1)); m2 = -((x3 - x2) / (y3 - y2));
                    mx1 = (x1 + x2) / 2.0; my1 = (y1 + y2) / 2.0; mx2 = (x2 + x3) / 2.0; my2 = (y2 + y3) / 2.0;
                    xc = (m1 * mx1 - m2 * mx2 + my2 - my1) / (m1 - m2);
                    yc = (fabsy1y2 > fabsy2y3) ? m1 * (xc - mx1) + my1 : m2 * (xc - mx2) + my2;
                }
                const dx = x2 - xc, dy = y2 - yc;
                return { i, j, k, x: xc, y: yc, radiusSq: dx * dx + dy * dy };
            }
            return {
                triangulate: function(vertices) {
                    let n = vertices.length, i, j, indices, st, open, closed, edges, dx, dy, a, b, c;
                    indices = new Array(n);
                    for (i = n; i--;) indices[i] = i;
                    indices.sort((i, j) => vertices[j].x - vertices[i].x);
                    st = supertriangle(vertices); vertices.push(st[0], st[1], st[2]);
                    open = [circumcircle(vertices, n + 0, n + 1, n + 2)]; closed = []; edges = [];
                    for (i = indices.length; i--;) {
                        c = indices[i]; edges.length = 0;
                        for (j = open.length; j--;) {
                            dx = vertices[c].x - open[j].x;
                            if (dx > 0 && dx * dx > open[j].radiusSq) { closed.push(open[j]); open.splice(j, 1); continue; }
                            dy = vertices[c].y - open[j].y;
                            if (dx * dx + dy * dy - open[j].radiusSq > EPSILON) continue;
                            edges.push(open[j].i, open[j].j, open[j].j, open[j].k, open[j].k, open[j].i); open.splice(j, 1);
                        }
                        edges = edges.filter((v, i) => edges.indexOf(v) === i);
                        for (j = edges.length; j > 1; j -= 2) {
                            b = edges[j - 1]; a = edges[j - 2];
                            open.push(circumcircle(vertices, a, b, c));
                        }
                    }
                    for (i = open.length; i--;) closed.push(open[i]);
                    vertices.length -= 3;
                    const results = [];
                    for(i = closed.length; i--; ) {
                        if(closed[i].i < n && closed[i].j < n && closed[i].k < n) results.push([closed[i].i, closed[i].j, closed[i].k]);
                    }
                    return results;
                }
            };
        })();

        // --- Node Class Definition ---
        class Node {
            constructor(initialAngle, id) {
                this.id = id;
                this.centerX = width / 2; this.centerY = height / 2; this.scale = Math.random() * 0.7 + 0.3;
                this.radiusXFactor = (Math.random() * (1.0 - centralCoreMultiplier) + centralCoreMultiplier);
                this.radiusYFactor = (Math.random() * 0.5 + 0.3); this.orbitRotation = Math.random() * Math.PI;
                const maxRadius = ((width + height) / 2) / 2.2;
                this.orbitRadiusX = this.radiusXFactor * maxRadius;
                this.orbitRadiusY = this.orbitRadiusX * this.radiusYFactor; this.currentAngle = initialAngle;
                const speedScale = 0.7 + (this.scale * 0.3); this.baseSpeed = (0.0008 + Math.random() * 0.001) * speedScale;
                this.speed = this.baseSpeed * globalSpeedMultiplier; this.x = 0; this.y = 0;
                this.baseRadius = 1.5 * scalingFactor; this.info = null; this.update(1); // Initial position
            }
            update(timeMultiplier) {
                this.currentAngle += this.speed * timeMultiplier;
                const unrotatedX = this.orbitRadiusX * Math.cos(this.currentAngle);
                const unrotatedY = this.orbitRadiusY * Math.sin(this.currentAngle);
                const rotatedX = unrotatedX * Math.cos(this.orbitRotation) - unrotatedY * Math.sin(this.orbitRotation);
                const rotatedY = unrotatedX * Math.sin(this.orbitRotation) + unrotatedY * Math.cos(this.orbitRotation);
                this.x = this.centerX + rotatedX; this.y = this.centerY + rotatedY;
            }
            draw(ctx, isSelected, isHovered, pulse) {
                const displayRadius = this.baseRadius * this.scale + (isSelected ? pulse : 0);
                if (isSelected) { ctx.shadowColor = 'rgba(240, 240, 240, 0.7)'; ctx.shadowBlur = 10 * this.scale; }
                ctx.beginPath(); ctx.arc(this.x, this.y, displayRadius, 0, Math.PI * 2);
                ctx.fillStyle = isSelected ? 'var(--secondary-color)' : (isHovered ? '#bbb' : '#e0e0e0');
                ctx.fill();
                if (isSelected) { ctx.shadowBlur = 0; }
            }
            onResize(newWidth, newHeight, newScalingFactor) {
                this.centerX = newWidth / 2; this.centerY = newHeight / 2;
                const newMaxRadius = ((newWidth + newHeight) / 2) / 2.2;
                this.orbitRadiusX = this.radiusXFactor * newMaxRadius;
                this.orbitRadiusY = this.orbitRadiusX * this.radiusYFactor;
                this.baseRadius = 1.5 * newScalingFactor;
            }
        }
        
        // --- Point & Network Generation ---
        function generateBlueNoiseDistribution(nWidth, nHeight, minDistance, maxPoints) {
            const k = 30, grid = [], activeSamples = [], points = [];
            const cellSize = minDistance / Math.SQRT2;
            const cols = Math.floor(nWidth / cellSize) + 1, rows = Math.floor(nHeight / cellSize) + 1;
            for (let i = 0; i < cols * rows; i++) grid.push(null);
            const p0 = { x: Math.random() * nWidth, y: Math.random() * nHeight };
            activeSamples.push(p0); points.push(p0);
            grid[Math.floor(p0.x / cellSize) + Math.floor(p0.y / cellSize) * cols] = p0;
            while (activeSamples.length > 0 && points.length < maxPoints) {
                const randIndex = Math.floor(Math.random() * activeSamples.length), sample = activeSamples[randIndex];
                let found = false;
                for (let i = 0; i < k; i++) {
                    const angle = Math.random() * Math.PI * 2, radius = Math.random() * minDistance + minDistance;
                    const newSample = { x: sample.x + Math.cos(angle) * radius, y: sample.y + Math.sin(angle) * radius };
                    if (newSample.x >= 0 && newSample.x < nWidth && newSample.y >= 0 && newSample.y < nHeight) {
                        const gridX = Math.floor(newSample.x / cellSize), gridY = Math.floor(newSample.y / cellSize);
                        let isValid = true;
                        for (let y = -2; y <= 2; y++) {
                            for (let x = -2; x <= 2; x++) {
                                const neighborIndex = (gridX + x) + (gridY + y) * cols;
                                if (grid[neighborIndex]) {
                                    const d = Math.sqrt((newSample.x - grid[neighborIndex].x) ** 2 + (newSample.y - grid[neighborIndex].y) ** 2);
                                    if (d < minDistance) { isValid = false; break; }
                                }
                            }
                            if (!isValid) break;
                        }
                        if (isValid) {
                            points.push(newSample); activeSamples.push(newSample);
                            grid[gridX + gridY * cols] = newSample; found = true; break;
                        }
                    }
                }
                if (!found) activeSamples.splice(randIndex, 1);
            }
            const centerX = nWidth / 2, centerY = nHeight / 2;
            return points.map(p => Math.atan2(p.y - centerY, p.x - centerX));
        }

        function updateNetworkTopology() {
            buildQuadtree();
            const currentEdgeKeys = new Set();
            
            const nodeNeighbors = nodes.map(node => quadtree.query(createBoundary(node.x - densityRadius, node.y - densityRadius, densityRadius * 2, densityRadius * 2)).filter(other => other.id !== node.id));
            const isDense = nodes.map((_, i) => nodeNeighbors[i].length >= DENSITY_THRESHOLD);
            const processed = new Array(nodes.length).fill(false);
            
            for (let i = 0; i < nodes.length; i++) {
                if (!isDense[i] || processed[i]) continue;
                const patch = []; const queue = [i]; processed[i] = true;
                while (queue.length > 0) {
                    const currentIndex = queue.shift(); patch.push(nodes[currentIndex]);
                    nodeNeighbors[currentIndex].forEach(neighbor => {
                        if (isDense[neighbor.id] && !processed[neighbor.id]) {
                            processed[neighbor.id] = true; queue.push(neighbor.id);
                        }
                    });
                }

                if (patch.length > 2) {
                    const triangles = Delaunay.triangulate(patch);
                    triangles.forEach(triangle => {
                        [[patch[triangle[0]], patch[triangle[1]]], [patch[triangle[1]], patch[triangle[2]]], [patch[triangle[2]], patch[triangle[0]]]].forEach(pair => {
                            if (!pair[0] || !pair[1]) return;
                             currentEdgeKeys.add([pair[0].id, pair[1].id].sort().join('-'));
                        });
                    });
                }
            }
            for (let i = 0; i < nodes.length; i++) {
                nodeNeighbors[i].forEach(neighbor => {
                    if (nodes[i].id < neighbor.id) {
                        currentEdgeKeys.add([nodes[i].id, neighbor.id].sort().join('-'));
                    }
                });
            }

            for (const [key, edge] of edgeMap.entries()) {
                if (!currentEdgeKeys.has(key)) {
                    edge.targetOpacity = 0; // Mark for fade out
                }
            }
            
            for (const key of currentEdgeKeys) {
                if (!edgeMap.has(key)) {
                    const [id1, id2] = key.split('-');
                    edgeMap.set(key, {
                        source: nodes[id1], target: nodes[id2],
                        currentOpacity: 0, targetOpacity: 1
                    });
                } else {
                    edgeMap.get(key).targetOpacity = 1; // Mark for fade in
                }
            }
        }

        // --- Core Simulation & Rendering ---
        function setDynamicSizes() {
            const minDim = Math.min(width, height);
            densityRadius = minDim * DENSITY_RADIUS_FACTOR;
        }

        function init() {
            nodes = [];
            edgeMap.clear();
            setDynamicSizes();
            const minNodeDistance = 60 * scalingFactor;
            const initialAngles = generateBlueNoiseDistribution(width, height, minNodeDistance, maxNodes);
            for (let i = 0; i < initialAngles.length; i++) {
                nodes.push(new Node(initialAngles[i], i));
            }
            updateNodePhysics();
            updateNetworkTopology();
        }

        function buildQuadtree() {
            const boundary = createBoundary(0, 0, width, height);
            quadtree = new Quadtree(boundary);
            nodes.forEach(node => quadtree.insert(node));
        }

        function updateNodePhysics() {
            nodes.forEach(node => {
                node.speed = node.baseSpeed * globalSpeedMultiplier; 
                node.update(timeScale);
            });
        }
        
        function renderNetwork() {
            const interactiveNodes = new Set([selectedNode, hoveredNode]);
            const edgesToDelete = [];

            for (const [key, edge] of edgeMap.entries()) {
                // Weighted fade animation (easing)
                edge.currentOpacity += (edge.targetOpacity - edge.currentOpacity) * edgeFadeSpeed;

                if (edge.targetOpacity === 0 && edge.currentOpacity < 0.01) {
                    edgesToDelete.push(key);
                    continue;
                }
                if (edge.currentOpacity < 0.01) continue;


                const { source: n1, target: n2 } = edge;
                if (!n1 || !n2) continue;

                const isN1Interactive = interactiveNodes.has(n1);
                const isN2Interactive = interactiveNodes.has(n2);
                
                const dynamicOpacity = (n1.scale + n2.scale) * 0.5;
                const baseOpacity = n1.scale * 0.35 * dynamicOpacity * edge.currentOpacity;

                const color1 = `rgba(0, 174, 255, ${baseOpacity})`;
                const color2 = `rgba(0, 174, 255, ${baseOpacity})`;
                const glow1 = `rgba(240, 240, 240, ${glowBrightnessMultiplier * n1.scale * dynamicOpacity * edge.currentOpacity})`;
                const glow2 = `rgba(240, 240, 240, ${glowBrightnessMultiplier * n2.scale * dynamicOpacity * edge.currentOpacity})`;

                const startColor = isN1Interactive ? glow1 : color1;
                const endColor = isN2Interactive ? glow2 : color2;

                const gradient = ctx.createLinearGradient(n1.x, n1.y, n2.x, n2.y);
                gradient.addColorStop(0, startColor);
                gradient.addColorStop(1, endColor);
                
                ctx.beginPath();
                ctx.moveTo(n1.x, n1.y);
                ctx.lineTo(n2.x, n2.y);
                ctx.strokeStyle = gradient;
                ctx.lineWidth = lineThicknessMultiplier * dynamicOpacity;
                ctx.stroke();
            }

            edgesToDelete.forEach(key => edgeMap.delete(key));
        }
        
        function updateDynamicTimeScale() {
            const zoomFactor = Math.max(0, Math.min(1, (zoom - MIN_ZOOM_FOR_EFFECT) / (MAX_ZOOM_FOR_EFFECT - MIN_ZOOM_FOR_EFFECT)));
            
            let nodeFactor = 0;
            if (selectedNode) {
                // Node scale is 0.3 (far) to 1.0 (close). We want the inverse.
                nodeFactor = 1.0 - ((selectedNode.scale - 0.3) / 0.7);
            }

            timeScale = baseTimeScale + (zoomFactor * zoomTimeEffect) + (nodeFactor * nodeTimeEffect * zoomFactor);
        }

        function animate(timestamp) {
            updateDynamicTimeScale();

            // --- Performance: Time-Decoupled Network Update ---
            if (timestamp - lastNetworkUpdateTime > (networkUpdateInterval / timeScale)) {
                updateNetworkTopology();
                lastNetworkUpdateTime = timestamp;
            }

            // --- Camera Logic ---
            if (selectedNode) {
                let targetNodeScreenX = (modalSide === 'right') ? width / 3 : width * 2 / 3;
                targetViewX = selectedNode.x - (targetNodeScreenX - width / 2) / targetZoom;
                targetViewY = selectedNode.y;
            }
            viewX += (targetViewX - viewX) * 0.08;
            viewY += (targetViewY - viewY) * 0.08;
            zoom += (targetZoom - zoom) * 0.08;

            const minZoom = 1.5, maxZoom = 8.0;
            const minSpeed = 0.20, maxSpeed = 0.60;
            let t = Math.max(0, Math.min(1, (zoom - minZoom) / (maxZoom - minZoom)));
            const targetSpeed = minSpeed + t * (maxSpeed - minSpeed);
            globalSpeedMultiplier += (targetSpeed - globalSpeedMultiplier) * 0.05;

            // --- 60fps Physics & Rendering ---
            updateNodePhysics();
            updateModalPhysics();

            ctx.clearRect(0, 0, width, height);
            ctx.save();
            ctx.translate(width / 2, height / 2);
            ctx.scale(zoom, zoom);
            ctx.translate(-viewX, -viewY);
            
            renderNetwork();

            const sortedNodes = [...nodes].sort((a, b) => a.scale - b.scale);
            // Pulse calculation is now independent of timeScale
            const sine = Math.sin(timestamp / pulseSpeedMultiplier);
            const pulse = selectedNode ? (sine * 0.5 + 0.5) * (pulseSizeMultiplier - minPulseSize) + minPulseSize : 0;
            sortedNodes.forEach(node => node.draw(ctx, node === selectedNode, node === hoveredNode, pulse));
            
            ctx.restore();

            updateSynthesisPanelTargetPosition();
            requestAnimationFrame(animate);
        }

        function updateModalPhysics() {
            if (!selectedNode) return;
            const forceX = (targetModalX - modalX) * springStiffness;
            const forceY = (targetModalY - modalY) * springStiffness;
            const dampingX = modalVelX * springDamping;
            const dampingY = modalVelY * springDamping;
            modalVelX += forceX - dampingX;
            modalVelY += forceY - dampingY;
            modalX += modalVelX;
            modalY += modalVelY;
            if (Math.abs(modalVelX) > 0.01 || Math.abs(modalVelY) > 0.01) {
                synthesisPanel.style.left = `${modalX}px`;
                synthesisPanel.style.top = `${modalY}px`;
            }
        }
        
        // --- UI Logic & Event Handlers ---
        function deselectNodeAndResetView() {
            selectedNode = null;
            synthesisPanel.classList.remove('visible');
            vignette.classList.remove('visible');
            targetViewX = width / 2;
            targetViewY = height / 2;
            targetZoom = 1.5;
        }

        function updateSynthesisPanelTargetPosition() {
            if (!selectedNode) return;
            const panelWidth = synthesisPanel.offsetWidth, panelHeight = synthesisPanel.offsetHeight;
            const screenPadding = 20;
            let idealPanelX = (modalSide === 'right') ? (width * 2 / 3) - (panelWidth / 2) : (width / 3) - (panelWidth / 2);
            const screenY = (selectedNode.y - viewY) * zoom + height / 2;
            let panelY = screenY - panelHeight / 2;
            targetModalY = Math.max(screenPadding, Math.min(panelY, height - panelHeight - screenPadding));
            targetModalX = Math.max(screenPadding, Math.min(idealPanelX, width - panelWidth - screenPadding));
        }
        
        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            scalingFactor = Math.max(1, Math.pow(width / 1920, 0.5));
            nodes.forEach(node => node.onResize(width, height, scalingFactor));
            setDynamicSizes();
            updateNodePhysics();
            updateNetworkTopology();
            if (selectedNode) {
                deselectNodeAndResetView();
            } else {
                targetViewX = width / 2;
                targetViewY = height / 2;
            }
        });

        protocolToggle.addEventListener('click', () => {
            const isOpening = !protocolPanel.classList.contains('visible');
            protocolPanel.classList.toggle('visible');
            if (isOpening) { deselectNodeAndResetView(); }
        });

        canvas.addEventListener('mousemove', (event) => {
            const worldX = (event.clientX - width / 2) / zoom + viewX;
            const worldY = (event.clientY - height / 2) / zoom + viewY;
            const hoverRadius = (30 * scalingFactor) / zoom;
            
            const searchArea = createBoundary(worldX - hoverRadius, worldY - hoverRadius, hoverRadius * 2, hoverRadius * 2);
            const candidates = quadtree ? quadtree.query(searchArea) : [];

            let closestNode = null;
            let minDistanceSq = hoverRadius * hoverRadius;

            for (const node of candidates) {
                const dx = node.x - worldX, dy = node.y - worldY;
                const dSq = dx * dx + dy * dy;
                if (dSq < minDistanceSq) {
                    minDistanceSq = dSq;
                    closestNode = node;
                }
            }
            hoveredNode = closestNode;
        });

        canvas.addEventListener('click', (event) => {
            if (hoveredNode) {
                protocolPanel.classList.remove('visible');
                if (selectedNode === hoveredNode) {
                    deselectNodeAndResetView();
                } else {
                    const isFirstSelection = selectedNode === null;
                    selectedNode = hoveredNode;
                    const TARGET_ON_SCREEN_SCALE = 3.5; 
                    targetZoom = TARGET_ON_SCREEN_SCALE / selectedNode.scale;
                    const screenX = (hoveredNode.x - viewX) * zoom + width / 2;
                    modalSide = (screenX > width / 2) ? 'left' : 'right';
                    if (!selectedNode.info) { selectedNode.info = getNextUniquePhrase(); }
                    synthesisPanel.innerHTML = selectedNode.info;
                    const textLength = selectedNode.info.length;
                    const minWidth = 280 * scalingFactor;
                    const maxWidth = 450 * scalingFactor;
                    const dynamicWidth = minWidth + Math.sqrt(textLength) * (4 * scalingFactor);
                    synthesisPanel.style.width = `${Math.max(minWidth, Math.min(maxWidth, dynamicWidth))}px`;
                    if (isFirstSelection) {
                        setTimeout(() => {
                            updateSynthesisPanelTargetPosition();
                            modalX = targetModalX;
                            modalY = targetModalY;
                        }, 0);
                    }
                    synthesisPanel.classList.add('visible');
                    vignette.classList.add('visible');
                }
            } else {
                 if (!synthesisPanel.contains(event.target)){
                    deselectNodeAndResetView();
                 }
            }
        });

        document.body.addEventListener('click', (event) => {
            const isClickOnInteractive = canvas.contains(event.target) || 
                                         protocolToggle.contains(event.target) || 
                                         protocolPanel.contains(event.target) ||
                                         synthesisPanel.contains(event.target);
            if (!isClickOnInteractive) {
                deselectNodeAndResetView();
                protocolPanel.classList.remove('visible');
            }
        });

        // --- Initialization ---
        window.onload = () => {
            init();
            requestAnimationFrame(animate);
        };
    </script>
</body>
</html>
