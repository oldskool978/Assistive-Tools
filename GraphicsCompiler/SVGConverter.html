<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EdgeLUT Engine</title>
    <style>
        /* Basic styling for a full-screen canvas */
        html, body {
            height: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent scrollbars */
        }
        body {
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #fff;
        }
        #logo-container {
            position: relative;
            width: 90vw;
            height: 90vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #logo-canvas {
            max-width: 100%;
            max-height: 100%;
            display: block;
        }
    </style>
</head>
<body>

    <!-- Canvas container -->
    <div id="logo-container">
        <canvas id="logo-canvas"></canvas>
    </div>

    <!-- Hidden file inputs -->
    <input type="file" id="svg-uploader" accept=".svg" style="display: none;">
    <input type="file" id="lut-uploader" accept=".vis" style="display: none;">

    <script>
        /**
         * EdgeLUT: A low-memory SVG animation engine and LUT compiler.
         * Architecture: A two-phase "Stream then Finalize" model.
         * Phase 1 (Stream): A single-pass decompiler reads the SVG in 4kb chunks, generating
         * raw point geometry and calculating artwork bounds. No intermediate arrays persist.
         * Phase 2 (Finalize): After the stream, a single, fast in-memory pass calculates the
         * centering offset, quantizes the final color palette from raw color data, and maps
         * all buffered points to their correct color index before rendering begins.
         */
        const LogoEngine = {
            config: {
                canvasId: 'logo-canvas',
                defaultSvgMarkup: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="180 250 750 570"><path d="M 396 258 C 275 295, 190 350, 190 450 C 190 560, 250 600, 278 640 C 210 660, 210 700, 256 730 C 350 750, 550 800, 600 810 C 675 790, 800 750, 885 725 C 920 710, 915 690, 866 668 C 830 675, 700 650, 668 617 C 675 550, 680 400, 650 327 C 625 310, 500 300, 456 302 M 396 267 C 390 400, 390 550, 398 603 C 420 610, 670 610, 677 603 C 690 570, 680 450, 668 330 C 650 300, 550 305, 451 307" fill="none" stroke="#000000" stroke-width="2"/></svg>`,
                fallbackStrokeColor: '#0d1a26',
                maxStrokeWidth: 8.5,
                minCurveWidth: 1.5,
                maxPaletteSize: 16,
                visStreamChunkSize: 61440, 
                streamBufferThreshold: 51200, 
                visIntPrecision: 100000,
                svgStreamChunkSize: 4096, // SVG stream workspace size. 4096 bytes balances parsing complete tags and minimizing memory.
                colorSimilarityThreshold: 2500,
            },

            state: {
                canvas: null, ctx: null, animationFrameId: null,
                viewBox: { x: 0, y: 0, width: 400, height: 225 },
                colorPalette: [], 
                rawColorWeights: null, // Stores raw color strings and frequency during the stream phase.
                drawnPointsCount: 0,
                totalPointsInLut: 0,
                currentStrokeIndex: 0, currentPointInStrokeIndex: 0,
                reusablePathForSampling: null,
                maxGeometricStrokeWidth: 0,
                _lcg_seed: 1,
                lastSvgFile: null,
                isStreaming: false,
                isEndOfStream: false,
                streamReader: null,
                dataBuffer: [], 
                renderOffset: { x: 0, y: 0 },
                artworkBounds: null,
            },

            PRECALCULATED: {
                INV_ANIMATION_DURATION_MS: 0.00025,
                INV_LCG_SCALE_H: 0,
                INV_LCG_SCALE_L: 0,
                INV_255_SCALE_H: 1,
                INV_255_SCALE_L: 1,
                EASING_LUT_INT: [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,3,3,4,5,5,6,7,8,9,10,11,12,13,15,16,18,19,21,23,25,27,29,31,34,36,39,42,45,48,51,54,58,62,65,69,73,77,82,86,91,96,101,106,112,117,123,129,135,141,146,151,156,161,166,171,175,180,184,188,192,195,199,202,206,209,212,214,217,220,222,225,227,229,231,233,235,236,238,240,241,242,244,245,246,247,248,249,249,250,251,251,252,252,253,253,253,254,254,254,254,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,254,254,254,253,253,253,252,252,251,251,250,249,249,248,247,246,245,244,242,241,240,238,236,235,233,231,229,227,225,222,220,217,214,212,209,206,202,199,195,192,188,184,180,175,171,166,161,156,151,146,141,135,129,123,117,112,106,101,96,91,86,82,77,73,69,65,62,58,54,51,48,45,42,39,36,34,31,29,27,25,23,21,19,18,16,15,13,12,11,10,9,8,7,6,5,5,4,3,3,2,2,2,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
                EASING_LUT_SCALE: 255.0,
                CURVATURE_LUT_INT: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,4,4,4,4,4,4,5,5,5,5,5,6,6,6,6,7,7,7,7,8,8,8,9,9,9,10,10,10,11,11,11,12,12,13,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,22,22,23,23,24,25,25,26,27,28,28,29,30,30,31,32,33,34,35,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,56,57,58,59,60,62,63,64,66,67,68,70,71,72,74,75,77,78,80,81,83,85,86,88,89,91,93,94,96,98,100,102,103,105,107,109,111,113,115,117,119,121,123,125,127,129,131,134,136,138,140,143,145,147,150,152,155,157,159,162,165,167,170,172,175,178,180,183,186,189,192,194,197,200,203,206,209,212,215,219,222,225,228,231,235,238,241,245,248,252,255],
                CURVATURE_LUT_SCALE: 255.0,
                VELOCITY_LUT_INT: [306,222,209,201,195,190,186,182,178,175,173,170,168,165,163,161,159,158,156,154,153,151,150,148,147,146,144,143,142,141,140,139,138,137,136,135,134,133,132,131,130,129,128,127,127,126,125,124,123,123,122,121,120,120,119,118,118,117,116,116,115,114,114,113,113,112,111,111,110,110,109,109,108,107,107,106,106,105,105,104,104,103,103,102,102,101,101,100,100,99,99,98,98,98,97,97,96,96,95,95,95,94,94,93,93,92,92,92,91,91,90,90,90,89,89,89,88,88,87,87,87,86,86,86,85,85,85,84,84,83,83,83,82,82,82,81,81,81,80,80,80,79,79,79,79,78,78,78,77,77,77,76,76,76,75,75,75,75,74,74,74,73,73,73,73,72,72,72,71,71,71,71,70,70,70,69,69,69,69,68,68,68,68,67,67,67,67,66,66,66,66,65,65,65,65,64,64,64,64,63,63,63,63,62,62,62,62,61,61,61,61,60,60,60,60,60,59,59,59,59,58,58,58,58,58,57,57,57,57,56,56,56,56,56,55,55,55,55,54,54,54,54,54,53,53,53,53,53,52,52,52,52,52,51,51,51],
                VELOCITY_LUT_SCALE: 306.0,
                SIN_LUT_INT: new Int16Array([0,402,804,1206,1608,2009,2410,2811,3212,3612,4011,4410,4808,5205,5602,5998,6393,6786,7179,7571,7962,8351,8739,9126,9512,9896,10278,10659,11039,11417,11793,12167,12539,12910,13279,13645,14010,14372,14732,15090,15446,15800,16151,16499,16846,17189,17530,17869,18204,18537,18868,19195,19519,19841,20159,20475,20787,21096,21403,21705,22005,22301,22594,22884,23170,23452,23731,24007,24279,24547,24811,25072,25329,25582,25832,26077,26319,26556,26790,27019,27245,27466,27683,27896,28105,28310,28510,28706,28898,29085,29268,29447,29621,29791,29956,30117,30273,30424,30571,30714,30852,30985,31113,31237,31356,31470,31580,31685,31785,31880,31971,32057,32137,32213,32285,32351,32412,32469,32521,32567,32609,32646,32678,32705,32728,32745,32757,32765,32767,32765,32757,32745,32728,32705,32678,32646,32609,32567,32521,32469,32412,32351,32285,32213,32137,32057,31971,31880,31785,31685,31580,31470,31356,31237,31113,30985,30852,30714,30571,30424,30273,30117,29956,29791,29621,29447,29268,29085,28898,28706,28510,28310,28105,27896,27683,27466,27245,27019,26790,26556,26319,26077,25832,25582,25329,25072,24811,24547,24279,24007,23731,23452,23170,22884,22594,22301,22005,21705,21403,21096,20787,20475,20159,19841,19519,19195,18868,18537,18204,17869,17530,17189,16846,16499,16151,15800,15446,15090,14732,14372,14010,13645,13279,12910,12539,12167,11793,11417,11039,10659,10278,9896,9512,9126,8739,8351,7962,7571,7179,6786,6393,5998,5602,5205,4808,4410,4011,3612,3212,2811,2410,2009,1608,1206,804,402,0,-401,-803,-1205,-1607,-2008,-2409,-2810,-3211,-3611,-4010,-4409,-4807,-5204,-5601,-5997,-6392,-6785,-7178,-7570,-7961,-8350,-8738,-9125,-9511,-9895,-10277,-10658,-11038,-11416,-11792,-12166,-12538,-12909,-13278,-13644,-14009,-14371,-14731,-15089,-15445,-15799,-16150,-16498,-16845,-17188,-17529,-17868,-18203,-18536,-18867,-19194,-19518,-19840,-20158,-20474,-20786,-21095,-21402,-21704,-22004,-22300,-22593,-22883,-23169,-23451,-23730,-24006,-24278,-24546,-24810,-25071,-25328,-25581,-25831,-26076,-26318,-26555,-26789,-27018,-27244,-27465,-27682,-27895,-28104,-28309,-28509,-28705,-28897,-29084,-29267,-29446,-29620,-29790,-29955,-30116,-30272,-30423,-30570,-30713,-30851,-30984,-31112,-31236,-31355,-31469,-31579,-31684,-31784,-31879,-31970,-32056,-32136,-32212,-32284,-32350,-32411,-32468,-32520,-32566,-32608,-32645,-32677,-32704,-32727,-32744,-32756,-32764,-32766,-32764,-32756,-32744,-32727,-32704,-32677,-32645,-32608,-32566,-32520,-32468,-32411,-32350,-32284,-32212,-32136,-32056,-31970,-31879,-31784,-31684,-31579,-31469,-31355,-31236,-31112,-30984,-30851,-30713,-30570,-30423,-30272,-30116,-29955,-29790,-29620,-29446,-29267,-29084,-28897,-28705,-28509,-28309,-28104,-27895,-27682,-27465,-27244,-27018,-26789,-26555,-26318,-26076,-25831,-25581,-25328,-25071,-24810,-24546,-24278,-24006,-23730,-23451,-23169,-22883,-22593,-22300,-22004,-21704,-21402,-21095,-20786,-20474,-20158,-19840,-19518,-19194,-18867,-18536,-18203,-17868,-17529,-17188,-16845,-16498,-16150,-15799,-15445,-15089,-14731,-14371,-14009,-13644,-13278,-12909,-12538,-12166,-11792,-11416,-11038,-10658,-10277,-9895,-9511,-9125,-8738,-8350,-7961,-7570,-7178,-6785,-6392,-5997,-5601,-5204,-4807,-4409,-4010,-3611,-3211,-2810,-2409,-2008,-1607,-1205,-803,-401]),
                SOLVER_LUT_SCALE: 16,
                SOLVER_LUT_INT: [0,415,830,1245,1660,2076,2491,2906,3321,3736,4152,4567,4982,5397,5812,6228,6643,7058,7473,7888,8304,8719,9134,9549,9965,10380,10795,11210,11625,12041,12456,12871,13286,13701,14117,14532,14947,15362,15777,16193,16608,17023,17438,17853,18269,18684,19099,19514,19930,20345,20760,21175,21590,22006,22421,22836,23251,23666,24082,24497,24912,25327,25742,26158,26573,26988,27403,27818,28234,28649,29064,29479,29895,30310,30725,31140,31555,31971,32386,32801,33216,33631,34047,34462,34877,35292,35707,36123,36538,36953,37368,37784,38199,38614,39029,39444,39860,40275,40690,41105,41520,41936,42351,42766,43181,43596,44012,44427,44842,45257,45672,46088,46503,46918,47333,47749,48164,48579,48994,49409,49825,50240,50655,51070,51485,51901,52316,52731,53146,53561,53977,54392,54807,55222,55637,56053,56468,56883,57298,57714,58129,58544,58959,59374,59790,60205,60620,61035,61450,61866,62281,62696,63111,63526,63942,64357,64772,65187,65602,66018,66433,66848,67263,67679,68094,68509,68924,69339,69755,70170,70585,71000,71415,71831,72246,72661,73076,73491,73907,74322,74737,75152,75568,75983,76398,76813,77228,77644,78059,78474,78889,79304,79720,80135,80550,80965,81380,81796,82211,82626,83041,83456,83872,84287,84702,85117,85533,85948,86363,86778,87193,87609,88024,88439,88854,89269,89685,90100,90515,90930,91345,91761,92176,92591,93006,93421,93837,94252,94667,95082,95498,95913,96328,96743,97158,97574,97989,98404,98819,99234,99650,100065,100480,100895,101310,101726,102141,102556,102971,103386,103802,104217,104632,105047,105463,105878,106293,106708,107123,107539,107954,108369,108784,109199,109615,110030,110445,110860,111275,111691,112106,112521,112936,113352,113767,114182,114597,115012,115428,115843,116258,116673,117088,117504,117919,118334,118749,119164,119580,119995,120410,120825,121240,121656,122071,122486,122901,123317,123732,124147,124562,124977,125393,125808,126223,126638,127053,127469,127884,128299,128714,129129,129545,129960,130375,130790,131205,131621,132036,132451,132866,133282,133697,134112,134527,134942,135358,135773,136188,136603,137018,137434,137849,138264,138679,139094,139510,139925,140340,140755,141170,141586,142001,142416,142831,143247,143662,144077,144492,144907,145323,145738,146153,146568,146983,147399,147814,148229,148644,149059,149475,149890,150305,150720,151136,151551,151966,152381,152796,153212,153627,154042,154457,154872,155288,155703,156118,156533,156948,157364,157779,158194,158609,159024,159440,159855,160270,160685,161101,161516,161931,162346,162761,163177,163592,164007,164422,164837,165253,165668,166083,166498,166913,167329,167744,168159,168574,168989,169405,169820,170235,170650,171066,171481,171896,172311,172726,173142,173557,173972,174802,175218,175633,176048,176463,176878,177294,177709,178124,178539,178955,179370,179785,180200,180615,181031,181446,181861,182276,182691,183107,183522,183937,184352,184767,185183,185598,186013,186428,186843,187259,187674,188089,188504,188920,189335,189750,190165,190580,190996,191411,191826,192241,192656,193072,193487,193902,194317,194732,195148,195563,195978,196393,196808,197224,197639,198054,198469,198885,199300,199715,200130,200545,200961,201376,201791,202206,202621,203037,203452,203867,204282,204697,205113,205528,205943,206358,206773,207189,207604,208019,208434,208850,209265,209680,210095,210510,210926,211341,211756,212171,212586],
            },

            // --- Animation & Math Helpers ---
            animationProfile: (p) => {
                const lut = LogoEngine.PRECALCULATED.EASING_LUT_INT;
                const floatIndex = p * (lut.length - 1);
                return LogoEngine._interpolateFromLut(lut, floatIndex);
            },

            _interpolateFromLut: function(lut, floatIndex, wrap = false, wrapLength = 0) {
                const lutLength = wrap ? (wrapLength > 0 ? wrapLength : lut.length) : lut.length;
                const index1 = floatIndex | 0;
                const fraction = floatIndex - index1;
                const performInterpolation = (v1, v2) => v1 + ( ((v2 - v1) * (fraction * 256)) >> 8 );
                if (wrap) {
                    const i1 = index1 & (lutLength - 1);
                    const i2 = (i1 + 1) & (lutLength - 1);
                    return performInterpolation(lut[i1], lut[i2]);
                }
                if (index1 >= lutLength - 1) return lut[lutLength - 1];
                if (index1 < 0) return lut[0];
                return performInterpolation(lut[index1], lut[index1 + 1]);
            },

            // --- Core Methods: Unified Ingestion and Rendering ---
            init: function() {
                this.state.canvas = document.getElementById(this.config.canvasId);
                if (!this.state.canvas) return;
                this.state.ctx = this.state.canvas.getContext('2d', { willReadFrequently: true });
                this.state.reusablePathForSampling = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                
                this.Streamer.parent = this;

                const svgUploader = document.getElementById('svg-uploader');
                const lutUploader = document.getElementById('lut-uploader');
                
                window.addEventListener('keydown', (e) => {
                    if (e.target.matches('input, textarea')) return;
                    const key = e.key.toLowerCase();
                    if (key === 'b') svgUploader.click();
                    else if (key === 's') this._saveLutToFile();
                    else if (key === 'l') lutUploader.click();
                });
                svgUploader.addEventListener('change', (e) => {
                    if (!e.target.files[0]) return;
                    this.state.lastSvgFile = e.target.files[0];
                    this.Streamer.init(e.target.files[0], true);
                    e.target.value = '';
                });
                lutUploader.addEventListener('change', (e) => {
                    if (!e.target.files[0]) return;
                    this.state.lastSvgFile = null;
                    this.Streamer.init(e.target.files[0], false);
                    e.target.value = '';
                });
                window.addEventListener('resize', () => {
                    if (this.state.streamReader) {
                        this.startAnimation(this.state.totalPointsInLut);
                    }
                });
                const defaultFile = new File([new Blob([this.config.defaultSvgMarkup], {type: 'image/svg+xml'})], "default.svg");
                this.state.lastSvgFile = defaultFile;
                requestAnimationFrame(() => this.Streamer.init(defaultFile, true));
            },

            startAnimation: function(pointsForPacing) {
                if (!this.state.canvas || !this.state.ctx) return;
                cancelAnimationFrame(this.state.animationFrameId);
                this.state.drawnPointsCount = 0;
                this.state.currentStrokeIndex = 0;
                this.state.currentPointInStrokeIndex = 0;
                const container = document.getElementById('logo-container');
                if (!container) return;
                const containerRect = container.getBoundingClientRect();
                if (containerRect.width === 0 || containerRect.height === 0) {
                    requestAnimationFrame(() => this.startAnimation(pointsForPacing));
                    return;
                }
                this._setupCanvas(containerRect);
                this._renderLoop(pointsForPacing);
            },

            // --- Rendering and Animation ---
            _setupCanvas: function(containerRect) {
                const { canvas, viewBox } = this.state;
                const dpr = window.devicePixelRatio || 1;
                const padding = (this.state.maxGeometricStrokeWidth * 0.5) + this.config.maxStrokeWidth;
                const effectiveViewBox = { width: viewBox.width + padding * 2, height: viewBox.height + padding * 2 };
                const scale = Math.min(containerRect.width / effectiveViewBox.width, containerRect.height / effectiveViewBox.height);
                const canvasWidth = effectiveViewBox.width * scale;
                const canvasHeight = effectiveViewBox.height * scale;
                canvas.width = canvasWidth * dpr;
                canvas.height = canvasHeight * dpr;
                canvas.style.width = `${canvasWidth}px`;
                canvas.style.height = `${canvasHeight}px`;
            },

            _renderLoop: function(pointsForPacing) {
                const { ctx, colorPalette, viewBox } = this.state;
                if (!ctx) return;
                const dataSource = this.state.dataBuffer;
                const pacingTotalPoints = pointsForPacing;
                if (pacingTotalPoints === 0 && this.state.isEndOfStream) return;

                let startTime = null;
                let currentPos = {x: 0, y: 0};
                let dynamicRate = 10;

                const animationFrame = (timestamp) => {
                    if (!startTime) startTime = timestamp;
                    let elapsedTime = timestamp - startTime;

                    if (this.state.drawnPointsCount < this.state.totalPointsInLut || (!this.state.isEndOfStream && dataSource.length > 0) ) {
                        if (elapsedTime > 200 && this.state.drawnPointsCount < 50 && this.state.totalPointsInLut > 100) {
                            dynamicRate = Math.min(50, dynamicRate + 1);
                        }
                        elapsedTime = (elapsedTime * dynamicRate) / 10;
                        const targetPointsToDraw = (elapsedTime * this.PRECALCULATED.INV_ANIMATION_DURATION_MS * pacingTotalPoints) | 0;

                        if(this.state.drawnPointsCount < targetPointsToDraw) {
                            ctx.save();
                            const dpr = window.devicePixelRatio || 1;
                            const padding = (this.state.maxGeometricStrokeWidth * 0.5) + this.config.maxStrokeWidth;
                            const scale = Math.min((ctx.canvas.width / dpr) / (viewBox.width + padding * 2), (ctx.canvas.height / dpr) / (viewBox.height + padding * 2));
                            
                            const translateX = (-viewBox.x + padding + this.state.renderOffset.x) * scale * dpr;
                            const translateY = (-viewBox.y + padding + this.state.renderOffset.y) * scale * dpr;

                            ctx.setTransform(scale * dpr, 0, 0, scale * dpr, translateX, translateY);
                            ctx.lineCap = 'round';
                            ctx.lineJoin = 'round';

                            let drawnPoints = this.state.drawnPointsCount;
                            let strokeIdx = this.state.currentStrokeIndex;
                            let pointIdx = this.state.currentPointInStrokeIndex;

                            while (drawnPoints < targetPointsToDraw && strokeIdx < dataSource.length) {
                                const currentStroke = dataSource[strokeIdx].stroke;
                                if (pointIdx === 0) {
                                    if (!currentStroke || currentStroke.length < 2) { strokeIdx++; continue; }
                                    currentPos.x = currentStroke[0].x;
                                    currentPos.y = currentStroke[0].y;
                                    ctx.moveTo(currentPos.x, currentPos.y);
                                    pointIdx = 1;
                                }
                                if (pointIdx >= currentStroke.length) { pointIdx = 0; strokeIdx++; continue; }
                                
                                const prevPos = { ...currentPos };
                                const deltaPoint = currentStroke[pointIdx];
                                currentPos.x += deltaPoint.dx;
                                currentPos.y += deltaPoint.dy;
                                const colorData = colorPalette[deltaPoint.colorIndex] || {r:0,g:0,b:0,a:1};
                                const colorStr = `rgba(${colorData.r},${colorData.g},${colorData.b},${colorData.a})`;
                                if (ctx.strokeStyle !== colorStr) ctx.strokeStyle = colorStr;
                                
                                ctx.beginPath();
                                ctx.moveTo(prevPos.x, prevPos.y);
                                ctx.lineWidth = deltaPoint.width;
                                ctx.lineTo(currentPos.x, currentPos.y);
                                ctx.stroke();
                                
                                drawnPoints++;
                                pointIdx++;
                            }
                            this.state.drawnPointsCount = drawnPoints;
                            this.state.currentStrokeIndex = strokeIdx;
                            this.state.currentPointInStrokeIndex = pointIdx;
                            ctx.restore();
                        }
                    }
                    this.state.animationFrameId = requestAnimationFrame(animationFrame);
                };
                this.state.animationFrameId = requestAnimationFrame(animationFrame);
            },

            // --- LUT Generation, Saving, and Loading ---
            _toVisInt: (num) => (num * LogoEngine.config.visIntPrecision) | 0,
            _fromVisInt: (int) => int / LogoEngine.config.visIntPrecision,

            _saveLutToFile: function() {
                if (this.state.dataBuffer.length === 0) {
                    console.error("No animation data in the buffer to save.");
                    return;
                }
                
                let visString = `v${this._toVisInt(this.state.viewBox.x)},${this._toVisInt(this.state.viewBox.y)},${this._toVisInt(this.state.viewBox.width)},${this._toVisInt(this.state.viewBox.height)}|`;
                visString += `c${this._toVisInt(this.state.renderOffset.x)},${this._toVisInt(this.state.renderOffset.y)}|`;
                visString += `m${this._toVisInt(this.state.maxGeometricStrokeWidth)}|`;
                visString += `p${JSON.stringify(this.state.colorPalette)}|`;
                visString += `i1,${this.state.totalPointsInLut}|`;

                const tableString = this.state.dataBuffer.map(strokeData => {
                    const stroke = strokeData.stroke;
                    if (stroke.length < 2) return '';
                    const start = `x${this._toVisInt(stroke[0].x)}y${this._toVisInt(stroke[0].y)}`;
                    const deltas = stroke.slice(1).map(p => `d${this._toVisInt(p.dx)},${this._toVisInt(p.dy)}c${p.colorIndex}w${this._toVisInt(p.width)}`).join('');
                    return start + deltas;
                }).join('S');

                visString += `t${tableString}`;

                const blob = new Blob([visString], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'animation.vis';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            },

            _solver: function(svgTextChunk) {
                const commandRegex = /[MmLlHhVvCcSsQqTtAaZz]/g;
                let complexity = 0;
                const costs = { M: 1, L: 2, H: 2, V: 2, C: 5, S: 4, Q: 4, T: 3, A: 5, Z: 1 };
                const dRegex = /d\s*=\s*"([^"]+)"/gi;
                let match;
                while ((match = dRegex.exec(svgTextChunk)) !== null) {
                    const commands = match[1].match(commandRegex) || [];
                    commands.forEach(cmd => { complexity += costs[cmd.toUpperCase()] || 1; });
                }
                if (complexity === 0) return 21179; // Fallback
                if (complexity >= 8191) return (complexity * 26) | 0;
                const floatIndex = complexity / this.PRECALCULATED.SOLVER_LUT_SCALE;
                return this._interpolateFromLut(this.PRECALCULATED.SOLVER_LUT_INT, floatIndex);
            },
            
            // --- Helper and State Functions ---
            _resetAnimationState: function() {
                cancelAnimationFrame(this.state.animationFrameId);
                this.state.drawnPointsCount = 0;
                this.state.currentStrokeIndex = 0;
                this.state.currentPointInStrokeIndex = 0;
                this.state.totalPointsInLut = 0;
                this.state.streamReader = null;
                this.state.isStreaming = false;
                this.state.isEndOfStream = false;
                this.state.dataBuffer = [];
                this.state.renderOffset = { x: 0, y: 0 };
                this.state.artworkBounds = null;
                this.state.colorPalette = [];
                this.state.rawColorWeights = new Map();
                if (this.state.ctx) this.state.ctx.reset();
            },
            _parseAttributes: function(attrString) {
                const attrs = {};
                if (!attrString) return attrs;
                const attrRegex = /([a-zA-Z0-9\-_:]+)\s*=\s*(?:"([^"]*)"|'([^']*)'|[^\s]+)/g;
                let match;
                while ((match = attrRegex.exec(attrString)) !== null) {
                    attrs[match[1]] = match[2] ?? match[3] ?? match[0].split('=')[1];
                }
                return attrs;
            },
            _parseStyleAttribute: function(s) {
                return s.split(';').reduce((styles, p) => {
                    const parts = p.split(':');
                    if (parts.length === 2) styles[parts[0].trim()] = parts[1].trim();
                    return styles;
                }, {});
            },
            _quantizeWithWeightedKMeans: function(weightedColors, k) {
                if (weightedColors.length <= k) return weightedColors.map(wc => wc.color);
                let centroids = [];
                let colorsCopy = [...weightedColors];
                
                const totalWeight = colorsCopy.reduce((sum, wc) => sum + wc.weight, 0);
                let rand = this._lcg() * totalWeight;
                let chosenIndex = colorsCopy.findIndex(wc => (rand -= wc.weight) <= 0);
                if (chosenIndex === -1) chosenIndex = colorsCopy.length - 1;
                centroids.push(colorsCopy.splice(chosenIndex, 1)[0].color);
                
                while (centroids.length < k && colorsCopy.length > 0) {
                    let distances = colorsCopy.map(wc => {
                        let minDistanceSq = Infinity;
                        for (let i = 0; i < centroids.length; i++) {
                            const distSq = this._colorUtils.colorDistanceSq(wc.color, centroids[i]);
                            if (distSq < minDistanceSq) minDistanceSq = distSq;
                        }
                        return minDistanceSq * wc.weight;
                    });
                    const distSum = distances.reduce((sum, d) => sum + d, 0);
                    rand = this._lcg() * distSum;
                    chosenIndex = distances.findIndex(d => (rand -= d) <= 0);
                    if (chosenIndex === -1) chosenIndex = colorsCopy.length - 1;
                    centroids.push(colorsCopy.splice(chosenIndex, 1)[0].color);
                }

                for (let iter = 0; iter < 20; iter++) {
                    const clusters = Array.from({ length: k }, () => []);
                    weightedColors.forEach(wc => {
                        let closestCentroidIndex = 0, minDistance = Infinity;
                        for (let i = 0; i < centroids.length; i++) {
                            const dist = this._colorUtils.colorDistanceSq(wc.color, centroids[i]);
                            if (dist < minDistance) {
                                minDistance = dist;
                                closestCentroidIndex = i;
                            }
                        }
                        clusters[closestCentroidIndex].push(wc);
                    });
                    
                    let hasChanged = false;
                    const newCentroids = clusters.map((cluster, i) => {
                        if (cluster.length === 0) return centroids[i];
                        const clusterWeight = cluster.reduce((sum, wc) => sum + wc.weight, 0);
                        if (clusterWeight === 0) return centroids[i];
                        
                        const totalColor = cluster.reduce((acc, wc) => ({
                            r: acc.r + wc.color.r * wc.weight, g: acc.g + wc.color.g * wc.weight,
                            b: acc.b + wc.color.b * wc.weight, a: acc.a + wc.color.a * wc.weight
                        }), {r:0, g:0, b:0, a:0});
                        
                        const invClusterWeight = 1.0 / clusterWeight;
                        const newCentroid = {
                            r: (totalColor.r * invClusterWeight + 0.5) | 0, g: (totalColor.g * invClusterWeight + 0.5) | 0,
                            b: (totalColor.b * invClusterWeight + 0.5) | 0, a: totalColor.a * invClusterWeight
                        };
                        
                        if (!centroids[i] || newCentroid.r !== centroids[i].r || newCentroid.g !== centroids[i].g || newCentroid.b !== centroids[i].b) {
                            hasChanged = true;
                        }
                        return newCentroid;
                    });
                    centroids = newCentroids;
                    if (!hasChanged) break;
                }
                return centroids;
            },
            _streamProcessSVG: function(animatablePath, pointCallback) {
                const { EASING_LUT_SCALE, CURVATURE_LUT_SCALE, VELOCITY_LUT_SCALE } = this.PRECALCULATED;
                const absolutePos = { x: 0, y: 0 };
                const pathData = animatablePath;

                const path = this.state.reusablePathForSampling;
                path.setAttribute('d', pathData.path);
                const length = path.getTotalLength();
                if (length === 0) return;
                const inv_length = 1.0 / length;

                let samplingStep = length * 0.002;
                samplingStep = samplingStep < 1.0 ? samplingStep : 1.0;
                samplingStep = samplingStep > 0.25 ? samplingStep : 0.25;
                
                let currentSegment = [], lastPoint = null;
                for (let i = 0; i < length; i += samplingStep) {
                    const point = path.getPointAtLength(i);
                    let width;
                    let velocityFactor = 1.0;

                    if (lastPoint) {
                        const dx = point.x - lastPoint.x, dy = point.y - lastPoint.y;
                        let n = dx * dx + dy * dy;
                        n = (n + 1) * 0.5;
                        const distance = n - (n*n- (dx*dx+dy*dy)) / (2*n);

                        let normalizedDistance = distance * 0.2 > 1.0 ? 1.0 : distance * 0.2;
                        const lut = this.PRECALCULATED.VELOCITY_LUT_INT;
                        const floatIndex = normalizedDistance * (lut.length - 1);
                        let lutValue = this._interpolateFromLut(lut, floatIndex);
                        velocityFactor = lutValue / VELOCITY_LUT_SCALE;
                    }

                    if (pathData.isOriginalStroke) {
                        let curvatureFactor = 1.0;
                        if (i > 0 && i < length - samplingStep) {
                            const p_prev = path.getPointAtLength(i - samplingStep);
                            const p_curr = point;
                            const p_next = path.getPointAtLength(i + samplingStep);
                            const v1_x = p_curr.x - p_prev.x, v1_y = p_curr.y - p_prev.y;
                            const v2_x = p_next.x - p_curr.x, v2_y = p_next.y - p_curr.y;
                            const dot = v1_x * v2_x + v1_y * v2_y;
                            const denominator = samplingStep * samplingStep;
                            if (denominator > 0.001) {
                                let cosTheta = dot / denominator;
                                cosTheta = cosTheta > 1.0 ? 1.0 : (cosTheta < -1.0 ? -1.0 : cosTheta);
                                
                                const lut = this.PRECALCULATED.CURVATURE_LUT_INT;
                                const floatIndex = (cosTheta + 1.0) * 0.5 * (lut.length - 1);
                                let lutValue = this._interpolateFromLut(lut, floatIndex);
                                curvatureFactor = lutValue / CURVATURE_LUT_SCALE;
                            }
                        }
                        const progress = i * inv_length;
                        const swellFactor = this.animationProfile(progress) / EASING_LUT_SCALE;
                        let animatedBaseWidth = pathData.strokeWidth > 1.0 ? pathData.strokeWidth : 1.0;
                        const baseWidth = animatedBaseWidth + swellFactor * (this.config.maxStrokeWidth - animatedBaseWidth);
                        width = this.config.minCurveWidth + (baseWidth - this.config.minCurveWidth) * curvatureFactor;
                        width *= velocityFactor;
                    } else {
                        const progress = i * inv_length;
                        const swellFactor = this.animationProfile(progress) / EASING_LUT_SCALE;
                        if (pathData.type === 'fill') {
                            const animatedBaseWidth = 2.0;
                            width = animatedBaseWidth + swellFactor * (this.config.maxStrokeWidth - animatedBaseWidth);
                        } else {
                            width = this.config.maxStrokeWidth;
                        }
                    }

                    let tempWidth = width > this.config.maxStrokeWidth * 1.5 ? this.config.maxStrokeWidth * 1.5 : width;
                    width = tempWidth < 0.5 ? 0.5 : tempWidth;

                    const pointData = { width, color: pathData.color, opacity: pathData.opacity, type: pathData.type };
                    if (!lastPoint) {
                        currentSegment.push({ x: point.x, y: point.y, ...pointData });
                        absolutePos.x = point.x;
                        absolutePos.y = point.y;
                    } else {
                        const dx = point.x - lastPoint.x;
                        const dy = point.y - lastPoint.y;
                        currentSegment.push({ dx, dy, ...pointData });
                        absolutePos.x += dx;
                        absolutePos.y += dy;
                    }
                    
                    if (!this.state.artworkBounds) {
                        this.state.artworkBounds = { minX: absolutePos.x, maxX: absolutePos.x, minY: absolutePos.y, maxY: absolutePos.y };
                    } else {
                        this.state.artworkBounds.minX = Math.min(this.state.artworkBounds.minX, absolutePos.x);
                        this.state.artworkBounds.maxX = Math.max(this.state.artworkBounds.maxX, absolutePos.x);
                        this.state.artworkBounds.minY = Math.min(this.state.artworkBounds.minY, absolutePos.y);
                        this.state.artworkBounds.maxY = Math.max(this.state.artworkBounds.maxY, absolutePos.y);
                    }

                    lastPoint = point;
                }
                if (currentSegment.length > 1) {
                    this.state.totalPointsInLut += currentSegment.length - 1;
                    pointCallback(currentSegment);
                }
            },
            _getPathDataFromNode: function(node) {
                const tagName = node.tagName.toLowerCase();
                switch(tagName) {
                    case 'path': return node.getAttribute('d');
                    case 'rect': {
                        const w = +node.getAttribute('width') || 0, h = +node.getAttribute('height') || 0;
                        if (w <= 0 || h <= 0) return '';
                        const x = +node.getAttribute('x') || 0, y = +node.getAttribute('y') || 0;
                        let rx = +node.getAttribute('rx') || 0, ry = +node.getAttribute('ry') || rx;
                        rx = rx < w * 0.5 ? rx : w * 0.5;
                        ry = ry < h * 0.5 ? ry : h * 0.5;
                        if (rx > 0 || ry > 0) return `M${x + rx},${y} h${w - 2 * rx} a${rx},${ry} 0 0 1 ${rx},${ry} v${h - 2 * ry} a${rx},${ry} 0 0 1 ${-rx},${ry} h${-(w - 2 * rx)} a${rx},${ry} 0 0 1 ${-rx},${-ry} v${-(h - 2 * ry)} a${rx},${ry} 0 0 1 ${rx},${-ry} Z`;
                        return `M${x},${y} h${w} v${h} h${-w} Z`;
                    }
                    case 'circle': {
                        const r = +node.getAttribute('r') || 0; if (r <= 0) return '';
                        const cx = +node.getAttribute('cx') || 0, cy = +node.getAttribute('cy') || 0, r2 = r * 2;
                        return `M ${cx - r},${cy} a ${r},${r} 0 1,0 ${r2},0 a ${r},${r} 0 1,0 -${r2},0`;
                    }
                    case 'ellipse': {
                        const rx = +node.getAttribute('rx') || 0, ry = +node.getAttribute('ry') || 0;
                        if (rx <= 0 || ry <= 0) return '';
                        const cx = +node.getAttribute('cx') || 0, cy = +node.getAttribute('cy') || 0, rx2 = rx * 2;
                        return `M ${cx - rx},${cy} a ${rx},${ry} 0 1,0 ${rx2},0 a ${rx},${ry} 0 1,0 -${rx2},0`;
                    }
                    case 'line': {
                        const x1 = +node.getAttribute('x1') || 0, y1 = +node.getAttribute('y1') || 0, x2 = +node.getAttribute('x2') || 0, y2 = +node.getAttribute('y2') || 0;
                        return `M ${x1} ${y1} L ${x2} ${y2}`;
                    }
                    case 'polyline': case 'polygon': {
                        const points = (node.getAttribute('points')||'').trim().split(/[\s,]+/).map(p => +p || 0);
                        if (points.length < 2) return '';
                        let d = `M ${points[0]} ${points[1]}`;
                        for(let i=2; i<points.length; i+=2) d += ` L ${points[i]} ${points[i+1]}`;
                        if (tagName === 'polygon') d += ' Z';
                        return d;
                    }
                    default: return '';
                }
            },
            _lcg: function() {
                const { INV_LCG_SCALE_H, INV_LCG_SCALE_L } = this.PRECALCULATED;
                const invScale = (((INV_LCG_SCALE_H << 8) | INV_LCG_SCALE_L) / 65535.0) * 4294967296.0;
                this.state._lcg_seed = (this.state._lcg_seed * 1664525 + 1013904223) | 0;
                return (this.state._lcg_seed >>> 0) * invScale;
            },
            _matrixHelper: {
                identity: () => [1, 0, 0, 1, 0, 0],
                isIdentity: (m) => m.every((val, i) => val === (i === 0 || i === 3 ? 1 : 0)),
                multiply: (m1, m2) => [
                    m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1],
                    m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3],
                    m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]
                ],
                transformPoint: (x, y, m) => ({ x: m[0] * x + m[2] * y + m[4], y: m[1] * x + m[3] * y + m[5] }),
                translate: (tx, ty) => [1, 0, 0, 1, tx, ty],
                scale: (sx, sy) => [sx, 0, 0, sy, 0, 0],
                rotate: function(angle, cx = 0, cy = 0) {
                    const lut = LogoEngine.PRECALCULATED.SIN_LUT_INT;
                    const inv_scale = 1.0 / 32767.0;
                    const getTrigValue = (angleInDegrees) => {
                        const floatIndex = (angleInDegrees / 360) * 360;
                        const interpolatedValue = LogoEngine._interpolateFromLut(lut, floatIndex, true, 360);
                        return interpolatedValue * inv_scale;
                    };
                    const sin = getTrigValue(angle), cos = getTrigValue(angle + 90);
                    const m = [cos, sin, -sin, cos, 0, 0];
                    if (cx !== 0 || cy !== 0) {
                        const m1 = this.translate(cx, cy), m2 = this.translate(-cx, -cy);
                        return this.multiply(m1, this.multiply(m, m2));
                    }
                    return m;
                }
            },
            _parseTransform: function(transformString) {
                let matrix = this._matrixHelper.identity();
                if (!transformString) return matrix;
                const regex = /(\w+)\s*\(([^)]+)\)/g;
                let match;
                while ((match = regex.exec(transformString)) !== null) {
                    const [_, type, valueStr] = match;
                    const values = valueStr.trim().split(/[\s,]+/).map(v => +v.trim());
                    if (values.some(isNaN)) continue;
                    let transformMatrix;
                    switch (type) {
                        case 'translate': transformMatrix = this._matrixHelper.translate(values[0], values[1] || 0); break;
                        case 'scale': transformMatrix = this._matrixHelper.scale(values[0], values[1] ?? values[0]); break;
                        case 'rotate': transformMatrix = this._matrixHelper.rotate(values[0], values[1] || 0, values[2] || 0); break;
                        case 'matrix': transformMatrix = values.length === 6 ? values : this._matrixHelper.identity(); break;
                        default: transformMatrix = this._matrixHelper.identity();
                    }
                    matrix = this._matrixHelper.multiply(matrix, transformMatrix);
                }
                return matrix;
            },
            _applyTransformBySampling: function(pathData, matrix) {
                if (!matrix || this._matrixHelper.isIdentity(matrix)) return pathData;
                const path = this.state.reusablePathForSampling;
                path.setAttribute('d', pathData);
                const len = path.getTotalLength();
                if (len === 0) return '';
                const p0 = path.getPointAtLength(0);
                const transformedP0 = this._matrixHelper.transformPoint(p0.x, p0.y, matrix);
                let newPath = `M${transformedP0.x.toFixed(2)} ${transformedP0.y.toFixed(2)}`;
                const step = len * 0.005 > 0.5 ? len * 0.005 : 0.5;
                for (let i = step; i <= len; i += step) {
                    const p = path.getPointAtLength(i);
                    const transformedP = this._matrixHelper.transformPoint(p.x, p.y, matrix);
                    newPath += ` L${transformedP.x.toFixed(2)} ${transformedP.y.toFixed(2)}`;
                }
                if (pathData.trim().toUpperCase().endsWith('Z')) newPath += ' Z';
                return newPath;
            },
            _colorUtils: {
                _colorCanvasCtx: null,
                _initColorCanvas() {
                    if (!this._colorCanvasCtx) {
                        const canvas = document.createElement('canvas');
                        canvas.width = 1; canvas.height = 1;
                        this._colorCanvasCtx = canvas.getContext('2d', { willReadFrequently: true });
                    }
                    return this._colorCanvasCtx;
                },
                parseColor(colorStr, opacity = 1) {
                    if (!colorStr || typeof colorStr !== 'string' || colorStr.toLowerCase() === 'none') {
                        return { r: 0, g: 0, b: 0, a: 0 };
                    }
                    const ctx = this._initColorCanvas();
                    ctx.clearRect(0, 0, 1, 1);
                    ctx.fillStyle = colorStr;
                    ctx.fillRect(0, 0, 1, 1);
                    const [r, g, b, a_255] = ctx.getImageData(0, 0, 1, 1).data;
                    const { INV_255_SCALE_H, INV_255_SCALE_L } = LogoEngine.PRECALCULATED;
                    const invScale = (((INV_255_SCALE_H << 8) | INV_255_SCALE_L) / 65535.0);
                    return { r, g, b, a: (a_255 * invScale) * opacity };
                },
                colorDistanceSq(c1, c2) {
                    const dr = c1.r - c2.r, dg = c1.g - c2.g, db = c1.b - c2.b;
                    return dr*dr + dg*dg + db*db;
                },
                interpolateColor(c1, c2, factor) {
                    return {
                        r: c1.r + (c2.r - c1.r) * factor,
                        g: c1.g + (c2.g - c1.g) * factor,
                        b: c1.b + (c2.b - c1.b) * factor,
                        a: c1.a + (c2.a - c1.a) * factor,
                    };
                },
                findClosestPaletteIndex(color, palette) {
                    let bestMatchIndex = 0, minDistance = Infinity;
                    palette.forEach((paletteRgba, index) => {
                        const distance = this.colorDistanceSq(color, paletteRgba);
                        if (distance < minDistance) {
                            minDistance = distance;
                            bestMatchIndex = index;
                        }
                    });
                    return bestMatchIndex;
                }
            },
        };

        // ===================================================================================
        // UNIFIED STREAMER OBJECT
        // ===================================================================================
        LogoEngine.Streamer = {
            parent: null,
            _svg: {
                partialData: "",
                transformStack: [],
                styleStack: [],
                tagRegex: /<\/?([a-zA-Z0-9]+)((?:\s+[a-zA-Z0-9\-_:]+(?:\s*=\s*(?:"[^"]*"|'[^']*'))?)*)\s*\/?>/g,
            },
            _vis: {
                partialStrokeData: "",
            },

            async init(file, isSvg) {
                this.parent._resetAnimationState();
                this.parent.state.isStreaming = true;
                this.parent.state.streamReader = { file, readPosition: 0, isReading: false, isSvg };

                if (isSvg) {
                    await this.SVG.init();
                } else {
                    this.VIS.init();
                }
            },

            // --- .VIS ROUTINE ---
            VIS: {
                init() {
                    const S = LogoEngine.Streamer;
                    S._vis.partialStrokeData = "";
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        const text = e.target.result;
                        const headerEndIndex = text.indexOf('|t');
                        if (headerEndIndex === -1) { console.error("Invalid .vis file"); return; }
                        
                        const headerText = text.substring(0, headerEndIndex);
                        S.parent.state.streamReader.readPosition = headerEndIndex + 2;
                        const pointsForPacing = S.VIS._parseHeader(headerText);

                        while(!S.parent.state.isEndOfStream) {
                            await S.VIS._fetchChunk();
                        }
                        S.parent.startAnimation(pointsForPacing);
                    };
                    reader.readAsText(S.parent.state.streamReader.file.slice(0, 2048));
                },
                async _fetchChunk() {
                    const S = LogoEngine.Streamer;
                    const { streamReader } = S.parent.state;
                    if (streamReader.isReading) return;
                    streamReader.isReading = true;

                    const { file, readPosition } = streamReader;
                    if (readPosition >= file.size) {
                        S.parent.state.isEndOfStream = true;
                        streamReader.isReading = false;
                        if (S._vis.partialStrokeData) {
                            S.VIS._parseChunk(S._vis.partialStrokeData);
                            S._vis.partialStrokeData = "";
                        }
                        return;
                    }

                    const end = readPosition + S.parent.config.visStreamChunkSize;
                    const blob = file.slice(readPosition, end);
                    const textChunk = await blob.text();

                    const combinedText = S._vis.partialStrokeData + textChunk;
                    const lastSeparator = combinedText.lastIndexOf('S');
                    
                    let chunkToParse;
                    if (lastSeparator === -1 && end < file.size) {
                        S._vis.partialStrokeData = combinedText;
                        chunkToParse = "";
                    } else {
                        chunkToParse = combinedText.substring(0, lastSeparator > -1 ? lastSeparator : undefined);
                        S._vis.partialStrokeData = lastSeparator > -1 ? combinedText.substring(lastSeparator + 1) : "";
                    }

                    streamReader.readPosition += blob.size;
                    S.VIS._parseChunk(chunkToParse);
                    streamReader.isReading = false;
                },
                _parseHeader(headerText) {
                    const P = LogoEngine;
                    const parts = headerText.split('|');
                    let pointsForPacing = 0;
                    parts.forEach(part => {
                        if (!part) return;
                        const token = part[0];
                        const data = part.substring(1);
                        switch(token) {
                            case 'v':
                                const vb = data.split(',').map(v => P._fromVisInt(parseInt(v, 10)));
                                if (vb.length === 4) P.state.viewBox = { x: vb[0], y: vb[1], width: vb[2], height: vb[3] };
                                break;
                            case 'c':
                                const offset = data.split(',').map(v => P._fromVisInt(parseInt(v, 10)));
                                if (offset.length === 2) P.state.renderOffset = { x: offset[0], y: offset[1] };
                                break;
                            case 'm':
                                P.state.maxGeometricStrokeWidth = P._fromVisInt(parseInt(data, 10));
                                break;
                            case 'p':
                                P.state.colorPalette = JSON.parse(data);
                                break;
                            case 'i':
                                const info = data.split(',').map(v => parseInt(v, 10));
                                if (info[0] === 1) {
                                    pointsForPacing = info[1];
                                    P.state.totalPointsInLut = info[1];
                                }
                                break;
                        }
                    });
                    return pointsForPacing;
                },
                _parseChunk(chunkText) {
                    const P = LogoEngine;
                    if (!chunkText) return;
                    const strokes = chunkText.split('S').filter(s => s);
                    strokes.forEach(strokeStr => {
                        if (!strokeStr) return;
                        const stroke = [];
                        const regex = /([xycdw])([\-0-9,]+)/g;
                        let match, currentPoint = {}, isStart = true;
                        while ((match = regex.exec(strokeStr))) {
                            const [_, type, values] = match;
                            if (isStart) {
                                if (type === 'x') currentPoint.x = P._fromVisInt(parseInt(values, 10));
                                if (type === 'y') {
                                    currentPoint.y = P._fromVisInt(parseInt(values, 10));
                                    stroke.push(currentPoint);
                                    currentPoint = {};
                                    isStart = false;
                                }
                            } else {
                                if (type === 'd') {
                                    const [dx, dy] = values.split(',').map(v => P._fromVisInt(parseInt(v, 10)));
                                    currentPoint.dx = dx; currentPoint.dy = dy;
                                }
                                if (type === 'c') currentPoint.colorIndex = parseInt(values, 10);
                                if (type === 'w') {
                                    currentPoint.width = P._fromVisInt(parseInt(values, 10));
                                    stroke.push(currentPoint);
                                    currentPoint = {};
                                }
                            }
                        }
                        if (stroke.length > 1) {
                            const size = new Blob([strokeStr]).size + 1;
                            P.state.dataBuffer.push({ stroke, size });
                        }
                    });
                },
            },

            // --- SVG ROUTINE (Single-Pass Refactor) ---
            SVG: {
                async init() {
                    const S = LogoEngine.Streamer;
                    const P = S.parent;
                    
                    S._svg.partialData = "";
                    S._svg.transformStack = [P._matrixHelper.identity()];
                    S._svg.styleStack = [{ fill: 'black', 'fill-opacity': 1, stroke: 'none', 'stroke-opacity': 1, 'stroke-width': 1, color: '#000' }];
                    P.state.totalPointsInLut = 0;

                    const firstChunk = await S.SVG._fetchChunkForPass();
                    const pacingPoints = P._solver(firstChunk); 
                    
                    S.SVG._parseAndProcessSvgChunk(firstChunk);
                    
                    while (P.state.streamReader.readPosition < P.state.streamReader.file.size) {
                        const chunkText = await S.SVG._fetchChunkForPass();
                        S.SVG._parseAndProcessSvgChunk(chunkText);
                    }
                    
                    if (S._svg.partialData) {
                        S.SVG._parseAndProcessSvgChunk(S._svg.partialData, true);
                    }
                    P.state.isEndOfStream = true;

                    S.SVG._finalize();
                    
                    P.startAnimation(pacingPoints);
                },
                
                _finalize() {
                    const P = LogoEngine.Streamer.parent;
                    const { artworkBounds, viewBox, rawColorWeights, dataBuffer } = P.state;
                    
                    if (artworkBounds) {
                        const artworkCenterX = artworkBounds.minX + (artworkBounds.maxX - artworkBounds.minX) * 0.5;
                        const artworkCenterY = artworkBounds.minY + (artworkBounds.maxY - artworkBounds.minY) * 0.5;
                        const viewBoxCenterX = viewBox.x + viewBox.width * 0.5;
                        const viewBoxCenterY = viewBox.y + viewBox.height * 0.5;
                        P.state.renderOffset.x = viewBoxCenterX - artworkCenterX;
                        P.state.renderOffset.y = viewBoxCenterY - artworkCenterY;
                    }

                    const weightedColors = Array.from(rawColorWeights.values());
                    let finalPalette = weightedColors.length <= P.config.maxPaletteSize
                        ? weightedColors.map(item => item.color)
                        : P._quantizeWithWeightedKMeans(weightedColors, P.config.maxPaletteSize);

                    if (finalPalette.length === 0) {
                        finalPalette.push(P._colorUtils.parseColor(P.config.fallbackStrokeColor, 1));
                    }
                    P.state.colorPalette = finalPalette;

                    dataBuffer.forEach(strokeData => {
                        strokeData.stroke.forEach(point => {
                            if (point.color) {
                                const rgba = P._colorUtils.parseColor(point.color, point.opacity);
                                point.colorIndex = P._colorUtils.findClosestPaletteIndex(rgba, finalPalette);
                                delete point.color;
                                delete point.opacity;
                            }
                        });
                    });
                },

                async _fetchChunkForPass() {
                    const P = LogoEngine.Streamer.parent;
                    const reader = P.state.streamReader;
                    const start = reader.readPosition;
                    const end = start + P.config.svgStreamChunkSize;
                    const blob = reader.file.slice(start, end);
                    const text = await blob.text();
                    reader.readPosition += blob.size;
                    return text;
                },
                
                _parseAndProcessSvgChunk(chunkText, isFinalChunk = false) {
                    const S = LogoEngine.Streamer;
                    const P = S.parent;
                    const chunkShapes = [];

                    const combinedText = S._svg.partialData + chunkText;
                    let chunkToParse;

                    if (isFinalChunk) {
                        chunkToParse = combinedText;
                        S._svg.partialData = "";
                    } else {
                        const lastTagEnd = combinedText.lastIndexOf('>');
                        if (lastTagEnd === -1) {
                            S._svg.partialData = combinedText;
                            return;
                        }
                        chunkToParse = combinedText.substring(0, lastTagEnd + 1);
                        S._svg.partialData = combinedText.substring(lastTagEnd + 1);
                    }

                    S._svg.tagRegex.lastIndex = 0;
                    let match;
                    while ((match = S._svg.tagRegex.exec(chunkToParse))) {
                        const tagName = match[1].toLowerCase();
                        if (match[0].startsWith('</')) {
                            if (['g', 'svg'].includes(tagName)) {
                                if (S._svg.transformStack.length > 1) S._svg.transformStack.pop();
                                if (S._svg.styleStack.length > 1) S._svg.styleStack.pop();
                            }
                        } else {
                            const attrs = P._parseAttributes(match[2]);
                            if (tagName === 'svg' && attrs.viewBox) {
                                const vb = attrs.viewBox.split(/[\s,]+/).map(Number);
                                if (vb.length === 4) P.state.viewBox = { x: vb[0], y: vb[1], width: vb[2], height: vb[3] };
                            }

                            if (['g', 'svg'].includes(tagName)) {
                                S.SVG._pushState(attrs);
                                if (match[0].endsWith('/>')) {
                                    S._svg.transformStack.pop();
                                    S._svg.styleStack.pop();
                                }
                            } else if (['path', 'rect', 'circle', 'ellipse', 'line', 'polygon', 'polyline'].includes(tagName)) {
                                S.SVG._processShape(tagName, attrs, chunkShapes);
                            }
                        }
                    }
                    
                    S.SVG._orderAndProcessShapes(chunkShapes);
                },
                _orderAndProcessShapes(shapes) {
                    const S = LogoEngine.Streamer;
                    const P = S.parent;

                    shapes.forEach(p => {
                        const rgba = P._colorUtils.parseColor(p.color, p.opacity);
                        if (rgba.a > 0) {
                            const key = `${rgba.r},${rgba.g},${rgba.b},${rgba.a}`;
                            if (!P.state.rawColorWeights.has(key)) P.state.rawColorWeights.set(key, { color: rgba, weight: 0 });
                            P.state.rawColorWeights.get(key).weight++;
                        }
                    });

                    const animatablePaths = [];
                    const hasStrokesInCollection = shapes.some(p => p.isOriginalStroke);
                    const hasFillsInCollection = shapes.some(p => p.type === 'fill');
                    
                    animatablePaths.push(...shapes.filter(p => p.type === 'fill'));
                    
                    if (hasStrokesInCollection) {
                        animatablePaths.push(...shapes.filter(p => p.type === 'stroke'));
                    } else if (hasFillsInCollection) {
                        const strokesFromFills = shapes.filter(p => p.type === 'fill').map(p => ({ 
                            ...p, type: 'stroke', strokeWidth: 2, isOriginalStroke: false 
                        }));
                        animatablePaths.push(...strokesFromFills);
                    }
                    
                    animatablePaths.forEach(path => {
                        P._streamProcessSVG(path, (segment) => {
                            const size = JSON.stringify(segment).length;
                            P.state.dataBuffer.push({ stroke: segment, size });
                        });
                    });
                },
                _pushState(attrs) {
                    const S = LogoEngine.Streamer;
                    const P = S.parent;
                    const parentStyle = S._svg.styleStack[S._svg.styleStack.length - 1] || {};
                    const newStyle = { ...parentStyle, ...P._parseStyleAttribute(attrs.style || '') };
                    ['fill', 'fill-opacity', 'stroke', 'stroke-opacity', 'stroke-width', 'color'].forEach(key => {
                        if (attrs[key] != null) newStyle[key] = attrs[key];
                    });
                    if (newStyle.fill === 'currentColor') newStyle.fill = newStyle.color;
                    if (newStyle.stroke === 'currentColor') newStyle.stroke = newStyle.color;
                    S._svg.styleStack.push(newStyle);

                    const parentTransform = S._svg.transformStack[S._svg.transformStack.length - 1] || P._matrixHelper.identity();
                    const localTransform = attrs.transform ? P._parseTransform(attrs.transform) : P._matrixHelper.identity();
                    S._svg.transformStack.push(P._matrixHelper.multiply(parentTransform, localTransform));
                },
                _processShape(tagName, attrs, collection) {
                    const S = LogoEngine.Streamer;
                    const P = S.parent;
                    const currentStyle = { ...(S._svg.styleStack[S._svg.styleStack.length - 1] || {}), ...attrs };
                    const currentTransform = S._svg.transformStack[S._svg.transformStack.length - 1] || P._matrixHelper.identity();
                    const pathData = P._getPathDataFromNode({ tagName, getAttribute: (name) => currentStyle[name] });
                    if (!pathData) return;

                    const subPaths = pathData.trim().split(/(?=M|m)/g).filter(s => s.trim());
                    
                    subPaths.forEach(subPathData => {
                        const transformedPath = P._applyTransformBySampling(subPathData, currentTransform);
                        
                        const fillOpacity = parseFloat(currentStyle['fill-opacity']) || 1;
                        const hasFill = currentStyle.fill && currentStyle.fill !== 'none' && fillOpacity > 0;
                        
                        const strokeWidth = parseFloat(currentStyle['stroke-width']) || 0;
                        const strokeOpacity = parseFloat(currentStyle['stroke-opacity']) || 1;
                        const hasStroke = currentStyle.stroke && currentStyle.stroke !== 'none' && strokeWidth > 0 && strokeOpacity > 0;

                        if (hasFill) {
                            collection.push({ path: transformedPath, type: 'fill', color: currentStyle.fill, opacity: fillOpacity, isOriginalStroke: false, strokeWidth: P.config.maxStrokeWidth });
                        }
                        if (hasStroke) {
                            if(strokeWidth > P.state.maxGeometricStrokeWidth) P.state.maxGeometricStrokeWidth = strokeWidth;
                            collection.push({ path: transformedPath, type: 'stroke', color: currentStyle.stroke, opacity: strokeOpacity, isOriginalStroke: true, strokeWidth: strokeWidth });
                        }
                    });
                },
            }
        };

        LogoEngine.init();
    </script>
</body>
</html>
