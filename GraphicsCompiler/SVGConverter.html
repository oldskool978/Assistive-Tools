<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EdgeLUT Engine</title>
    <style>
        /* Basic styling for a full-screen canvas */
        html, body {
            height: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
        }
        body {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #logo-container {
            position: relative;
            width: 90vw;
            height: 90vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #logo-canvas {
            max-width: 100%;
            max-height: 100%;
            display: block;
        }
    </style>
</head>
<body>

    <!-- Canvas container -->
    <div id="logo-container">
        <canvas id="logo-canvas"></canvas>
    </div>

    <!-- Hidden file inputs -->
    <input type="file" id="svg-uploader" accept=".svg" style="display: none;">
    <input type="file" id="lut-uploader" accept=".vis" style="display: none;">

    <script>
        /**
         * EdgeLUT: SVG animation engine and LUT compiler.
         * Renders vector animations from pre-calculated data tables (LUTs).
         * Optimized for low-compute environments via integer math and bitwise operations.
         */
        const LogoEngine = {
            config: {
                canvasId: 'logo-canvas',
                defaultSvgMarkup: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="180 250 750 570"><path d="M 396 258 C 275 295, 190 350, 190 450 C 190 560, 250 600, 278 640 C 210 660, 210 700, 256 730 C 350 750, 550 800, 600 810 C 675 790, 800 750, 885 725 C 920 710, 915 690, 866 668 C 830 675, 700 650, 668 617 C 675 550, 680 400, 650 327 C 625 310, 500 300, 456 302 M 396 267 C 390 400, 390 550, 398 603 C 420 610, 670 610, 677 603 C 690 570, 680 450, 668 330 C 650 300, 550 305, 451 307" fill="none" stroke="#000000" stroke-width="2"/></svg>`,
                fallbackStrokeColor: '#0d1a26',
                maxStrokeWidth: 8.5,
                minCurveWidth: 1.5,
                maxPaletteSize: 16,
                // Configuration for the streaming system based on memory profiling
                streamChunkSize: 131072, // 128 KB
                streamBufferThreshold: 1, // Fetch next chunk only when the buffer is completely empty.
            },

            state: {
                canvas: null, ctx: null, lookupTable: null, animationFrameId: null,
                viewBox: { x: 0, y: 0, width: 400, height: 225 },
                colorPalette: [], cssRules: new Map(), drawnPointsCount: 0,
                totalPointsInLut: 0,
                currentStrokeIndex: 0, currentPointInStrokeIndex: 0,
                clipPathCache: new Map(), reusablePathForSampling: null,
                maxGeometricStrokeWidth: 0,
                _lcg_seed: 1,
                lastSvgText: '', // Cache the last loaded SVG for saving
                
                // State for the streaming system
                isStreaming: false,
                isEndOfStream: false,
                streamReader: null, 
                dataBuffer: [], // In-memory buffer for strokes { stroke: [], sizeInBits: 0 }
            },
            
            PRECALCULATED: {
                // --- Core Animation & Timing ---
                INV_ANIMATION_DURATION_MS: 0.00025,

                // --- High-Precision Inverse Constants (Two-Byte Fixed-Point) ---
                INV_VIS_INT_SCALE_H: 0,
                INV_VIS_INT_SCALE_L: 7, // Represents 1/10000 as a fixed-point 16-bit number (0.0001 * 65535 = 6.55)
                INV_LCG_SCALE_H: 0,
                INV_LCG_SCALE_L: 0, // Note: LCG scale is handled differently
                INV_255_SCALE_H: 1,
                INV_255_SCALE_L: 1, // Represents 1/255 as a fixed-point 16-bit number (1/255 * 65535 = 257)

                // --- Look-Up Tables & Scales ---
                EASING_LUT_INT: [0,0,0,0,1,1,1,2,2,3,4,5,6,6,8,9,10,11,12,14,15,17,18,20,22,23,25,27,29,31,33,35,38,40,42,45,47,49,52,54,57,60,62,65,68,71,73,76,79,82,85,88,91,94,97,100,103,106,109,113,116,119,122,125,128,131,135,138,141,144,147,150,153,156,159,162,165,168,171,174,177,180,183,186,189,191,194,197,199,202,204,207,209,212,214,216,218,221,223,225,227,229,231,232,234,236,238,239,241,242,243,245,246,247,248,249,250,251,252,252,253,253,254,254,255,255,255,255,255,255,255,255,254,254,253,253,252,252,251,250,249,248,247,246,245,243,242,241,239,238,236,234,232,231,229,227,225,223,221,218,216,214,212,209,207,204,202,199,197,194,191,189,186,183,180,177,174,171,168,165,162,159,156,153,150,147,144,141,138,135,131,128,125,122,119,116,113,109,106,103,100,97,94,91,88,85,82,79,76,73,71,68,65,62,60,57,54,52,49,47,45,42,40,38,35,33,31,29,27,25,23,22,20,18,17,15,14,12,11,10,9,8,6,6,5,4,3,2,2,1,1,1,0,0,0,0],
                EASING_LUT_SCALE: 255.0,
                CURVATURE_LUT_INT: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,2,2,2,2,2,3,3,3,4,4,4,5,5,6,6,7,7,8,9,9,10,11,11,12,13,14,15,16,17,18,19,20,21,22,23,24,26,27,28,30,31,33,34,36,37,39,41,43,45,46,48,50,53,55,57,59,61,64,66,69,71,74,76,79,82,85,88,91,94,97,100,103,107,110,114,117,121,124,128,132,136,140,144,148,153,157,161,166,170,175,180,184,189,194,199,205,210,215,221,226,232,237,243,249,255],
                CURVATURE_LUT_SCALE: 255.0,
                VELOCITY_LUT_INT: [154,153,153,153,153,152,152,152,152,151,151,151,151,150,150,150,149,149,149,149,148,148,148,148,147,147,147,146,146,146,146,145,145,145,144,144,144,143,143,143,143,142,142,142,141,141,141,140,140,140,139,139,139,138,138,138,137,137,137,136,136,136,135,135,135,134,134,134,133,133,132,132,132,131,131,131,130,130,129,129,129,128,128,127,127,126,126,126,125,125,124,124,123,123,122,122,121,121,120,120,119,119,118,117,117,116,116,115,114,114,113,112,112,111,110,109,108,108,107,106,105,104,102,101,99,98,95,90],
                VELOCITY_LUT_SCALE: 128.0,
                SIN_LUT_INT: new Int16Array([0,572,1144,1715,2286,2856,3425,3993,4560,5126,5690,6252,6813,7371,7927,8481,9032,9580,10126,10668,11207,11743,12275,12803,13328,13848,14364,14876,15383,15886,16384,16877,17364,17846,18323,18795,19260,19720,20174,20621,21063,21497,21926,22347,22762,23170,23571,23965,24351,24730,25101,25465,25821,26169,26509,26842,27165,27481,27788,28087,28377,28659,28932,29196,29451,29697,29935,30163,30381,30591,30791,30982,31164,31336,31498,31651,31794,31928,32051,32165,32270,32364,32449,32523,32588,32643,32688,32723,32748,32763,32768,32763,32748,32723,32688,32643,32588,32523,32449,32364,32270,32165,32051,31928,31794,31651,31498,31336,31164,30982,30791,30591,30381,30163,29935,29697,29451,29196,28932,28659,28377,28087,27788,27481,27165,26842,26509,26169,25821,25465,25101,24730,24351,23965,23571,23170,22762,22347,21926,21497,21063,20621,20174,19720,19260,18795,18323,17846,17364,16877,16384,15886,15383,14876,14364,13848,13328,12803,12275,11743,11207,10668,10126,9580,9032,8481,7927,7371,6813,6252,5690,5126,4560,3993,3425,2856,2286,1715,1144,572,0,-572,-1144,-1715,-2286,-2856,-3425,-3993,-4560,-5126,-5690,-6252,-6813,-7371,-7927,-8481,-9032,-9580,-10126,-10668,-11207,-11743,-12275,-12803,-13328,-13848,-14364,-14876,-15383,-15886,-16384,-16877,-17364,-17846,-18323,-18795,-19260,-19720,-20174,-20621,-21063,-21497,-21926,-22347,-22762,-23170,-23571,-23965,-24351,-24730,-25101,-25465,-25821,-26169,-26509,-26842,-27165,-27481,-27788,-28087,-28377,-28659,-28932,-29196,-29451,-29697,-29935,-30163,-30381,-30591,-30791,-30982,-31164,-31336,-31498,-31651,-31794,-31928,-32051,-32165,-32270,-32364,-32449,-32523,-32588,-32643,-32688,-32723,-32748,-32763,-32767,-32763,-32748,-32723,-32688,-32643,-32588,-32523,-32449,-32364,-32270,-32165,-32051,-31928,-31794,-31651,-31498,-31336,-31164,-30982,-30791,-30591,-30381,-30163,-29935,-29697,-29451,-29196,-28932,-28659,-28377,-28087,-27788,-27481,-27165,-26842,-26509,-26169,-25821,-25465,-25101,-24730,-24351,-23965,-23571,-23170,-22762,-22347,-21926,-21497,-21063,-20621,-20174,-19720,-19260,-18795,-18323,-17846,-17364,-16877,-16384,-15886,-15383,-14876,-14364,-13848,-13328,-12803,-12275,-11743,-11207,-10668,-10126,-9580,-9032,-8481,-7927,-7371,-6813,-6252,-5690,-5126,-4560,-3993,-3425,-2856,-2286,-1715,-1144,-572]),
                
                SOLVER_LUT_SCALE: 16,
                SOLVER_LUT_INT: [0,415,830,1245,1660,2076,2491,2906,3321,3736,4152,4567,4982,5397,5812,6228,6643,7058,7473,7888,8304,8719,9134,9549,9965,10380,10795,11210,11625,12041,12456,12871,13286,13701,14117,14532,14947,15362,15777,16193,16608,17023,17438,17853,18269,18684,19099,19514,19930,20345,20760,21175,21590,22006,22421,22836,23251,23666,24082,24497,24912,25327,25742,26158,26573,26988,27403,27818,28234,28649,29064,29479,29895,30310,30725,31140,31555,31971,32386,32801,33216,33631,34047,34462,34877,35292,35707,36123,3658,36953,37368,37784,38199,38614,39029,39444,39860,40275,40690,41105,41520,41936,42351,42766,43181,43596,44012,44427,44842,45257,45672,46088,46503,46918,47333,47749,48164,48579,48994,49409,49825,50240,50655,51070,51485,51901,52316,52731,53146,53561,53977,54392,54807,55222,55637,56053,56468,56883,57298,57714,58129,58544,58959,59374,59790,60205,60620,61035,61450,61866,62281,62696,63111,63526,63942,64357,64772,65187,65602,66018,66433,66848,67263,67679,68094,68509,68924,69339,69755,70170,70585,71000,71415,71831,72246,72661,73076,73491,73907,74322,74737,75152,75568,75983,76398,76813,77228,77644,78059,78474,78889,79304,79720,80135,80550,80965,81380,81796,82211,82626,83041,83456,83872,84287,84702,85117,85533,85948,86363,86778,87193,87609,88024,88439,88854,89269,89685,90100,90515,90930,91345,91761,92176,92591,93006,93421,93837,94252,94667,95082,95498,95913,96328,96743,97158,97574,97989,98404,98819,99234,99650,100065,100480,100895,101310,101726,102141,102556,102971,103386,103802,104217,104632,105047,105463,105878,106293,106708,107123,107539,107954,108369,108784,109199,109615,110030,110445,110860,111275,111691,112106,112521,112936,113352,113767,114182,114597,115012,115428,115843,116258,116673,117088,117504,117919,118334,118749,119164,119580,119995,120410,120825,121240,121656,122071,122486,122901,123317,123732,124147,124562,124977,125393,125808,126223,126638,127053,127469,127884,128299,128714,129129,129545,129960,130375,130790,131205,131621,132036,132451,132866,133282,133697,134112,134527,134942,135358,135773,136188,136603,137018,137434,137849,138264,138679,139094,139510,139925,140340,140755,141170,141586,142001,142416,142831,143247,143662,144077,144492,144907,145323,145738,146153,146568,146983,147399,147814,148229,148644,149059,149475,149890,150305,150720,151136,151551,151966,152381,152796,153212,153627,154042,154457,154872,155288,155703,156118,156533,156948,157364,157779,158194,158609,159024,159440,159855,160270,160685,161101,161516,161931,162346,162761,163177,163592,164007,164422,164837,165253,165668,166083,166498,166913,167329,167744,168159,168574,168989,169405,169820,170235,170650,171066,171481,171896,172311,172726,173142,173557,173972,174387,174802,175218,175633,176048,176463,176878,177294,177709,178124,178539,178955,179370,179785,180200,180615,181031,181446,181861,182276,182691,183107,183522,183937,184352,184767,185183,185598,186013,186428,186843,187259,187674,188089,188504,188920,189335,189750,190165,190580,190996,191411,191826,192241,192656,193072,193487,193902,194317,194732,195148,195563,195978,196393,196808,197224,197639,198054,198469,198885,199300,199715,200130,200545,200961,201376,201791,202206,202621,203037,203452,203867,204282,204697,205113,205528,205943,206358,206773,207189,207604,208019,208434,208850,209265,209680,210095,210510,210926,211341,211756,212171,212586],
            },

            // --- Animation & Math Helpers ---
            animationProfile: (p) => {
                const lut = LogoEngine.PRECALCULATED.EASING_LUT_INT;
                const floatIndex = p * (lut.length - 1);
                return LogoEngine._interpolateFromLut(lut, floatIndex);
            },

            /**
             * Interpolates a value from a Look-Up Table (LUT) using linear interpolation.
             * This is a core utility for animation curves, physics, and other calculations.
             * @param {number[]} lut - The Look-Up Table of pre-calculated integer values.
             * @param {number} floatIndex - The non-integer index to sample from the table.
             * @param {boolean} [wrap=false] - If true, the index will wrap around the LUT for cyclical values (e.g., sine waves).
             * @param {number} [wrapLength=0] - The specific length to wrap around, if different from the LUT's actual length.
             * @returns {number} The interpolated integer value.
             */
            _interpolateFromLut: function(lut, floatIndex, wrap = false, wrapLength = 0) {
                const lutLength = wrap ? (wrapLength > 0 ? wrapLength : lut.length) : lut.length;
                const index1 = floatIndex | 0;
                const fraction = floatIndex - index1;

                if (wrap) {
                    // Ensure the index is positive before wrapping
                    const wrappedIndex1 = (index1 % lutLength + lutLength) % lutLength;
                    const wrappedIndex2 = (wrappedIndex1 + 1) % lutLength;
                    const value1 = lut[wrappedIndex1];
                    const value2 = lut[wrappedIndex2];
                    return value1 + (((value2 - value1) * ((fraction * 256) | 0)) >> 8);
                } else {
                    if (index1 >= lutLength - 1) return lut[lutLength - 1];
                    if (index1 < 0) return lut[0];
                    const value1 = lut[index1];
                    const value2 = lut[index1 + 1];
                    return value1 + (((value2 - value1) * ((fraction * 256) | 0)) >> 8);
                }
            },
            
            // --- Core Methods: The Compiler & Renderer ---
            
            reloadWithNewArt: function(svgText, isLut) {
                this._resetAnimationState();
                this.state.isStreaming = false;
                this.state.lastSvgText = isLut ? '' : svgText;
                
                let pointsToPace = 0;

                if (!isLut) {
                    const estimatedPoints = this._solver(svgText);
                    pointsToPace = estimatedPoints; 
                }

                const parser = new DOMParser();
                const svgDoc = parser.parseFromString(svgText, "image/svg+xml");
                const svgElement = svgDoc.querySelector('svg');
                if (!svgElement || svgDoc.querySelector('parsererror')) return;

                this._extractSVGMetadata(svgElement);
                const { animatablePaths, compoundPathMeta } = this._extractAndConvertPathsFromSVG(svgElement);
                
                const { finalPalette, mappedStrokes, maxStroke } = this._buildPaletteAndMapPaths(animatablePaths);
                this.state.colorPalette = finalPalette;
                this.state.maxGeometricStrokeWidth = maxStroke;
                
                const { lut } = this._generateLookupTable(mappedStrokes);
                
                this.state.totalPointsInLut = lut.reduce((sum, stroke) => sum + (stroke.length > 0 ? stroke.length - 1 : 0), 0);
                
                const drawableLut = this._resolveCompoundPaths(lut, compoundPathMeta);
                this.state.lookupTable = drawableLut;
                
                this.startAnimation(isLut ? this.state.totalPointsInLut : pointsToPace);
            },

            startAnimation: function(pointsForPacing) {
                if (!this.state.canvas || !this.state.ctx) return;
                
                cancelAnimationFrame(this.state.animationFrameId);
                this.state.drawnPointsCount = 0;
                this.state.currentStrokeIndex = 0;
                this.state.currentPointInStrokeIndex = 0;

                const container = document.getElementById('logo-container');
                if (!container) return;

                const containerRect = container.getBoundingClientRect();
                if (containerRect.width === 0 || containerRect.height === 0) {
                    requestAnimationFrame(() => this.startAnimation(pointsForPacing));
                    return;
                }
                this._setupCanvas(containerRect);
                this._renderLoop(pointsForPacing);
            },
            
            // --- Rendering and Animation ---

            _setupCanvas: function(containerRect) {
                const { canvas, viewBox } = this.state;
                const dpr = window.devicePixelRatio || 1;
                
                const padding = (this.state.maxGeometricStrokeWidth * 0.5) + this.config.maxStrokeWidth;
                const effectiveViewBox = {
                    width: viewBox.width + padding * 2,
                    height: viewBox.height + padding * 2
                };

                const scaleX = containerRect.width / effectiveViewBox.width;
                const scaleY = containerRect.height / effectiveViewBox.height;
                const scale = scaleX < scaleY ? scaleX : scaleY;

                const canvasWidth = effectiveViewBox.width * scale;
                const canvasHeight = effectiveViewBox.height * scale;

                canvas.width = canvasWidth * dpr;
                canvas.height = canvasHeight * dpr;
                canvas.style.width = `${canvasWidth}px`;
                canvas.style.height = `${canvasHeight}px`;
            },
            
            _renderLoop: function(pointsForPacing) {
                const dataSource = this.state.isStreaming ? this.state.dataBuffer : this.state.lookupTable;
                const { ctx, colorPalette, viewBox } = this.state;
                const { INV_ANIMATION_DURATION_MS } = this.PRECALCULATED;

                if (!ctx || !dataSource) return;

                const pacingTotalPoints = (pointsForPacing > 0) ? pointsForPacing : this.state.totalPointsInLut;
                if (pacingTotalPoints === 0 && this.state.totalPointsInLut === 0) return;

                let startTime = null;
                let currentPos = {x: 0, y: 0};
                let dynamicRate = 10;

                const animationFrame = (timestamp) => {
                    if (this.state.isStreaming) {
                        this.Streamer._manageBuffer();
                    }

                    if (!startTime) startTime = timestamp;
                    let elapsedTime = timestamp - startTime;

                    if (this.state.drawnPointsCount < this.state.totalPointsInLut) {
                        if (elapsedTime > 200 && this.state.drawnPointsCount < 50 && this.state.totalPointsInLut > 100) {
                            dynamicRate = dynamicRate < 49 ? dynamicRate + 1 : 50;
                        }
                        elapsedTime = (elapsedTime * dynamicRate) / 10;

                        const pacingProgress = elapsedTime * INV_ANIMATION_DURATION_MS;
                        const targetPointsToDraw = (pacingProgress * pacingTotalPoints) | 0;

                        if(this.state.drawnPointsCount < targetPointsToDraw) {
                            ctx.save();
                            const dpr = window.devicePixelRatio || 1;
                            const padding = (this.state.maxGeometricStrokeWidth * 0.5) + this.config.maxStrokeWidth;
                            const effectiveWidth = viewBox.width + padding * 2;
                            const effectiveHeight = viewBox.height + padding * 2;
                            
                            const scaleX = (ctx.canvas.width / dpr) / effectiveWidth;
                            const scaleY = (ctx.canvas.height / dpr) / effectiveHeight;
                            
                            const translateX = (-viewBox.x + padding) * scaleX * dpr;
                            const translateY = (-viewBox.y + padding) * scaleY * dpr;

                            ctx.setTransform(scaleX * dpr, 0, 0, scaleY * dpr, translateX, translateY);
                            ctx.lineCap = 'round';
                            ctx.lineJoin = 'round';
                            
                            let drawnPoints = this.state.drawnPointsCount;
                            let strokeIdx = this.state.currentStrokeIndex;
                            let pointIdx = this.state.currentPointInStrokeIndex;

                            while (drawnPoints < targetPointsToDraw && drawnPoints < this.state.totalPointsInLut) {
                                if (strokeIdx >= dataSource.length) break;
                                const currentStroke = dataSource[strokeIdx];
                                
                                if (pointIdx === 0) {
                                    if (!currentStroke || currentStroke.length < 2 || typeof currentStroke[0].x === 'undefined') {
                                        strokeIdx++;
                                        continue;
                                    }
                                    currentPos.x = currentStroke[0].x;
                                    currentPos.y = currentStroke[0].y;
                                    pointIdx = 1;
                                }

                                if (pointIdx >= currentStroke.length) {
                                    pointIdx = 0;
                                    strokeIdx++;
                                    continue;
                                }

                                const prevPos = { ...currentPos };
                                const deltaPoint = currentStroke[pointIdx];
                                
                                currentPos.x += deltaPoint.dx;
                                currentPos.y += deltaPoint.dy;

                                const colorData = colorPalette[deltaPoint.colorIndex] || {r:0,g:0,b:0,a:1};
                                const colorStr = `rgba(${colorData.r},${colorData.g},${colorData.b},${colorData.a})`;
                                if (ctx.strokeStyle !== colorStr) ctx.strokeStyle = colorStr;
                                
                                ctx.beginPath();
                                ctx.lineWidth = deltaPoint.width;
                                ctx.moveTo(prevPos.x, prevPos.y);
                                ctx.lineTo(currentPos.x, currentPos.y);
                                ctx.stroke();

                                drawnPoints++;
                                pointIdx++;
                            }
                            
                            this.state.drawnPointsCount = drawnPoints;
                            this.state.currentStrokeIndex = strokeIdx;
                            this.state.currentPointInStrokeIndex = pointIdx;

                            ctx.restore();
                        }
                        this.state.animationFrameId = requestAnimationFrame(animationFrame);
                    }
                };
                this.state.animationFrameId = requestAnimationFrame(animationFrame);
            },
            
            // --- LUT Generation, Saving, and Loading ---
            
            _toVisInt: (num) => (num * 10000) | 0,
            _fromVisInt: (int) => {
                const { INV_VIS_INT_SCALE_H, INV_VIS_INT_SCALE_L } = LogoEngine.PRECALCULATED;
                // Correctly calculate the inverse scale factor from the fixed-point representation
                const invScale = (((INV_VIS_INT_SCALE_H << 8) | INV_VIS_INT_SCALE_L) / 65535.0);
                return int * invScale;
            },

            _saveLutToFile: function() {
                if (!this.state.lastSvgText) {
                    console.error("No SVG data loaded to generate a LUT from.");
                    return;
                }
                
                const parser = new DOMParser();
                const svgDoc = parser.parseFromString(this.state.lastSvgText, "image/svg+xml");
                const svgElement = svgDoc.querySelector('svg');
                this._extractSVGMetadata(svgElement);
                const { animatablePaths, compoundPathMeta } = this._extractAndConvertPathsFromSVG(svgElement);
                const { finalPalette, mappedStrokes, maxStroke } = this._buildPaletteAndMapPaths(animatablePaths);
                const { lut } = this._generateLookupTable(mappedStrokes);
                const finalLut = this._resolveCompoundPaths(lut, compoundPathMeta);
                
                const actualTotalPoints = finalLut.reduce((sum, stroke) => sum + (stroke.length > 0 ? stroke.length - 1 : 0), 0);
                
                let visString = `v${this._toVisInt(this.state.viewBox.x)},${this._toVisInt(this.state.viewBox.y)},${this._toVisInt(this.state.viewBox.width)},${this._toVisInt(this.state.viewBox.height)}|`;
                visString += `m${this._toVisInt(maxStroke)}|`;
                visString += `p${JSON.stringify(finalPalette)}|`;
                visString += `i1,${actualTotalPoints}|`;

                const tableString = finalLut.map(stroke => {
                    if (stroke.length < 2) return '';
                    const start = `x${this._toVisInt(stroke[0].x)}y${this._toVisInt(stroke[0].y)}`;
                    const deltas = stroke.slice(1).map(p => `d${this._toVisInt(p.dx)},${this._toVisInt(p.dy)}c${p.colorIndex}w${this._toVisInt(p.width)}`).join('');
                    return start + deltas;
                }).join('S');

                visString += `t${tableString}`;

                const blob = new Blob([visString], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = 'animation.vis';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            },

            _loadLutFromFile: function(file) {
                this.Streamer.init(file);
            },
            
            // --- Initialization and Event Handlers ---
            init: function() {
                this.state.canvas = document.getElementById(this.config.canvasId);
                if (!this.state.canvas) return;
                this.state.ctx = this.state.canvas.getContext('2d', { willReadFrequently: true });
                
                this.state.reusablePathForSampling = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                this.Streamer.parent = this; // Give streamer a reference to the main engine

                const svgUploader = document.getElementById('svg-uploader');
                const lutUploader = document.getElementById('lut-uploader');
                
                window.addEventListener('keydown', (e) => {
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                    const key = e.key.toLowerCase();
                    if (key === 'b') svgUploader.click();
                    else if (key === 's') this._saveLutToFile();
                    else if (key === 'l') lutUploader.click();
                });

                svgUploader.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = (event) => this.reloadWithNewArt(event.target.result, false);
                    reader.readAsText(file);
                    e.target.value = '';
                });

                lutUploader.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    this._loadLutFromFile(file);
                    e.target.value = '';
                });

                window.addEventListener('resize', () => {
                    // Re-start might need adjustment for streaming context
                    this.startAnimation(this.state.totalPointsInLut);
                });

                requestAnimationFrame(() => { this.reloadWithNewArt(this.config.defaultSvgMarkup, false); });
            },

            _solver: function(svgText) {
                const parser = new DOMParser();
                const svgDoc = parser.parseFromString(svgText, "image/svg+xml");
                const svgElement = svgDoc.querySelector('svg');
                if (!svgElement) return 21179; // Return average if parse fails

                const commandRegex = /[MmLlHhVvCcSsQqTtAaZz]/g;
                let liveGeometricComplexity = 0;
                const commandCosts = { M: 1, L: 2, H: 2, V: 2, C: 5, S: 4, Q: 4, T: 3, A: 5, Z: 1 };

                const pathElements = svgElement.querySelectorAll('path, rect, circle, ellipse, line, polyline, polygon');
                pathElements.forEach(node => {
                    const pathData = this._getPathDataFromNode(node);
                    if (pathData) {
                        const commands = pathData.match(commandRegex) || [];
                        commands.forEach(cmd => {
                            liveGeometricComplexity += commandCosts[cmd.toUpperCase()] || 1;
                        });
                    }
                });

                if (liveGeometricComplexity === 0) return 0;
                
                if (liveGeometricComplexity >= 8191) {
                    return (liveGeometricComplexity * 26) | 0; 
                }

                const lut = this.PRECALCULATED.SOLVER_LUT_INT;
                const scale = this.PRECALCULATED.SOLVER_LUT_SCALE;

                const floatIndex = liveGeometricComplexity / scale;
                return this._interpolateFromLut(lut, floatIndex);
            },

            // --- Helper Functions ---
            _buildPaletteAndMapPaths: function(animatablePaths) {
                if (!animatablePaths || animatablePaths.length === 0) {
                    return { finalPalette: [this._colorUtils.parseColor(this.config.fallbackStrokeColor, 1)], mappedStrokes: [], maxStroke: 0 };
                }
                const colorWeights = new Map();
                let maxStroke = 0;
                animatablePaths.forEach(p => {
                    const rgba = this._colorUtils.parseColor(p.color, p.opacity);
                    if (rgba.a > 0) {
                        const colorKey = `${rgba.r},${rgba.g},${rgba.b},${rgba.a}`;
                        const metrics = this._getPathMetrics(p.path);
                        const weight = p.type === 'fill' ? metrics.area : metrics.perimeter * p.strokeWidth;
                        if (colorWeights.has(colorKey)) {
                            colorWeights.get(colorKey).weight += weight;
                        } else {
                            colorWeights.set(colorKey, { color: rgba, weight });
                        }
                    }
                    if (p.strokeWidth > maxStroke) maxStroke = p.strokeWidth;
                });

                const weightedColors = Array.from(colorWeights.values());
                let finalPalette;
                if (weightedColors.length <= this.config.maxPaletteSize) {
                    finalPalette = weightedColors.map(item => item.color);
                } else {
                    finalPalette = this._quantizeWithWeightedKMeans(weightedColors, this.config.maxPaletteSize);
                }
                if (finalPalette.length === 0) finalPalette.push(this._colorUtils.parseColor(this.config.fallbackStrokeColor, 1));
                
                const mappedStrokes = animatablePaths.map(stroke => {
                    const strokeRgba = this._colorUtils.parseColor(stroke.color, stroke.opacity);
                    if (strokeRgba.a === 0) return null;
                    let bestMatchIndex = 0, minDistance = Infinity;
                    finalPalette.forEach((paletteRgba, index) => {
                        const distance = this._colorUtils.colorDistanceSq(strokeRgba, paletteRgba);
                        if (distance < minDistance) {
                            minDistance = distance;
                            bestMatchIndex = index;
                        }
                    });
                    return { ...stroke, colorIndex: bestMatchIndex };
                }).filter(Boolean);
                return { finalPalette, mappedStrokes, maxStroke };
            },
            _quantizeWithWeightedKMeans: function(weightedColors, k) {
                if (weightedColors.length <= k) return weightedColors.map(wc => wc.color);
                let centroids = [];
                let colorsCopy = [...weightedColors];
                
                const totalWeight = colorsCopy.reduce((sum, wc) => sum + wc.weight, 0);
                let rand = this._lcg() * totalWeight;
                let chosenIndex = colorsCopy.findIndex(wc => (rand -= wc.weight) <= 0);
                if (chosenIndex === -1) chosenIndex = colorsCopy.length - 1;
                centroids.push(colorsCopy.splice(chosenIndex, 1)[0].color);
                
                while (centroids.length < k && colorsCopy.length > 0) {
                    let distances = colorsCopy.map(wc => {
                        let minDistanceSq = Infinity;
                        for (let i = 0; i < centroids.length; i++) {
                            const distSq = this._colorUtils.colorDistanceSq(wc.color, centroids[i]);
                            if (distSq < minDistanceSq) minDistanceSq = distSq;
                        }
                        return minDistanceSq * wc.weight;
                    });
                    const distSum = distances.reduce((sum, d) => sum + d, 0);
                    rand = this._lcg() * distSum;
                    chosenIndex = distances.findIndex(d => (rand -= d) <= 0);
                    if (chosenIndex === -1) chosenIndex = colorsCopy.length - 1;
                    centroids.push(colorsCopy.splice(chosenIndex, 1)[0].color);
                }

                for (let iter = 0; iter < 20; iter++) {
                    const clusters = Array.from({ length: k }, () => []);
                    weightedColors.forEach(wc => {
                        let closestCentroidIndex = 0, minDistance = Infinity;
                        for (let i = 0; i < centroids.length; i++) {
                            const dist = this._colorUtils.colorDistanceSq(wc.color, centroids[i]);
                            if (dist < minDistance) {
                                minDistance = dist;
                                closestCentroidIndex = i;
                            }
                        }
                        clusters[closestCentroidIndex].push(wc);
                    });
                    
                    let hasChanged = false;
                    const newCentroids = clusters.map((cluster, i) => {
                        if (cluster.length === 0) return centroids[i];
                        const clusterWeight = cluster.reduce((sum, wc) => sum + wc.weight, 0);
                        if (clusterWeight === 0) return centroids[i];
                        
                        const totalColor = cluster.reduce((acc, wc) => ({
                            r: acc.r + wc.color.r * wc.weight, g: acc.g + wc.color.g * wc.weight,
                            b: acc.b + wc.color.b * wc.weight, a: acc.a + wc.color.a * wc.weight
                        }), {r:0, g:0, b:0, a:0});
                        
                        const invClusterWeight = 1.0 / clusterWeight;
                        const newCentroid = {
                            r: (totalColor.r * invClusterWeight + 0.5) | 0, g: (totalColor.g * invClusterWeight + 0.5) | 0,
                            b: (totalColor.b * invClusterWeight + 0.5) | 0, a: totalColor.a * invClusterWeight
                        };
                        
                        if (!centroids[i] || newCentroid.r !== centroids[i].r || newCentroid.g !== centroids[i].g || newCentroid.b !== centroids[i].b) {
                            hasChanged = true;
                        }
                        return newCentroid;
                    });
                    centroids = newCentroids;
                    if (!hasChanged) break;
                }
                return centroids;
            },
            _generateLookupTable: function(animatablePaths) {
                const draftLut = [];
                const pointCollectorCallback = (segment) => {
                    draftLut.push(segment);
                };
                this._streamProcessSVG(animatablePaths, pointCollectorCallback);
                return { lut: draftLut };
            },
            _streamProcessSVG: function(animatablePaths, pointCallback) {
                const checkCtx = document.createElement('canvas').getContext('2d');
                
                const { EASING_LUT_SCALE, CURVATURE_LUT_SCALE, VELOCITY_LUT_SCALE } = this.PRECALCULATED;

                animatablePaths.forEach((pathData) => {
                    const path = this.state.reusablePathForSampling;
                    path.setAttribute('d', pathData.path);
                    const length = path.getTotalLength();
                    if (length === 0) return;
                    const inv_length = 1.0 / length;

                    let samplingStep = length * 0.002;
                    samplingStep = samplingStep < 1.0 ? samplingStep : 1.0;
                    samplingStep = samplingStep > 0.25 ? samplingStep : 0.25;

                    const clipPath2D = pathData.clipPathId ? this.state.clipPathCache.get(pathData.clipPathId) : null;
                    
                    let currentSegment = [], lastPoint = null;
                    for (let i = 0; i < length; i += samplingStep) {
                        const point = path.getPointAtLength(i);
                        let width;
                        let velocityFactor = 1.0;

                        if (lastPoint) {
                            const dx = point.x - lastPoint.x, dy = point.y - lastPoint.y;
                            let n = dx * dx + dy * dy;
                            n = (n + 1) * 0.5;
                            const distance = n - (n*n- (dx*dx+dy*dy)) / (2*n);

                            let normalizedDistance = distance * 0.2 > 1.0 ? 1.0 : distance * 0.2;
                            const lut = this.PRECALCULATED.VELOCITY_LUT_INT;
                            const floatIndex = normalizedDistance * (lut.length - 1);
                            let lutValue = this._interpolateFromLut(lut, floatIndex);
                            velocityFactor = lutValue / VELOCITY_LUT_SCALE;
                        }

                        if (pathData.isOriginalStroke) {
                            let curvatureFactor = 1.0;
                            if (i > 0 && i < length - samplingStep) {
                                const p_prev = path.getPointAtLength(i - samplingStep);
                                const p_curr = point;
                                const p_next = path.getPointAtLength(i + samplingStep);
                                const v1_x = p_curr.x - p_prev.x, v1_y = p_curr.y - p_prev.y;
                                const v2_x = p_next.x - p_curr.x, v2_y = p_next.y - p_curr.y;
                                const dot = v1_x * v2_x + v1_y * v2_y;
                                const denominator = samplingStep * samplingStep;
                                if (denominator > 0.001) {
                                    let cosTheta = dot / denominator;
                                    cosTheta = cosTheta > 1.0 ? 1.0 : (cosTheta < -1.0 ? -1.0 : cosTheta);
                                    
                                    const lut = this.PRECALCULATED.CURVATURE_LUT_INT;
                                    const floatIndex = (cosTheta + 1.0) * 0.5 * (lut.length - 1);
                                    let lutValue = this._interpolateFromLut(lut, floatIndex);
                                    curvatureFactor = lutValue / CURVATURE_LUT_SCALE;
                                }
                            }
                            const progress = i * inv_length;
                            const swellFactor = this.animationProfile(progress) / EASING_LUT_SCALE;
                            let animatedBaseWidth = pathData.strokeWidth > 1.0 ? pathData.strokeWidth : 1.0;
                            const baseWidth = animatedBaseWidth + swellFactor * (this.config.maxStrokeWidth - animatedBaseWidth);
                            width = this.config.minCurveWidth + (baseWidth - this.config.minCurveWidth) * curvatureFactor;
                            width *= velocityFactor;
                        } else {
                            const progress = i * inv_length;
                            const swellFactor = this.animationProfile(progress) / EASING_LUT_SCALE;
                            if (pathData.type === 'fill') {
                                const animatedBaseWidth = 2.0;
                                width = animatedBaseWidth + swellFactor * (this.config.maxStrokeWidth - animatedBaseWidth);
                            } else {
                                width = this.config.maxStrokeWidth;
                            }
                        }

                        if (!clipPath2D || checkCtx.isPointInPath(clipPath2D, point.x, point.y)) {
                            let tempWidth = width > this.config.maxStrokeWidth * 1.5 ? this.config.maxStrokeWidth * 1.5 : width;
                            width = tempWidth < 0.5 ? 0.5 : tempWidth;

                            const pointData = { width, colorIndex: pathData.colorIndex, type: pathData.type, compoundId: pathData.compoundId };
                            if (!lastPoint) {
                                currentSegment.push({ x: point.x, y: point.y, ...pointData });
                            } else {
                                currentSegment.push({ dx: point.x - lastPoint.x, dy: point.y - lastPoint.y, ...pointData });
                            }
                            lastPoint = point;
                        } else {
                            if (currentSegment.length > 1) pointCallback(currentSegment);
                            currentSegment = [];
                            lastPoint = null;
                        }
                    }
                    if (currentSegment.length > 1) pointCallback(currentSegment);
                });
            },
            _resolveCompoundPaths: function(draftLut, compoundPathMeta) {
                if (compoundPathMeta.size === 0) return draftLut;
                const cleanedLut = [];
                const checkCtx = document.createElement('canvas').getContext('2d');
                const holeGeometries = new Map();
                for (const [id, meta] of compoundPathMeta.entries()) {
                    holeGeometries.set(id, new Path2D(meta.erasePathData));
                }
                draftLut.forEach(segment => {
                    const firstPoint = segment[0];
                    if (firstPoint.type !== 'fill' || !holeGeometries.has(firstPoint.compoundId)) {
                        cleanedLut.push(segment);
                        return;
                    }
                    const hole = holeGeometries.get(firstPoint.compoundId);
                    const absolutePoints = this._convertDeltaToAbsolute(segment);
                    let currentCleanSegment = [];
                    absolutePoints.forEach(absPoint => {
                        if (!checkCtx.isPointInPath(hole, absPoint.absX, absPoint.absY, 'evenodd')) {
                            currentCleanSegment.push(absPoint);
                        } else {
                            if (currentCleanSegment.length > 1) cleanedLut.push(this._convertAbsoluteToDelta(currentCleanSegment));
                            currentCleanSegment = [];
                        }
                    });
                    if (currentCleanSegment.length > 1) cleanedLut.push(this._convertAbsoluteToDelta(currentCleanSegment));
                });
                return cleanedLut;
            },
            _extractAndConvertPathsFromSVG: function(svgNode) {
                const allFoundPaths = [], compoundPathMeta = new Map();
                let compoundPathCounter = 0;
                
                const traverse = (node, inheritedProps) => {
                    if (node.nodeType !== 1 || ['defs', 'mask', 'style', 'title', 'metadata', 'clippath'].includes(node.tagName.toLowerCase())) return;
                    const props = this._getInheritedProps(node, inheritedProps);
                    if (node.tagName.toLowerCase() === 'use') {
                        const href = node.getAttribute('href') || node.getAttribute('xlink:href');
                        if (href?.startsWith('#')) {
                            const referencedNode = svgNode.getRootNode().getElementById(href.substring(1));
                            if (referencedNode) {
                                const useX = +node.getAttribute('x') || 0, useY = +node.getAttribute('y') || 0;
                                const finalProps = { ...props };
                                if (useX !== 0 || useY !== 0) {
                                    finalProps.transform = this._matrixHelper.multiply(props.transform, this._matrixHelper.translate(useX, useY));
                                }
                                traverse(referencedNode, finalProps);
                            }
                        }
                        return;
                    }
                    this._processPathNode(node, props, allFoundPaths, compoundPathMeta, ++compoundPathCounter);
                    node.childNodes.forEach(child => traverse(child, props));
                };

                const initialProps = {
                    transform: this._matrixHelper.identity(), fill: 'black', 'fill-opacity': 1,
                    stroke: 'none', 'stroke-opacity': 1, 'stroke-width': 1,
                    clipPath: null, fillRule: 'nonzero', color: '#000'
                };
                traverse(svgNode, initialProps);

                const animatablePaths = [];
                const hasStrokesInCollection = allFoundPaths.some(p => p.isOriginalStroke);
                const hasFillsInCollection = allFoundPaths.some(p => p.type === 'fill');
                animatablePaths.push(...allFoundPaths.filter(p => p.type === 'fill'));
                if (hasStrokesInCollection) {
                    animatablePaths.push(...allFoundPaths.filter(p => p.type === 'stroke'));
                } else if (hasFillsInCollection) {
                    const strokesFromFills = allFoundPaths.filter(p => p.type === 'fill').map(p => ({ 
                        ...p, type: 'stroke', strokeWidth: 2, color: p.color, opacity: p.opacity, isOriginalStroke: false 
                    }));
                    animatablePaths.push(...strokesFromFills);
                }
                return { animatablePaths, compoundPathMeta };
            },
            _processPathNode: function(node, props, allFoundPaths, compoundPathMeta, compoundId) {
                let pathData = this._getPathDataFromNode(node);
                if (!pathData) return;
                const isSolid = (c) => c && c !== 'none' && !c.includes('url(');
                const hasVisibleFill = isSolid(props.fill) && props['fill-opacity'] > 0;
                const hasVisibleStroke = isSolid(props.stroke) && props['stroke-width'] > 0 && props['stroke-opacity'] > 0;
                const subPaths = pathData.trim().split(/(?=M|m)/g).filter(s => s.trim());
                const isCompound = props.fillRule === 'evenodd' && subPaths.length > 1;

                if (hasVisibleFill) {
                    const processFill = (pData, cId) => {
                        const transformedPath = this._applyTransformBySampling(pData, props.transform);
                        allFoundPaths.push({
                            path: transformedPath, clipPathId: props.clipPath, compoundId: cId,
                            type: 'fill', strokeWidth: this.config.maxStrokeWidth,
                            color: props.fill, opacity: props['fill-opacity'], isOriginalStroke: false
                        });
                    };
                    if (isCompound) {
                        processFill(subPaths[0], compoundId);
                        const holePathsData = subPaths.slice(1).join(' ');
                        const transformedHolePath = this._applyTransformBySampling(holePathsData, props.transform);
                        compoundPathMeta.set(compoundId, { erasePathData: transformedHolePath });
                    } else {
                        subPaths.forEach(subPathData => processFill(subPathData, null));
                    }
                }
                if (hasVisibleStroke) {
                    subPaths.forEach(subPathData => {
                        const transformedPath = this._applyTransformBySampling(subPathData, props.transform);
                        allFoundPaths.push({
                            path: transformedPath, clipPathId: props.clipPath, compoundId: null,
                            type: 'stroke', strokeWidth: props['stroke-width'],
                            color: props.stroke, opacity: props['stroke-opacity'], isOriginalStroke: true
                        });
                    });
                }
            },
            _getInheritedProps: function(node, inheritedProps) {
                const props = { ...inheritedProps };
                const styleProps = {};
                const styleAttr = node.getAttribute('style');
                const classAttr = node.getAttribute('class');
                if (classAttr) {
                    classAttr.split(' ').forEach(cls => {
                        const rule = this.state.cssRules.get(`.${cls}`);
                        if (rule) Object.assign(styleProps, rule);
                    });
                }
                if (node.id && this.state.cssRules.has(`#${node.id}`)) {
                    Object.assign(styleProps, this.state.cssRules.get(`#${node.id}`));
                }
                if (styleAttr) Object.assign(styleProps, this._parseStyleAttribute(styleAttr));
                Object.assign(props, styleProps);
                const directAttrs = {
                    fill: node.getAttribute('fill'), 'fill-opacity': node.getAttribute('fill-opacity'),
                    'fill-rule': node.getAttribute('fill-rule'), stroke: node.getAttribute('stroke'),
                    'stroke-width': node.getAttribute('stroke-width'), 'stroke-opacity': node.getAttribute('stroke-opacity'),
                    'clip-path': node.getAttribute('clip-path'), color: node.getAttribute('color')
                };
                for (const [key, value] of Object.entries(directAttrs)) {
                    if (value !== null) props[key] = value;
                }
                if (props.fill === 'currentColor') props.fill = props.color;
                if (props.stroke === 'currentColor') props.stroke = props.color;
                let localTransform = this._matrixHelper.identity();
                if (styleProps.transform) localTransform = this._parseTransform(styleProps.transform);
                const attrTransform = node.getAttribute('transform');
                if (attrTransform) localTransform = this._matrixHelper.multiply(localTransform, this._parseTransform(attrTransform));
                props.transform = this._matrixHelper.multiply(inheritedProps.transform, localTransform);
                props['stroke-width'] = +props['stroke-width'];
                props['stroke-opacity'] = +props['stroke-opacity'];
                props['fill-opacity'] = +props['fill-opacity'];
                if (props['clip-path']) props.clipPath = props['clip-path'].replace(/url\(#|\)/g, '');
                return props;
            },
            _getPathDataFromNode: function(node) {
                const tagName = node.tagName.toLowerCase();
                switch(tagName) {
                    case 'path': return node.getAttribute('d');
                    case 'rect': {
                        const w = +node.getAttribute('width') || 0, h = +node.getAttribute('height') || 0;
                        if (w <= 0 || h <= 0) return '';
                        const x = +node.getAttribute('x') || 0, y = +node.getAttribute('y') || 0;
                        let rx = +node.getAttribute('rx') || 0, ry = +node.getAttribute('ry') || rx;
                        rx = rx < w * 0.5 ? rx : w * 0.5;
                        ry = ry < h * 0.5 ? ry : h * 0.5;
                        if (rx > 0 || ry > 0) return `M${x + rx},${y} h${w - 2 * rx} a${rx},${ry} 0 0 1 ${rx},${ry} v${h - 2 * ry} a${rx},${ry} 0 0 1 ${-rx},${ry} h${-(w - 2 * rx)} a${rx},${ry} 0 0 1 ${-rx},${-ry} v${-(h - 2 * ry)} a${rx},${ry} 0 0 1 ${rx},${-ry} Z`;
                        return `M${x},${y} h${w} v${h} h${-w} Z`;
                    }
                    case 'circle': {
                        const r = +node.getAttribute('r') || 0; if (r <= 0) return '';
                        const cx = +node.getAttribute('cx') || 0, cy = +node.getAttribute('cy') || 0, r2 = r * 2;
                        return `M ${cx - r},${cy} a ${r},${r} 0 1,0 ${r2},0 a ${r},${r} 0 1,0 -${r2},0`;
                    }
                    case 'ellipse': {
                        const rx = +node.getAttribute('rx') || 0, ry = +node.getAttribute('ry') || 0;
                        if (rx <= 0 || ry <= 0) return '';
                        const cx = +node.getAttribute('cx') || 0, cy = +node.getAttribute('cy') || 0, rx2 = rx * 2;
                        return `M ${cx - rx},${cy} a ${rx},${ry} 0 1,0 ${rx2},0 a ${rx},${ry} 0 1,0 -${rx2},0`;
                    }
                    case 'line': {
                        const x1 = +node.getAttribute('x1') || 0, y1 = +node.getAttribute('y1') || 0, x2 = +node.getAttribute('x2') || 0, y2 = +node.getAttribute('y2') || 0;
                        return `M ${x1} ${y1} L ${x2} ${y2}`;
                    }
                    case 'polyline': case 'polygon': {
                        const points = (node.getAttribute('points')||'').trim().split(/[\s,]+/).map(p => +p || 0);
                        if (points.length < 2) return '';
                        let d = `M ${points[0]} ${points[1]}`;
                        for(let i=2; i<points.length; i+=2) d += ` L ${points[i]} ${points[i+1]}`;
                        if (tagName === 'polygon') d += ' Z';
                        return d;
                    }
                    default: return '';
                }
            },
            _extractSVGMetadata: function(svgElement) {
                const viewBoxAttr = svgElement.getAttribute('viewBox');
                if (viewBoxAttr) {
                    const vb = viewBoxAttr.split(/[\s,]+/).map(Number);
                    if (vb.length === 4 && !vb.some(isNaN)) this.state.viewBox = { x: vb[0], y: vb[1], width: vb[2], height: vb[3] };
                } else {
                    const w = +svgElement.getAttribute('width'), h = +svgElement.getAttribute('height');
                    this.state.viewBox = { x: 0, y: 0, width: (isNaN(w) ? 400 : w), height: (isNaN(h) ? 225 : h) };
                }
                this.state.cssRules = this._parseStyleSheets(svgElement);
                this.state.clipPathCache.clear();
                this._compileClipPaths(svgElement);
            },
            _compileClipPaths: function(svgNode) {
                svgNode.querySelectorAll('clipPath').forEach(clipNode => {
                    const clipId = clipNode.getAttribute('id');
                    if (!clipId) return;
                    const combinedPath2D = new Path2D();
                    const traverseClipPath = (node, inheritedTransform) => {
                        if (node.nodeType !== 1) return;
                        let currentTransform = inheritedTransform;
                        const transformAttr = node.getAttribute('transform');
                        if (transformAttr) currentTransform = this._matrixHelper.multiply(inheritedTransform, this._parseTransform(transformAttr));
                        if (node.tagName.toLowerCase() === 'use') {
                            const href = node.getAttribute('href') || node.getAttribute('xlink:href');
                            if (href?.startsWith('#')) {
                                const ref = svgNode.getRootNode().getElementById(href.substring(1));
                                if (ref) {
                                    const useX = +node.getAttribute('x')||0, useY = +node.getAttribute('y')||0;
                                    let finalTransform = currentTransform;
                                    if (useX !== 0 || useY !== 0) finalTransform = this._matrixHelper.multiply(currentTransform, this._matrixHelper.translate(useX, useY));
                                    traverseClipPath(ref, finalTransform);
                                }
                            }
                        } else {
                            const pathData = this._getPathDataFromNode(node);
                            if (pathData) {
                                const transformedPath = this._applyTransformBySampling(pathData, currentTransform);
                                combinedPath2D.addPath(new Path2D(transformedPath));
                            }
                        }
                        node.childNodes.forEach(child => traverseClipPath(child, currentTransform));
                    };
                    traverseClipPath(clipNode, this._matrixHelper.identity());
                    this.state.clipPathCache.set(clipId, combinedPath2D);
                });
            },
            _resetAnimationState: function() {
                cancelAnimationFrame(this.state.animationFrameId);
                this.state.drawnPointsCount = 0;
                this.state.currentStrokeIndex = 0;
                this.state.currentPointInStrokeIndex = 0;
                this.state.totalPointsInLut = 0;
                this.state.lookupTable = [];
                this.state.streamReader = null;
                this.state.isStreaming = false;
                this.state.isEndOfStream = false;
                this.state.dataBuffer = [];
                if (this.state.ctx && this.state.canvas) {
                    this.state.ctx.reset();
                }
            },
            _parseStyleAttribute: function(s) {
                return s.split(';').reduce((styles, p) => {
                    const parts = p.split(':');
                    if (parts.length === 2) styles[parts[0].trim()] = parts[1].trim();
                    return styles;
                }, {});
            },
            _parseStyleSheets: function(svgNode) {
                const rules = new Map();
                svgNode.querySelectorAll('style').forEach(style => {
                    const ruleRegex = /([^{]+)\s*\{([^}]+)\}/g;
                    let match;
                    while ((match = ruleRegex.exec(style.textContent)) !== null) {
                        const selector = match[1].trim();
                        const properties = this._parseStyleAttribute(match[2].trim());
                        rules.set(selector, properties);
                    }
                });
                return rules;
            },
            _lcg: function() {
                const { INV_LCG_SCALE_H, INV_LCG_SCALE_L } = this.PRECALCULATED;
                const invScale = (((INV_LCG_SCALE_H << 8) | INV_LCG_SCALE_L) / 65535.0) * 4294967296.0;
                this.state._lcg_seed = (this.state._lcg_seed * 1664525 + 1013904223) | 0;
                return (this.state._lcg_seed >>> 0) * invScale;
            },
            _matrixHelper: {
                identity: () => [1, 0, 0, 1, 0, 0],
                isIdentity: (m) => m.every((val, i) => val === (i === 0 || i === 3 ? 1 : 0)),
                multiply: (m1, m2) => [
                    m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1],
                    m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3],
                    m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]
                ],
                transformPoint: (x, y, m) => ({ x: m[0] * x + m[2] * y + m[4], y: m[1] * x + m[3] * y + m[5] }),
                translate: (tx, ty) => [1, 0, 0, 1, tx, ty],
                scale: (sx, sy) => [sx, 0, 0, sy, 0, 0],
                rotate: function(angle, cx = 0, cy = 0) {
                    const lut = LogoEngine.PRECALCULATED.SIN_LUT_INT;
                    const inv_scale = 1.0 / 32767.0;

                    const getTrigValue = (angleInDegrees) => {
                        const floatIndex = (angleInDegrees % 360 + 360) % 360;
                        // The original code wraps at 360, so we pass that as the wrapLength.
                        const interpolatedValue = LogoEngine._interpolateFromLut(lut, floatIndex, true, 360);
                        return interpolatedValue * inv_scale;
                    };
                    const sin = getTrigValue(angle), cos = getTrigValue(angle + 90);
                    const m = [cos, sin, -sin, cos, 0, 0];
                    if (cx !== 0 || cy !== 0) {
                        const m1 = this.translate(cx, cy), m2 = this.translate(-cx, -cy);
                        return this.multiply(m1, this.multiply(m, m2));
                    }
                    return m;
                }
            },
            _parseTransform: function(transformString) {
                let matrix = this._matrixHelper.identity();
                if (!transformString) return matrix;
                const regex = /(\w+)\s*\(([^)]+)\)/g;
                let match;
                while ((match = regex.exec(transformString)) !== null) {
                    const [_, type, valueStr] = match;
                    const values = valueStr.trim().split(/[\s,]+/).map(v => +v.trim());
                    if (values.some(isNaN)) continue;
                    let transformMatrix;
                    switch (type) {
                        case 'translate': transformMatrix = this._matrixHelper.translate(values[0], values[1] || 0); break;
                        case 'scale': transformMatrix = this._matrixHelper.scale(values[0], values[1] ?? values[0]); break;
                        case 'rotate': transformMatrix = this._matrixHelper.rotate(values[0], values[1] || 0, values[2] || 0); break;
                        case 'matrix': transformMatrix = values.length === 6 ? values : this._matrixHelper.identity(); break;
                        default: transformMatrix = this._matrixHelper.identity();
                    }
                    matrix = this._matrixHelper.multiply(matrix, transformMatrix);
                }
                return matrix;
            },
            _applyTransformBySampling: function(pathData, matrix) {
                if (!matrix || this._matrixHelper.isIdentity(matrix)) return pathData;
                const path = this.state.reusablePathForSampling;
                path.setAttribute('d', pathData);
                const len = path.getTotalLength();
                if (len === 0) return '';
                const p0 = path.getPointAtLength(0);
                const transformedP0 = this._matrixHelper.transformPoint(p0.x, p0.y, matrix);
                let newPath = `M${transformedP0.x} ${transformedP0.y}`;
                const step = len * 0.005 > 0.5 ? len * 0.005 : 0.5;
                for (let i = step; i <= len; i += step) {
                    const p = path.getPointAtLength(i);
                    const transformedP = this._matrixHelper.transformPoint(p.x, p.y, matrix);
                    newPath += ` L${transformedP.x} ${transformedP.y}`;
                }
                if (pathData.trim().toUpperCase().endsWith('Z')) newPath += ' Z';
                return newPath;
            },
            _colorUtils: {
                _colorCanvasCtx: null,
                _initColorCanvas() {
                    if (!this._colorCanvasCtx) {
                        const canvas = document.createElement('canvas');
                        canvas.width = 1; canvas.height = 1;
                        this._colorCanvasCtx = canvas.getContext('2d', { willReadFrequently: true });
                    }
                    return this._colorCanvasCtx;
                },
                parseColor(colorStr, opacity = 1) {
                    if (!colorStr || typeof colorStr !== 'string' || colorStr.toLowerCase() === 'none') {
                        return { r: 0, g: 0, b: 0, a: 0 };
                    }
                    const ctx = this._initColorCanvas();
                    ctx.clearRect(0, 0, 1, 1);
                    ctx.fillStyle = colorStr;
                    ctx.fillRect(0, 0, 1, 1);
                    const [r, g, b, a_255] = ctx.getImageData(0, 0, 1, 1).data;
                    const { INV_255_SCALE_H, INV_255_SCALE_L } = LogoEngine.PRECALCULATED;
                    // Correctly calculate the inverse scale factor from the fixed-point representation
                    const invScale = (((INV_255_SCALE_H << 8) | INV_255_SCALE_L) / 65535.0);
                    return { r, g, b, a: (a_255 * invScale) * opacity };
                },
                colorDistanceSq(c1, c2) {
                    const dr = c1.r - c2.r, dg = c1.g - c2.g, db = c1.b - c2.b, da = (c1.a - c2.a) * 255;
                    return dr*dr + dg*dg + db*db + da*da;
                }
            },
            _getPathMetrics: function(pathData) {
                const path = this.state.reusablePathForSampling;
                path.setAttribute('d', pathData);
                const perimeter = path.getTotalLength();
                if (perimeter < 1) return { perimeter: 0, area: 0 };
                
                const points = [];
                
                // Data-driven sample count based on profiling.
                // This tiered approach provides more detail for paths of different sizes.
                let sampleCount;
                if (perimeter < 50) {
                    sampleCount = 30; // Tiny paths
                } else if (perimeter < 250) {
                    sampleCount = 60; // Small paths
                } else if (perimeter < 750) {
                    sampleCount = 100; // Medium paths (around average)
                } else if (perimeter < 1500) {
                    sampleCount = 150; // Large paths
                } else {
                    sampleCount = 200; // Huge paths
                }
                
                const invSampleCount = 1.0 / sampleCount;

                for (let i = 0; i < sampleCount; i++) {
                    points.push(path.getPointAtLength(i * invSampleCount * perimeter));
                }
                if (points.length === 0) return { perimeter, area: 0 };
                
                points.push(points[0]);
                let area = 0;
                for (let i = 0; i < points.length - 1; i++) {
                    area += points[i].x * points[i+1].y - points[i+1].x * points[i].y;
                }
                area = (area < 0 ? -area : area) * 0.5;

                return { perimeter, area };
            },
            _convertAbsoluteToDelta: function(abs) {
                if (abs.length < 2) return [];
                const first = abs[0];
                const delta = [{ x: first.absX, y: first.absY, ...first }];
                delete delta[0].absX; delete delta[0].absY;
                for (let i = 1; i < abs.length; i++) {
                    const curr = abs[i], prev = abs[i-1];
                    const p = { dx: curr.absX - prev.absX, dy: curr.absY - prev.absY, ...curr };
                    delete p.absX; delete p.absY;
                    delta.push(p);
                }
                return delta;
            },
            _convertDeltaToAbsolute: function(delta) {
                const abs = [];
                let curr = { x: 0, y: 0 };
                delta.forEach((p, i) => {
                    if (i === 0) { curr = { x: p.x, y: p.y }; }
                    else { curr.x += p.dx; curr.y += p.dy; }
                    abs.push({ ...p, absX: curr.x, absY: curr.y });
                });
                return abs;
            },
        };

        LogoEngine.Streamer = {
            parent: null, // Will be set to LogoEngine on init
            partialStrokeData: "", // Holds data from a stroke split between chunks

            init: function(file) {
                this.parent._resetAnimationState();
                this.parent.state.isStreaming = true;
                this.parent.state.streamReader = {
                    file: file,
                    readPosition: 0,
                    isReading: false,
                };
                this.partialStrokeData = "";

                const reader = new FileReader();
                reader.onload = (e) => {
                    const text = e.target.result;
                    const headerEndIndex = text.indexOf('|t');
                    if (headerEndIndex === -1) {
                        console.error("Invalid .vis file: table data not found.");
                        return;
                    }

                    const headerText = text.substring(0, headerEndIndex);
                    this.parent.state.streamReader.readPosition = headerEndIndex + 2; // Start after '|t'

                    let pointsForPacing = this._parseHeader(headerText);
                    
                    this._fetchNextChunk().then(() => {
                        this.parent.startAnimation(pointsForPacing);
                    });
                };
                reader.readAsText(file);
            },

            _parseHeader: function(headerText) {
                const parts = headerText.split('|');
                let pointsForPacing = 0;
                parts.forEach(part => {
                    if (!part) return;
                    const token = part[0];
                    const data = part.substring(1);
                    switch(token) {
                        case 'v':
                            const vb = data.split(',').map(v => this.parent._fromVisInt(parseInt(v, 10)));
                            if (vb.length === 4) this.parent.state.viewBox = { x: vb[0], y: vb[1], width: vb[2], height: vb[3] };
                            break;
                        case 'm':
                            this.parent.state.maxGeometricStrokeWidth = this.parent._fromVisInt(parseInt(data, 10));
                            break;
                        case 'p':
                            this.parent.state.colorPalette = JSON.parse(data);
                            break;
                        case 'i':
                            const info = data.split(',').map(v => parseInt(v, 10));
                            if (info[0] === 1) {
                                pointsForPacing = info[1];
                                this.parent.state.totalPointsInLut = info[1];
                            }
                            break;
                    }
                });
                return pointsForPacing;
            },

            _manageBuffer: function() {
                const { streamReader, dataBuffer, isEndOfStream, currentStrokeIndex } = this.parent.state;
                if (!streamReader || streamReader.isReading || isEndOfStream) {
                    return;
                }
                
                const remainingStrokes = dataBuffer.length - currentStrokeIndex;
                
                if (remainingStrokes < this.parent.config.streamBufferThreshold) {
                    this._fetchNextChunk();
                }
            },

            _fetchNextChunk: async function() {
                const { streamReader } = this.parent.state;
                if (!streamReader || streamReader.isReading) return;

                streamReader.isReading = true;
                const file = streamReader.file;
                const start = streamReader.readPosition;
                
                if (start >= file.size) {
                    this.parent.state.isEndOfStream = true;
                    streamReader.isReading = false;
                    if (this.partialStrokeData) {
                        this._parseChunk(this.partialStrokeData);
                        this.partialStrokeData = "";
                    }
                    return;
                }
                
                const end = start + this.parent.config.streamChunkSize;
                const blob = file.slice(start, end);
                const textChunk = await blob.text();
                
                const combinedText = this.partialStrokeData + textChunk;
                const lastStrokeSeparator = combinedText.lastIndexOf('S');
                
                let chunkToParse;
                
                if (lastStrokeSeparator === -1) {
                    this.partialStrokeData = combinedText;
                    chunkToParse = "";
                } else {
                    chunkToParse = combinedText.substring(0, lastStrokeSeparator);
                    this.partialStrokeData = combinedText.substring(lastStrokeSeparator + 1);
                }
                
                const bytesConsumed = new Blob([chunkToParse]).size - new Blob([this.partialStrokeData]).size + (lastStrokeSeparator !== -1 ? 1 : 0);
                streamReader.readPosition = start + (new Blob([textChunk]).size);

                this._parseChunk(chunkToParse);
                streamReader.isReading = false;
            },

            _parseChunk: function(chunkText) {
                if (!chunkText) return;
                const strokes = chunkText.split('S').filter(s => s);
                strokes.forEach(strokeStr => {
                       if (!strokeStr) return;
                       const stroke = [];
                       const regex = /([xycdw])([\-0-9,]+)/g;
                       let match;
                       let currentPoint = {};
                       let isStart = true;

                       while ((match = regex.exec(strokeStr)) !== null) {
                           const type = match[1];
                           const values = match[2];
                           
                           if (isStart) {
                               if (type === 'x') currentPoint.x = this.parent._fromVisInt(parseInt(values, 10));
                               if (type === 'y') {
                                   currentPoint.y = this.parent._fromVisInt(parseInt(values, 10));
                                   stroke.push(currentPoint);
                                   currentPoint = {};
                                   isStart = false;
                               }
                           } else {
                               if (type === 'd') {
                                   const [dx, dy] = values.split(',').map(v => this.parent._fromVisInt(parseInt(v, 10)));
                                   currentPoint.dx = dx;
                                   currentPoint.dy = dy;
                               }
                               if (type === 'c') currentPoint.colorIndex = parseInt(values, 10);
                               if (type === 'w') {
                                   currentPoint.width = this.parent._fromVisInt(parseInt(values, 10));
                                   stroke.push(currentPoint);
                                   currentPoint = {};
                               }
                           }
                       }
                       if(stroke.length > 1) { // Only add valid strokes
                           this.parent.state.dataBuffer.push(stroke);
                       }
                });
            }
        };

        document.addEventListener('DOMContentLoaded', () => LogoEngine.init());
    </script>
</body>
</http>
