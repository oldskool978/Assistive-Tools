<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fiducial Point</title>
    <!--
    ## Fiducial Point - Interactive Visualization ##

    A sophisticated, production-ready interactive splash screen.
    - Node field distribution via Bridson's Algorithm for Blue Noise.
    - Dynamic, orbiting node field with a 3D parallax effect.
    - Hybrid network topology with Delaunay Triangulation in dense regions.
    - High-performance via Time-Decoupled network updates.
    - Optimized nearest-neighbor searches using a Quadtree data structure.
    - Procedural text engine generates unique company principles.
    -->
    <style>
        /* === Core Setup === */
        :root {
            --primary-color: #00aeff;
            --secondary-color: #f0f0f0;
            --background-color: #0a0a1a;
            --container-bg: #1a1a2acc;
            --text-color: #e0e0e0;
            --header-color: #ffffff;
            --border-color: #0077b3;
            --vignette-speed: 1.7s;
            --vignette-opacity: 0.30;
            --vignette-size: 54%;
        }
        html {
            font-size: 16px;
        }
        @media (min-width: 2560px) {
            html { font-size: 18px; }
        }
        @media (min-width: 3840px) {
            html { font-size: 20px; }
        }
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--background-color);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            cursor: pointer;
        }

        /* === UI Elements === */
        .overlay-text {
            position: absolute;
            top: 20px;
            left: 20px;
            color: var(--primary-color);
            opacity: 0.8;
            font-size: 0.875rem;
            pointer-events: none;
            z-index: 2;
        }
        #protocol-toggle {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 3.125rem;
            height: 3.125rem;
            background-color: var(--primary-color);
            border-radius: 50%;
            cursor: pointer;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 10px rgba(0, 174, 255, 0.5);
            transition: transform 0.3s, box-shadow 0.3s;
        }
        #protocol-toggle:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(0, 174, 255, 0.75);
        }
        #protocol-toggle svg {
            width: 1.5rem;
            height: 1.5rem;
            fill: var(--background-color);
        }
        #protocol-panel, #synthesis-panel {
            position: absolute;
            background-color: var(--container-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1.5em;
            color: var(--text-color);
            pointer-events: none;
            text-align: left;
            backdrop-filter: blur(4px);
            box-sizing: border-box;
        }
        #protocol-panel {
            bottom: 5.625rem;
            right: 1.25rem;
            width: 28.125rem;
            max-width: 90vw;
            z-index: 9;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.4s ease, transform 0.4s ease;
            max-height: 80vh;
            overflow-y: auto;
        }
        #protocol-panel.visible {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }
        #protocol-panel h2 {
            color: var(--header-color);
            margin-top: 0;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.5em;
        }
        .protocol-item {
            margin-bottom: 1em;
        }
        .protocol-item strong {
            color: var(--header-color);
            display: block;
        }
        .protocol-item code {
            color: var(--primary-color);
            white-space: pre-wrap;
            font-size: 0.9em;
            display: block;
            background: #00000055;
            padding: 5px;
            border-radius: 4px;
            margin-top: 5px;
        }
        #synthesis-panel {
            min-width: 280px;
            max-width: 90vw;
            border-color: var(--primary-color);
            z-index: 20;
            box-shadow: 0 0 20px #00aeff44;
            word-wrap: break-word;
            line-height: 1.6;
            opacity: 0;
            transform: scale(0.95);
            transition: opacity 0.5s ease, 
                        transform 0.5s ease, 
                        width 0.5s ease;
            pointer-events: none;
            left: -1000px; 
        }
        #synthesis-panel.visible {
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
        }
        #vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, 
                rgba(0,0,0,0) 0%, 
                rgba(0,0,0,0) var(--vignette-size), 
                rgba(0,0,0, var(--vignette-opacity)) 100%);
            pointer-events: none;
            z-index: 5;
            opacity: 0;
            transition: opacity var(--vignette-speed) ease;
        }
        #vignette.visible {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="overlay-text">
        <p>// FIDUCIAL POINT</p>
    </div>

    <div id="vignette"></div>
    <canvas id="unificationCanvas"></canvas>

    <div id="protocol-toggle">
        <svg viewBox="0 0 24 24">
            <path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M11,16.5V14.5H13V16.5H11M11,12.5V7.5H13V12.5H11Z" />
        </svg>
    </div>

    <div id="protocol-panel">
        <h2>About Fiducial Point</h2>
        <div class="protocol-item">
            <strong>Founder</strong>
            <code>David Cache // david@fiducialpoint.com</code>
        </div>
        <div class="protocol-item">
            <strong>Core Competencies</strong>
            <code>Modern Hardware and Software development. Professional Electronics Design, Custom Hardware Engineering, and Advanced Systems Programming.</code>
        </div>
        <div class="protocol-item">
            <strong>Mission</strong>
            <code>Pioneering bleeding-edge electronics solutions by transforming complex engineering challenges into significant market opportunities.</code>
        </div>
    </div>
    
    <div id="synthesis-panel"></div>

    <script>
        // =================================================================
        // Fiducial Point :: Core Application Logic
        // =================================================================

        // --- DOM Elements ---
        const canvas = document.getElementById('unificationCanvas');
        const ctx = canvas.getContext('2d');
        const protocolToggle = document.getElementById('protocol-toggle');
        const protocolPanel = document.getElementById('protocol-panel');
        const synthesisPanel = document.getElementById('synthesis-panel');
        const vignette = document.getElementById('vignette');
        

    /**
     * @class GenerativeTextEngine
     * @description A self-contained, static class for generating unique, themed phrases.
     * It uses a system of themes, templates, and word banks to procedurally construct
     * sentences, ensuring variety and preventing immediate repetition.
     */
    class GenerativeTextEngine {
        // -- Private Static Properties for Data and State --
        static _themeDeck = [];
        static _templateDecks = {};
        static _wordBankDecks = {};

        /**
         * @description Primary data structure for all generative content. This object
         * defines the vocabulary and grammatical structures the engine uses.
         *
         * ARCHITECTURAL PRINCIPLES:
         * 1. Combinatorial Expansion: To maximize variety, complex ideas are deconstructed
         * into granular, component-based word banks (e.g., system properties, classes, types).
         * Templates assemble these components, creating a vast number of unique permutations
         * from a concise vocabulary.
         *
         * 2. Grammatical Integrity: Word banks are curated to prevent malformations.
         * For instance, nouns are separated into singular and plural banks, and adjectives
         * are stored without articles to prevent duplication (e.g., "the a..."). This
         * enforces grammatical correctness at the data level.
         *
         * 3. Nested Resolution: The generation logic iteratively processes placeholders. This
         * allows word banks themselves to contain placeholders, enabling complex, multi-level
         * phrase construction without run-on sentences.
         */
        static _commonWordBanks = {
            industry: [
              { "text": "aerospace and defense" }, { "text": "medical technology" },
              { "text": "robotics" }, { "text": "semiconductors" },
              { "text": "scientific research and high-performance computing" },
              { "text": "automotive and autonomous systems" },
              { "text": "telecommunications and wireless communications" },
              { "text": "advanced materials science" },
              { "text": "emerging technology ventures" }
            ],
            application_plural: [
              { "text": "mission-critical embedded systems" },
              { "text": "next-generation consumer electronics" },
              { "text": "reference-grade analysis and instrumentation" },
              { "text": "advanced software-defined radio (SDR) platforms" },
              { "text": "high-fidelity audio processing and codec implementations" },
              { "text": "heterogeneous compute platforms" },
              { "text": "safety-critical control systems" }
            ],
            application_singular: [
              { "text": "a mission-critical embedded system" },
              { "text": "a next-generation consumer electronic device" },
              { "text": "a reference-grade analysis instrument" },
              { "text": "an advanced software-defined radio (SDR) platform" },
              { "text": "a high-fidelity audio processing pipeline" },
              { "text": "a heterogeneous compute platform" },
              { "text": "a safety-critical control system" }
            ],
            hardware_domain: [
              { "text": "programmable logic (FPGA/CPLD)" },
              { "text": "{rf_descriptor} RF front-end design" },
              { "text": "precision analog-to-digital and digital-to-analog conversion" },
              { "text": "embedded SoC integration" },
              { "text": "gate-level logic design" },
              { "text": "HDL-based digital logic design (VHDL/Verilog/SystemVerilog)" },
              { "text": "custom silicon architecture and implementation" },
              { "text": "instruction set architecture (ISA) level design" }
            ],
            software_domain: [
              { "text": "bare-metal firmware" },
              { "text": "real-time operating systems (RTOS)" },
              { "text": "hardware abstraction layers (HAL)" },
              { "text": "custom audio codec development and implementation" },
              { "text": "performance-critical kernel development" },
              { "text": "runtime optimization at the opcode level" }
            ],
            unified_expertise: [
              { "text": "holistic hardware/software co-design" },
              { "text": "end-to-end signal chain design" },
              { "text": "the synthesis of advanced mathematics and practical silicon engineering" },
              { "text": "rigorous {analysis_focus} across the full {signal_chain_focus} signal chain" },
              { "text": "leading-edge mixed-signal and data converter architectures" },
              { "text": "multi-vector PPA (power, performance, area) optimization" },
              { "text": "the complete digital implementation flow, from synthesis to physical verification" }
            ],
            
            // --- GRANULAR WORDBANKS for increased permutations ---
            system_property_full: [ // Use when the template does NOT have an article. e.g., "...results in {system_property_full}"
                { "text": "a fault-tolerant" }, { "text": "a resilient" }, { "text": "a high-availability" }, { "text": "a fully-validated" }
            ],
            system_property_adj: [ // Use when the template already has an article or needs an adjective. e.g., "...delivers {system_property_adj} integrity"
                { "text": "fault-tolerant" }, { "text": "resilient" }, { "text": "high-availability" }, { "text": "fully-validated" }
            ],
            system_class: [
                { "text": "mission-critical" }, { "text": "safety-critical" }, { "text": "performance-critical" }, { "text": "production-ready" }
            ],
            system_type: [
                { "text": "system" }, { "text": "platform" }, { "text": "architecture" }, { "text": "hardware solution" }
            ],
            development_focus: [
                { "text": "turnkey product development" }, { "text": "end-to-end project execution" }, { "text": "strategic technical leadership" }
            ],
            management_focus: [
                { "text": "full lifecycle management" }, { "text": "strategic supply chain oversight" }, { "text": "holistic product engineering" }
            ],
            media_descriptor: [
                { "text": "next-generation" }, { "text": "high-fidelity" }, { "text": "emerging" }
            ],
            rf_descriptor: [
                { "text": "high-performance" }, { "text": "wide-band" }, { "text": "low-noise" }
            ],
            signal_chain_focus: [
                { "text": "RF" }, { "text": "audio" }, { "text": "mixed-signal" }
            ],
            analysis_focus: [
                { "text": "Fourier analysis" }, { "text": "statistical modeling" }, { "text": "signal correlation" }
            ]
        };

        static _themes = [
            {
              "name": "Innovation and Pioneering",
              "templates": [
                "{action_verb} {key_deliverable} for the {industry} sector.",
                "{action_verb} solutions for the {media_descriptor} media and professional audio sector.",
                "The principle of {guiding_principle} delivers {client_advantage} on complex {application_plural} projects.",
                "A mastery of {unified_expertise} directly architects {key_deliverable}, providing {client_advantage}.",
                "Our philosophy of {guiding_principle} translates client needs in the {application_plural} space into {client_advantage}.",
                "Solving {technical_challenge} is the direct path to achieving {client_advantage} in the {industry} sector.",
                "The fusion of {hardware_domain} and {software_domain} makes {key_deliverable} possible.",
                "{action_verb} the approach to {application_plural} unlocks {client_advantage}.",
                "A mastery of {unified_expertise} is foundational to creating {key_deliverable}.",
                "To pioneer in {application_plural}, it takes a mastery of {unified_expertise}.",
                "We bridge the gap between {hardware_domain} and {software_domain}, creating {key_deliverable} for the {industry} sector.",
                "Our approach to {technical_challenge} redefines what's possible in {application_plural}.",
                "By applying the principle of {guiding_principle}, we deconstruct {technical_challenge}, resulting in {system_property_full} {system_class} {system_type}.",
                "From first principles to final netlist, our mastery of {hardware_domain} results in {key_deliverable}."
              ],
              "wordBanks": {
                "action_verb": [
                  { "text": "Pioneering" }, { "text": "Unifying" }, { "text": "Accelerating" }, { "text": "Architecting" },
                  { "text": "Redefining" }, { "text": "Synthesizing" }, { "text": "Realizing" }, { "text": "Executing" }
                ],
                "technical_challenge": [
                  { "text": "the synthesis of disparate compute paradigms" },
                  { "text": "systemic bottlenecks through hardware acceleration" },
                  { "text": "the practical implementation of novel mathematical concepts" },
                  { "text": "complex RF modulation and demodulation schemes" },
                  { "text": "nanosecond-level timing closure in complex systems" },
                  { "text": "emerging compute paradigms on constrained hardware" }
                ],
                "key_deliverable": [
                  { "text": "a category-defining technology platform" },
                  { "text": "a paradigm-shifting system architecture" },
                  { "text": "a foundational piece of intellectual property" },
                  { "text": "a system engineered for generational longevity" },
                  { "text": "a verifiably correct and robust system architecture" },
                  { "text": "a fully-realized technology vision" }
                ],
                "client_advantage": [
                  { "text": "a sustainable technological moat" },
                  { "text": "the certainty of architectural integrity" },
                  { "text": "the transformation of ambitious vision into market-ready reality" },
                  { "text": "the creation of a defensible IP portfolio" },
                  { "text": "a unified and unambiguous development path" }
                ],
                "guiding_principle": [
                  { "text": "first-principles engineering" },
                  { "text": "ground-truth engineering" },
                  { "text": "adherence to the physics of computation" },
                  { "text": "holistic system design from gate-level to application" },
                  { "text": "mathematically-rigorous architectural modeling" },
                  { "text": "a vertically-integrated design approach" }
                ]
              }
            },
            {
              "name": "Reliability and Mission-Critical Systems",
              "templates": [
                "Our expertise in {core_service} allows us to {reliability_action} the challenge of {technical_challenge}, delivering {system_property_full} {system_class} {system_type}.",
                "Excellence in {core_service} means solving {technical_challenge} to give clients {client_advantage}.",
                "A mastery of {unified_expertise} is the cornerstone of every project, resulting in {key_deliverable}.",
                "Mastering the prototype-to-production path means tackling {technical_challenge} to deliver {key_deliverable}.",
                "For {application_plural}, the principle of {guiding_principle} ensures {system_property_full} {system_class} {system_type}.",
                "{core_service} directly mitigates project risk, providing {client_advantage}.",
                "A mastery of {unified_expertise} delivers {client_advantage} for high-stakes systems.",
                "Adherence to {guiding_principle} is non-negotiable when engineering for the {industry} sector.",
                "For the {industry} sector, {core_service} is a guarantee of {client_advantage}.",
                "A commitment to {guiding_principle} delivers {system_property_full} {system_class} {system_type} that performs under pressure.",
                "Navigating {technical_challenge} requires a mastery of {unified_expertise}.",
                "Our execution of {core_service} provides {client_advantage} for {application_plural}.",
                "A deep understanding of {hardware_domain} is how we guarantee {system_property_full} {system_type} at a gate level.",
                "For systems in hostile environments, our expertise in {core_service} delivers {system_property_adj} operational integrity."
              ],
              "wordBanks": {
                "core_service": [
                  { "text": "principled system architecture and integration" },
                  { "text": "end-to-end {signal_chain_focus} system design and characterization" },
                  { "text": "high-fidelity design realization and verification" },
                  { "text": "architectural optimization for power, performance, and area" },
                  { "text": "rigorous, cycle-accurate system validation" },
                  { "text": "formal verification of mission-critical logic" }
                ],
                "reliability_action": [
                  { "text": "solve" }, { "text": "master" }, { "text": "mitigate" }, { "text": "eliminate" }
                ],
                "technical_challenge": [
                  { "text": "achieving absolute real-time determinism" },
                  { "text": "preserving signal integrity in high-frequency environments" },
                  { "text": "JTAG-level silicon debug and validation" },
                  { "text": "metastability avoidance in asynchronous clock domains" },
                  { "text": "single-event upset (SEU) mitigation for hostile environments" },
                  { "text": "achieving theoretical limits in signal-to-noise ratio" }
                ],
                "key_deliverable": [
                  { "text": "a certifiably robust and compliant system" },
                  { "text": "a five-nines availability compute platform" },
                  { "text": "a radiation-tolerant digital design" },
                  { "text": "a system with unimpeachable operational integrity" }
                ],
                "client_advantage": [
                  { "text": "a radical reduction in development risk" },
                  { "text": "uncompromised system performance and reliability" },
                  { "text": "a clear, de-risked path to production" },
                  { "text": "absolute execution predictability" },
                  { "text": "a verifiably correct and secure technology foundation" }
                ],
                "guiding_principle": [
                  { "text": "end-to-end ownership" },
                  { "text": "full-stack mastery" },
                  { "text": "absolute determinism" },
                  { "text": "transforming complexity into reliability" },
                  { "text": "a nuanced understanding of the hardware-software interface" },
                  { "text": "zero-defect design principles" }
                ]
              }
            },
            {
              "name": "Strategic Partnership and Turnkey Solutions",
              "templates": [
                "We provide {development_focus} and {management_focus}, giving clients {client_advantage} from concept to production.",
                "Our philosophy of {guiding_principle} ensures a seamless development journey for {application_plural}.",
                "By offering {development_focus}, we transform the challenge of {technical_challenge} into a scalable {system_type}.",
                "The value of combining {development_focus} with {management_focus} is {client_advantage} for our partners.",
                "A commitment to {guiding_principle} builds the trust needed for complex {application_plural} development.",
                "A mastery of {unified_expertise} enables us to offer true {development_focus} and {management_focus}.",
                "From architecture to production, our principle of {guiding_principle} delivers {client_advantage}.",
                "Our partnership model streamlines the path from concept to a scalable {key_deliverable}.",
                "Through a dedicated partnership, we {strategic_action} the complexities of {technical_challenge}, delivering {client_advantage}.",
                "Successful development of {application_singular} requires more than technology; it demands a philosophy of {guiding_principle}."
              ],
              "wordBanks": {
                 "strategic_action": [
                    { "text": "streamline" }, { "text": "resolve" }, { "text": "manage" }, { "text": "de-risk" }
                ],
                "technical_challenge": [
                  { "text": "complex supply chains and fabrication logistics" },
                  { "text": "scaling from prototype to mass production" },
                  { "text": "multi-vendor technology integration" },
                  { "text": "global certification and regulatory compliance" },
                  { "text": "custom IP development for performance-critical bottlenecks" }
                ],
                "key_deliverable": [
                  { "text": "a fully-managed, resilient production pipeline" },
                  { "text": "a market-ready, vertically-integrated product" },
                  { "text": "a robust, scalable, and future-proof architecture" },
                  { "text": "a strategically-sourced and optimized bill of materials" },
                  { "text": "a complete, market-defining product ecosystem" }
                ],
                "client_advantage": [
                  { "text": "a single, expert point of accountability" },
                  { "text": "a de-risked, accelerated product launch" },
                  { "text": "complete ownership of all intellectual property" },
                  { "text": "a resilient and future-proof supply chain" },
                  { "text": "a streamlined, predictable path to profitability" }
                ],
                "guiding_principle": [
                  { "text": "radical transparency and collaboration" },
                  { "text": "focus on the entire product lifecycle" },
                  { "text": "proactive risk mitigation" },
                  { "text": "agile, yet rigorous, hardware development" },
                  { "text": "the unification of disparate engineering disciplines" }
                ]
              }
            }
        ];
        
        /**
         * @description Generates the next unique phrase from the available content.
         * @returns {string} A fully-formed, unique sentence.
         */
        static getNextUniquePhrase() {
            // 1. Select a theme, ensuring themes are not repeated until all have been used.
            if (this._themeDeck.length === 0) {
                this._themeDeck = this._shuffleArray(Array.from(this._themes.keys()));
            }
            const themeIndex = this._themeDeck.pop();
            const theme = this._themes[themeIndex];

            // 2. Select a template from the chosen theme, ensuring templates are not repeated.
            if (!this._templateDecks[themeIndex] || this._templateDecks[themeIndex].length === 0) {
                this._templateDecks[themeIndex] = this._shuffleArray(Array.from(theme.templates.keys()));
            }
            const templateIndex = this._templateDecks[themeIndex].pop();
            let phrase = theme.templates[templateIndex];

            // 3. Iteratively find and replace all placeholders until none are left.
            // This loop is crucial for handling nested placeholders, where a replacement
            // string itself contains another placeholder.
            let placeholders = phrase.match(/{(\w+)}/g);
            let safety_check = 10; // Prevent infinite loops in case of a bug
            while (placeholders && safety_check > 0) {
                // 4. For each unique placeholder, find a corresponding word and substitute it.
                [...new Set(placeholders)].forEach(placeholder => {
                    const key = placeholder.substring(1, placeholder.length - 1);
                    let originalBank = (theme.wordBanks && theme.wordBanks[key]) || this._commonWordBanks[key];
                    if (!originalBank) return;

                    // 5. Ensure words from a specific bank are not repeated until all are used.
                    if (!this._wordBankDecks[key] || this._wordBankDecks[key].length === 0) {
                        this._wordBankDecks[key] = this._shuffleArray([...originalBank]);
                    }
                    
                    let wordObject = this._wordBankDecks[key].pop();
                    const regex = new RegExp(placeholder.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'g');
                    phrase = phrase.replace(regex, wordObject.text);
                });

                // Check for any new placeholders that might have been introduced in the last pass.
                placeholders = phrase.match(/{(\w+)}/g);
                safety_check--;
            }

            // 6. Capitalize the first letter and return the final phrase.
            return phrase.charAt(0).toUpperCase() + phrase.slice(1);
        }

        /**
         * @description Shuffles an array in place.
         * @param {Array} array The array to shuffle.
         * @returns {Array} The shuffled array.
         */
        static _shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }
    }

        // --- Simulation State ---
        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;
        let scalingFactor = Math.max(1, Math.pow(width / 1920, 0.5));
        let nodes = [];
        let edgeMap = new Map();
        let quadtree;
        const maxNodes = 150; 
        let selectedNode = null;
        let hoveredNode = null;
        let globalSpeedMultiplier = 0.2;
        let modalSide = 'right';
        const glowBrightnessMultiplier = 0.90;
        const centralCoreMultiplier = 0.30;
        const pulseSpeedMultiplier = 750;
        const pulseSizeMultiplier = 1.6;
        const minPulseSize = 0.8;

        // --- Final Aesthetic Parameters ---
        const lineThicknessMultiplier = 0.13;
        const edgeFadeSpeed = 0.070;
        const DENSITY_THRESHOLD = 1;
        
        // --- Dynamic Time Scale Parameters ---
        let timeScale = 1.0;
        const baseTimeScale = 0.6;
        const zoomTimeEffect = 3.1;
        const nodeTimeEffect = 0.3;
        const MIN_ZOOM_FOR_EFFECT = 1.5;
        const MAX_ZOOM_FOR_EFFECT = 8.0;

        // --- Performance Optimization: Temporal Decoupling ---
        const networkUpdateInterval = 100; // ms, for 10 updates per second
        let lastNetworkUpdateTime = 0;

        // --- Network Model Parameters ---
        const DENSITY_RADIUS_FACTOR = 0.14; 
        let densityRadius;

        // --- Viewport Camera State ---
        let viewX = width / 2;
        let viewY = height / 2;
        let targetViewX = width / 2;
        let targetViewY = height / 2;
        let zoom = 1.5;
        let targetZoom = 1.5;
        
        // --- Modal Physics State ---
        let modalX = -1000, modalY = -1000;
        let modalVelX = 0, modalVelY = 0;
        let targetModalX = -1000, targetModalY = -1000;
        const springStiffness = 0.04;
        const springDamping = 0.4;

        // --- Quadtree Implementation ---
        class Quadtree {
            constructor(boundary, capacity = 4) {
                this.boundary = boundary; this.capacity = capacity;
                this.points = []; this.divided = false;
            }
            subdivide() {
                const { x, y, width, height } = this.boundary;
                const hw = width / 2, hh = height / 2;
                this.northeast = new Quadtree(createBoundary(x + hw, y, hw, hh), this.capacity);
                this.northwest = new Quadtree(createBoundary(x, y, hw, hh), this.capacity);
                this.southeast = new Quadtree(createBoundary(x + hw, y + hh, hw, hh), this.capacity);
                this.southwest = new Quadtree(createBoundary(x, y + hh, hw, hh), this.capacity);
                this.divided = true;
            }
            insert(point) {
                if (!this.boundary.contains(point)) return false;
                if (this.points.length < this.capacity) { this.points.push(point); return true; }
                if (!this.divided) this.subdivide();
                return this.northeast.insert(point) || this.northwest.insert(point) ||
                       this.southeast.insert(point) || this.southwest.insert(point);
            }
            query(range, found = []) {
                if (!this.boundary.intersects(range)) return found;
                for (const p of this.points) { if (range.contains(p)) found.push(p); }
                if (this.divided) {
                    this.northwest.query(range, found); this.northeast.query(range, found);
                    this.southwest.query(range, found); this.southeast.query(range, found);
                }
                return found;
            }
        }
        function createBoundary(x, y, w, h) {
            return {
                x, y, width: w, height: h,
                contains: point => (point.x >= x && point.x <= x + w && point.y >= y && point.y <= y + h),
                intersects: range => !(range.x > x + w || range.x + range.width < x || range.y > y + h || range.y + range.height < y)
            };
        }

        // --- Delaunay Triangulation Utility ---
        const Delaunay = (() => {
            const EPSILON = 1.0 / 1048576.0;
            function supertriangle(vertices) {
                let xmin = Number.POSITIVE_INFINITY, ymin = Number.POSITIVE_INFINITY,
                    xmax = Number.NEGATIVE_INFINITY, ymax = Number.NEGATIVE_INFINITY,
                    i, dx, dy, dmax, xmid, ymid;
                for (i = vertices.length; i--;) {
                    if (vertices[i].x < xmin) xmin = vertices[i].x;
                    if (vertices[i].x > xmax) xmax = vertices[i].x;
                    if (vertices[i].y < ymin) ymin = vertices[i].y;
                    if (vertices[i].y > ymax) ymax = vertices[i].y;
                }
                dx = xmax - xmin, dy = ymax - ymin, dmax = Math.max(dx, dy);
                xmid = xmin + dx * 0.5, ymid = ymin + dy * 0.5;
                return [{ x: xmid - 20 * dmax, y: ymid - dmax }, { x: xmid, y: ymid + 20 * dmax }, { x: xmid + 20 * dmax, y: ymid - dmax }];
            }
            function circumcircle(vertices, i, j, k) {
                let x1 = vertices[i].x, y1 = vertices[i].y, x2 = vertices[j].x, y2 = vertices[j].y, x3 = vertices[k].x, y3 = vertices[k].y,
                    fabsy1y2 = Math.abs(y1 - y2), fabsy2y3 = Math.abs(y2 - y3),
                    xc, yc, m1, m2, mx1, mx2, my1, my2;
                if (fabsy1y2 < EPSILON && fabsy2y3 < EPSILON) return null;
                if (fabsy1y2 < EPSILON) {
                    m2 = -((x3 - x2) / (y3 - y2)); mx2 = (x2 + x3) / 2.0; my2 = (y2 + y3) / 2.0;
                    xc = (x2 + x1) / 2.0; yc = m2 * (xc - mx2) + my2;
                } else if (fabsy2y3 < EPSILON) {
                    m1 = -((x2 - x1) / (y2 - y1)); mx1 = (x1 + x2) / 2.0; my1 = (y1 + y2) / 2.0;
                    xc = (x3 + x2) / 2.0; yc = m1 * (xc - mx1) + my1;
                } else {
                    m1 = -((x2 - x1) / (y2 - y1)); m2 = -((x3 - x2) / (y3 - y2));
                    mx1 = (x1 + x2) / 2.0; my1 = (y1 + y2) / 2.0; mx2 = (x2 + x3) / 2.0; my2 = (y2 + y3) / 2.0;
                    xc = (m1 * mx1 - m2 * mx2 + my2 - my1) / (m1 - m2);
                    yc = (fabsy1y2 > fabsy2y3) ? m1 * (xc - mx1) + my1 : m2 * (xc - mx2) + my2;
                }
                const dx = x2 - xc, dy = y2 - yc;
                return { i, j, k, x: xc, y: yc, radiusSq: dx * dx + dy * dy };
            }
            return {
                triangulate: function(vertices) {
                    let n = vertices.length, i, j, indices, st, open, closed, edges, dx, dy, a, b, c;
                    indices = new Array(n);
                    for (i = n; i--;) indices[i] = i;
                    indices.sort((i, j) => vertices[j].x - vertices[i].x);
                    st = supertriangle(vertices); vertices.push(st[0], st[1], st[2]);
                    open = [circumcircle(vertices, n + 0, n + 1, n + 2)]; closed = []; edges = [];
                    for (i = indices.length; i--;) {
                        c = indices[i]; edges.length = 0;
                        for (j = open.length; j--;) {
                            dx = vertices[c].x - open[j].x;
                            if (dx > 0 && dx * dx > open[j].radiusSq) { closed.push(open[j]); open.splice(j, 1); continue; }
                            dy = vertices[c].y - open[j].y;
                            if (dx * dx + dy * dy - open[j].radiusSq > EPSILON) continue;
                            edges.push(open[j].i, open[j].j, open[j].j, open[j].k, open[j].k, open[j].i); open.splice(j, 1);
                        }
                        edges = edges.filter((v, i) => edges.indexOf(v) === i);
                        for (j = edges.length; j > 1; j -= 2) {
                            b = edges[j - 1]; a = edges[j - 2];
                            open.push(circumcircle(vertices, a, b, c));
                        }
                    }
                    for (i = open.length; i--;) closed.push(open[i]);
                    vertices.length -= 3;
                    const results = [];
                    for(i = closed.length; i--; ) {
                        if(closed[i].i < n && closed[i].j < n && closed[i].k < n) results.push([closed[i].i, closed[i].j, closed[i].k]);
                    }
                    return results;
                }
            };
        })();

        // --- Node Class Definition ---
        class Node {
            constructor(initialAngle, id) {
                this.id = id;
                this.centerX = width / 2; this.centerY = height / 2; this.scale = Math.random() * 0.7 + 0.3;
                this.radiusXFactor = (Math.random() * (1.0 - centralCoreMultiplier) + centralCoreMultiplier);
                this.radiusYFactor = (Math.random() * 0.5 + 0.3); this.orbitRotation = Math.random() * Math.PI;
                const maxRadius = ((width + height) / 2) / 2.2;
                this.orbitRadiusX = this.radiusXFactor * maxRadius;
                this.orbitRadiusY = this.orbitRadiusX * this.radiusYFactor; this.currentAngle = initialAngle;
                const speedScale = 0.7 + (this.scale * 0.3); this.baseSpeed = (0.0008 + Math.random() * 0.001) * speedScale;
                this.speed = this.baseSpeed * globalSpeedMultiplier;
                this.x = 0; this.y = 0;
                this.renderX = 0; this.renderY = 0;
                this.baseRadius = 1.5 * scalingFactor; this.info = null;
                this.update(1); // Set initial position
                this.renderX = this.x; this.renderY = this.y; // Sync render state
            }
            update(timeMultiplier) {
                this.currentAngle += this.speed * timeMultiplier;
                const unrotatedX = this.orbitRadiusX * Math.cos(this.currentAngle);
                const unrotatedY = this.orbitRadiusY * Math.sin(this.currentAngle);
                const rotatedX = unrotatedX * Math.cos(this.orbitRotation) - unrotatedY * Math.sin(this.orbitRotation);
                const rotatedY = unrotatedX * Math.sin(this.orbitRotation) + unrotatedY * Math.cos(this.orbitRotation);
                this.x = this.centerX + rotatedX; this.y = this.centerY + rotatedY;
            }
            updateRenderPosition() {
                this.renderX += (this.x - this.renderX) * 0.15;
                this.renderY += (this.y - this.renderY) * 0.15;
            }
            draw(ctx, isSelected, isHovered, pulse) {
                const displayRadius = this.baseRadius * this.scale + (isSelected ? pulse : 0);
                if (isSelected) { ctx.shadowColor = 'rgba(240, 240, 240, 0.7)'; ctx.shadowBlur = 10 * this.scale; }
                ctx.beginPath(); ctx.arc(this.renderX, this.renderY, displayRadius, 0, Math.PI * 2);
                ctx.fillStyle = isSelected ? 'var(--secondary-color)' : (isHovered ? '#bbb' : '#e0e0e0');
                ctx.fill();
                if (isSelected) { ctx.shadowBlur = 0; }
            }
            onResize(newWidth, newHeight, newScalingFactor) {
                this.centerX = newWidth / 2; this.centerY = newHeight / 2;
                const newMaxRadius = ((newWidth + newHeight) / 2) / 2.2;
                this.orbitRadiusX = this.radiusXFactor * newMaxRadius;
                this.orbitRadiusY = this.orbitRadiusX * this.radiusYFactor;
                this.baseRadius = 1.5 * newScalingFactor;
            }
        }
        
        // --- Point & Network Generation ---
        function generateBlueNoiseDistribution(nWidth, nHeight, minDistance, maxPoints) {
            const k = 30, grid = [], activeSamples = [], points = [];
            const cellSize = minDistance / Math.SQRT2;
            const cols = Math.floor(nWidth / cellSize) + 1, rows = Math.floor(nHeight / cellSize) + 1;
            for (let i = 0; i < cols * rows; i++) grid.push(null);
            const p0 = { x: Math.random() * nWidth, y: Math.random() * nHeight };
            activeSamples.push(p0); points.push(p0);
            grid[Math.floor(p0.x / cellSize) + Math.floor(p0.y / cellSize) * cols] = p0;
            while (activeSamples.length > 0 && points.length < maxPoints) {
                const randIndex = Math.floor(Math.random() * activeSamples.length), sample = activeSamples[randIndex];
                let found = false;
                for (let i = 0; i < k; i++) {
                    const angle = Math.random() * Math.PI * 2, radius = Math.random() * minDistance + minDistance;
                    const newSample = { x: sample.x + Math.cos(angle) * radius, y: sample.y + Math.sin(angle) * radius };
                    if (newSample.x >= 0 && newSample.x < nWidth && newSample.y >= 0 && newSample.y < nHeight) {
                        const gridX = Math.floor(newSample.x / cellSize), gridY = Math.floor(newSample.y / cellSize);
                        let isValid = true;
                        for (let y = -2; y <= 2; y++) {
                            for (let x = -2; x <= 2; x++) {
                                const neighborIndex = (gridX + x) + (gridY + y) * cols;
                                if (grid[neighborIndex]) {
                                    const d = Math.sqrt((newSample.x - grid[neighborIndex].x) ** 2 + (newSample.y - grid[neighborIndex].y) ** 2);
                                    if (d < minDistance) { isValid = false; break; }
                                }
                            }
                            if (!isValid) break;
                        }
                        if (isValid) {
                            points.push(newSample); activeSamples.push(newSample);
                            grid[gridX + gridY * cols] = newSample; found = true; break;
                        }
                    }
                }
                if (!found) activeSamples.splice(randIndex, 1);
            }
            const centerX = nWidth / 2, centerY = nHeight / 2;
            return points.map(p => Math.atan2(p.y - centerY, p.x - centerX));
        }

        function updateNetworkTopology() {
            buildQuadtree();
            const currentEdgeKeys = new Set();
            const nodeNeighbors = nodes.map(node => quadtree.query(createBoundary(node.x - densityRadius, node.y - densityRadius, densityRadius * 2, densityRadius * 2)).filter(other => other.id !== node.id));
            const isDense = nodes.map((_, i) => nodeNeighbors[i].length >= DENSITY_THRESHOLD);
            const processed = new Array(nodes.length).fill(false);
            for (let i = 0; i < nodes.length; i++) {
                if (!isDense[i] || processed[i]) continue;
                const patch = []; const queue = [i]; processed[i] = true;
                while (queue.length > 0) {
                    const currentIndex = queue.shift(); patch.push(nodes[currentIndex]);
                    nodeNeighbors[currentIndex].forEach(neighbor => {
                        if (isDense[neighbor.id] && !processed[neighbor.id]) { processed[neighbor.id] = true; queue.push(neighbor.id); }
                    });
                }
                if (patch.length > 2) {
                    const triangles = Delaunay.triangulate(patch);
                    triangles.forEach(triangle => {
                        [[patch[triangle[0]], patch[triangle[1]]], [patch[triangle[1]], patch[triangle[2]]], [patch[triangle[2]], patch[triangle[0]]]].forEach(pair => {
                            if (!pair[0] || !pair[1]) return;
                             currentEdgeKeys.add([pair[0].id, pair[1].id].sort().join('-'));
                        });
                    });
                }
            }
            for (let i = 0; i < nodes.length; i++) {
                nodeNeighbors[i].forEach(neighbor => {
                    if (nodes[i].id < neighbor.id) { currentEdgeKeys.add([nodes[i].id, neighbor.id].sort().join('-')); }
                });
            }
            for (const [key, edge] of edgeMap.entries()) {
                if (!currentEdgeKeys.has(key)) { edge.targetOpacity = 0; }
            }
            for (const key of currentEdgeKeys) {
                if (!edgeMap.has(key)) {
                    const [id1, id2] = key.split('-');
                    edgeMap.set(key, { source: nodes[id1], target: nodes[id2], currentOpacity: 0, targetOpacity: 1 });
                } else {
                    edgeMap.get(key).targetOpacity = 1;
                }
            }
        }

        // --- Core Simulation & Rendering ---
        function setDynamicSizes() {
            const minDim = Math.min(width, height);
            densityRadius = minDim * DENSITY_RADIUS_FACTOR;
        }

        function init() {
            nodes = [];
            edgeMap.clear();
            setDynamicSizes();
            const minNodeDistance = 60 * scalingFactor;
            const initialAngles = generateBlueNoiseDistribution(width, height, minNodeDistance, maxNodes);
            for (let i = 0; i < initialAngles.length; i++) {
                nodes.push(new Node(initialAngles[i], i));
            }
            updateNodePhysics();
            updateNetworkTopology();
        }

        function buildQuadtree() {
            const boundary = createBoundary(0, 0, width, height);
            quadtree = new Quadtree(boundary);
            nodes.forEach(node => quadtree.insert(node));
        }

        function updateNodePhysics() {
            updateDynamicTimeScale();
            nodes.forEach(node => {
                node.speed = node.baseSpeed * globalSpeedMultiplier; 
                node.update(timeScale);
            });
        }
        
        function renderNetwork() {
            const interactiveNodes = new Set([selectedNode, hoveredNode]);
            const edgesToDelete = [];

            for (const [key, edge] of edgeMap.entries()) {
                edge.currentOpacity += (edge.targetOpacity - edge.currentOpacity) * edgeFadeSpeed;
                if (edge.targetOpacity === 0 && edge.currentOpacity < 0.01) { edgesToDelete.push(key); continue; }
                if (edge.currentOpacity < 0.01) continue;

                const { source: n1, target: n2 } = edge;
                if (!n1 || !n2) continue;

                const isN1Interactive = interactiveNodes.has(n1);
                const isN2Interactive = interactiveNodes.has(n2);
                
                const dynamicOpacity = (n1.scale + n2.scale) * 0.5;
                const baseOpacity1 = n1.scale * 0.35 * dynamicOpacity * edge.currentOpacity;
                const baseOpacity2 = n2.scale * 0.35 * dynamicOpacity * edge.currentOpacity;
                const glowOpacity1 = glowBrightnessMultiplier * n1.scale * dynamicOpacity * edge.currentOpacity;
                const glowOpacity2 = glowBrightnessMultiplier * n2.scale * dynamicOpacity * edge.currentOpacity;
                
                const color1 = `rgba(0, 174, 255, ${baseOpacity1})`;
                const color2 = `rgba(0, 174, 255, ${baseOpacity2})`;
                const glow1 = `rgba(240, 240, 240, ${glowOpacity1})`;
                const glow2 = `rgba(240, 240, 240, ${glowOpacity2})`;

                const startColor = isN1Interactive ? glow1 : color1;
                const endColor = isN2Interactive ? glow2 : color2;

                const gradient = ctx.createLinearGradient(n1.renderX, n1.renderY, n2.renderX, n2.renderY);
                gradient.addColorStop(0, startColor);
                gradient.addColorStop(1, endColor);
                
                ctx.beginPath();
                ctx.moveTo(n1.renderX, n1.renderY);
                ctx.lineTo(n2.renderX, n2.renderY);
                ctx.strokeStyle = gradient;
                ctx.lineWidth = lineThicknessMultiplier * dynamicOpacity;
                ctx.stroke();
            }
            edgesToDelete.forEach(key => edgeMap.delete(key));
        }
        
        function updateDynamicTimeScale() {
            const zoomFactor = Math.max(0, Math.min(1, (zoom - MIN_ZOOM_FOR_EFFECT) / (MAX_ZOOM_FOR_EFFECT - MIN_ZOOM_FOR_EFFECT)));
            
            let nodeFactor = 0;
            if (selectedNode) {
                nodeFactor = 1.0 - ((selectedNode.scale - 0.3) / 0.7);
            }

            timeScale = baseTimeScale + (zoomFactor * zoomTimeEffect) + (nodeFactor * nodeTimeEffect * zoomFactor);
        }

        function animate(timestamp) {
            updateDynamicTimeScale();

            if (timestamp - lastNetworkUpdateTime > (networkUpdateInterval / timeScale)) {
                updateNetworkTopology();
                lastNetworkUpdateTime = timestamp;
            }

            if (selectedNode) {
                let targetNodeScreenX = (modalSide === 'right') ? width / 3 : width * 2 / 3;
                targetViewX = selectedNode.x - (targetNodeScreenX - width / 2) / targetZoom;
                targetViewY = selectedNode.y;
            }
            viewX += (targetViewX - viewX) * 0.08;
            viewY += (targetViewY - viewY) * 0.08;
            zoom += (targetZoom - zoom) * 0.08;

            const minZoom = 1.5, maxZoom = 8.0;
            const minSpeed = 0.20, maxSpeed = 0.60;
            let t = Math.max(0, Math.min(1, (zoom - minZoom) / (maxZoom - minZoom)));
            const targetSpeed = minSpeed + t * (maxSpeed - minSpeed);
            globalSpeedMultiplier += (targetSpeed - globalSpeedMultiplier) * 0.05;

            updateNodePhysics();
            nodes.forEach(node => node.updateRenderPosition());
            updateModalPhysics();

            ctx.clearRect(0, 0, width, height);
            ctx.save();
            ctx.translate(width / 2, height / 2);
            ctx.scale(zoom, zoom);
            ctx.translate(-viewX, -viewY);
            
            renderNetwork();

            const sortedNodes = [...nodes].sort((a, b) => a.scale - b.scale);
            const sine = Math.sin(timestamp / pulseSpeedMultiplier);
            const pulse = selectedNode ? (sine * 0.5 + 0.5) * (pulseSizeMultiplier - minPulseSize) + minPulseSize : 0;
            sortedNodes.forEach(node => node.draw(ctx, node === selectedNode, node === hoveredNode, pulse));
            
            ctx.restore();
            updateSynthesisPanelTargetPosition();
            requestAnimationFrame(animate);
        }

        function updateModalPhysics() {
            if (!selectedNode) return;
            const forceX = (targetModalX - modalX) * springStiffness;
            const forceY = (targetModalY - modalY) * springStiffness;
            const dampingX = modalVelX * springDamping;
            const dampingY = modalVelY * springDamping;
            modalVelX += forceX - dampingX;
            modalVelY += forceY - dampingY;
            modalX += modalVelX;
            modalY += modalVelY;
            if (Math.abs(modalVelX) > 0.01 || Math.abs(modalVelY) > 0.01) {
                synthesisPanel.style.left = `${modalX}px`;
                synthesisPanel.style.top = `${modalY}px`;
            }
        }
        
        // --- UI Logic & Event Handlers ---
        function deselectNodeAndResetView() {
            selectedNode = null;
            synthesisPanel.classList.remove('visible');
            vignette.classList.remove('visible');
            targetViewX = width / 2;
            targetViewY = height / 2;
            targetZoom = 1.5;
        }

        function updateSynthesisPanelTargetPosition() {
            if (!selectedNode) return;
            const panelWidth = synthesisPanel.offsetWidth, panelHeight = synthesisPanel.offsetHeight;
            const screenPadding = 20;
            let idealPanelX = (modalSide === 'right') ? (width * 2 / 3) - (panelWidth / 2) : (width / 3) - (panelWidth / 2);
            const screenY = (selectedNode.renderY - viewY) * zoom + height / 2;
            let panelY = screenY - panelHeight / 2;
            targetModalY = Math.max(screenPadding, Math.min(panelY, height - panelHeight - screenPadding));
            targetModalX = Math.max(screenPadding, Math.min(idealPanelX, width - panelWidth - screenPadding));
        }
        
        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            scalingFactor = Math.max(1, Math.pow(width / 1920, 0.5));
            nodes.forEach(node => node.onResize(width, height, scalingFactor));
            setDynamicSizes();
            updateNodePhysics();
            updateNetworkTopology();
            if (selectedNode) {
                deselectNodeAndResetView();
            } else {
                targetViewX = width / 2;
                targetViewY = height / 2;
            }
        });

        protocolToggle.addEventListener('click', () => {
            const isOpening = !protocolPanel.classList.contains('visible');
            protocolPanel.classList.toggle('visible');
            if (isOpening) { deselectNodeAndResetView(); }
        });

        canvas.addEventListener('mousemove', (event) => {
            const worldX = (event.clientX - width / 2) / zoom + viewX;
            const worldY = (event.clientY - height / 2) / zoom + viewY;
            const hoverRadius = (30 * scalingFactor) / zoom;
            
            const searchArea = createBoundary(worldX - hoverRadius, worldY - hoverRadius, hoverRadius * 2, hoverRadius * 2);
            const candidates = quadtree ? quadtree.query(searchArea) : [];

            let hits = [];
            for (const node of candidates) {
                const dx = node.renderX - worldX;
                const dy = node.renderY - worldY;
                const dSq = dx * dx + dy * dy;
                if (dSq < hoverRadius * hoverRadius) {
                    hits.push(node);
                }
            }

            if (hits.length === 0) {
                hoveredNode = null;
            } else if (hits.length === 1) {
                hoveredNode = hits[0];
            } else {
                hits.sort((a,b) => b.scale - a.scale);
                hoveredNode = hits[0];
            }
        });

        canvas.addEventListener('click', (event) => {
            if (hoveredNode) {
                protocolPanel.classList.remove('visible');
                if (selectedNode === hoveredNode) {
                    deselectNodeAndResetView();
                } else {
                    const isFirstSelection = selectedNode === null;
                    selectedNode = hoveredNode;
                    const TARGET_ON_SCREEN_SCALE = 3.5; 
                    targetZoom = TARGET_ON_SCREEN_SCALE / selectedNode.scale;
                    const screenX = (hoveredNode.renderX - viewX) * zoom + width / 2;
                    modalSide = (screenX > width / 2) ? 'left' : 'right';
                    
                    if (!selectedNode.info) { 
                        selectedNode.info = GenerativeTextEngine.getNextUniquePhrase(); 
                    }
                    
                    synthesisPanel.innerHTML = selectedNode.info;
                    const textLength = selectedNode.info.length;
                    const minWidth = 280 * scalingFactor;
                    const maxWidth = 450 * scalingFactor;
                    const dynamicWidth = minWidth + Math.sqrt(textLength) * (4 * scalingFactor);
                    synthesisPanel.style.width = `${Math.max(minWidth, Math.min(maxWidth, dynamicWidth))}px`;
                    
                    if (isFirstSelection) {
                        setTimeout(() => {
                            updateSynthesisPanelTargetPosition();
                            modalX = targetModalX;
                            modalY = targetModalY;
                        }, 0);
                    }
                    synthesisPanel.classList.add('visible');
                    vignette.classList.add('visible');
                }
            } else {
                 if (!synthesisPanel.contains(event.target)){
                    deselectNodeAndResetView();
                 }
            }
        });

        document.body.addEventListener('click', (event) => {
            const isClickOnInteractive = canvas.contains(event.target) || 
                                         protocolToggle.contains(event.target) || 
                                         protocolPanel.contains(event.target) ||
                                         synthesisPanel.contains(event.target);
            if (!isClickOnInteractive) {
                deselectNodeAndResetView();
                protocolPanel.classList.remove('visible');
            }
        });

        // --- Initialization ---
        window.onload = () => {
            init();
            requestAnimationFrame(animate);
        };
    </script>
</body>
</html>
