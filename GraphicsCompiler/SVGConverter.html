<!DOCTYPE html>
<html lang="en" class="h-full bg-white">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVG Animator</title>
    <!-- Load Inter font from Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        /* Basic styling for a full-screen canvas */
        html, body {
            height: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent scrollbars */
            font-family: 'Inter', sans-serif;
        }
        body {
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #ffffff;
        }
        #logo-container {
            position: relative;
            width: 90vw;
            height: 90vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #logo-canvas {
            max-width: 100%;
            max-height: 100%;
            display: block;
        }
    </style>
</head>
<body class="antialiased">

    <!-- Canvas container -->
    <div id="logo-container">
        <canvas id="logo-canvas"></canvas>
    </div>

    <!-- Hidden file input for SVG uploads -->
    <input type="file" id="svg-uploader" accept=".svg" style="display: none;">

    <script>
        /**
         * LogoEngine: A comprehensive SVG rendering engine and Look-Up Table (LUT) compiler.
         * This version is hyper-optimized for performance on resource-constrained devices by
         * using a hard-coded integer-based look-up table and bitwise operations.
         */
        const LogoEngine = {
            // --- Configuration & State ---
            config: {
                canvasId: 'logo-canvas',
                defaultSvgMarkup: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="180 250 750 570"><path d="M 396 258 C 275 295, 190 350, 190 450 C 190 560, 250 600, 278 640 C 210 660, 210 700, 256 730 C 350 750, 550 800, 600 810 C 675 790, 800 750, 885 725 C 920 710, 915 690, 866 668 C 830 675, 700 650, 668 617 C 675 550, 680 400, 650 327 C 625 310, 500 300, 456 302 M 396 267 C 390 400, 390 550, 398 603 C 420 610, 670 610, 677 603 C 690 570, 680 450, 668 330 C 650 300, 550 305, 451 307" fill="none" stroke="#000000" stroke-width="2"/></svg>`,
                fallbackStrokeColor: '#0d1a26',
                maxStrokeWidth: 8.5,
                minCurveWidth: 1.5, // The minimum width a line can have on a sharp curve.
                maxPaletteSize: 16,
                holdDurationMs: 500,
            },

            state: {
                canvas: null, ctx: null, lookupTable: null, animationFrameId: null,
                viewBox: { x: 0, y: 0, width: 400, height: 225 },
                colorPalette: [], cssRules: new Map(), drawnPointsCount: 0,
                currentStrokeIndex: 0, currentPointInStrokeIndex: 0,
                clipPathCache: new Map(), reusablePathForSampling: null,
                maxGeometricStrokeWidth: 0,
                currentSvgText: '',
                // State for our pseudo-random number generator
                _lcg_seed: 1,
            },

            // --- Pre-calculated Constants & Animation Profiles ---
            PRECALCULATED: {
                ANIMATION_DURATION_MS: 4000,
                INV_ANIMATION_DURATION_MS: 0.00025,
                EASING_LUT_INT: [0,0,0,0,1,1,1,2,2,3,4,5,6,6,8,9,10,11,12,14,15,17,18,20,22,23,25,27,29,31,33,35,38,40,42,45,47,49,52,54,57,60,62,65,68,71,73,76,79,82,85,88,91,94,97,100,103,106,109,113,116,119,122,125,128,131,135,138,141,144,147,150,153,156,159,162,165,168,171,174,177,180,183,186,189,191,194,197,199,202,204,207,209,212,214,216,218,221,223,225,227,229,231,232,234,236,238,239,241,242,243,245,246,247,248,249,250,251,252,252,253,253,254,254,255,255,255,255,255,255,255,255,254,254,253,253,252,252,251,250,249,248,247,246,245,243,242,241,239,238,236,234,232,231,229,227,225,223,221,218,216,214,212,209,207,204,202,199,197,194,191,189,186,183,180,177,174,171,168,165,162,159,156,153,150,147,144,141,138,135,131,128,125,122,119,116,113,109,106,103,100,97,94,91,88,85,82,79,76,73,71,68,65,62,60,57,54,52,49,47,45,42,40,38,35,33,31,29,27,25,23,22,20,18,17,15,14,12,11,10,9,8,6,6,5,4,3,2,2,1,1,1,0,0,0,0],
                EASING_LUT_SCALE: 255.0,
                CURVATURE_LUT_INT: [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,2,2,2,2,2,3,3,3,4,4,4,5,5,6,6,7,7,8,9,9,10,11,11,12,13,14,15,16,17,18,19,20,21,22,23,24,26,27,28,30,31,33,34,36,37,39,41,43,45,46,48,50,53,55,57,59,61,64,66,69,71,74,76,79,82,85,88,91,94,97,100,103,107,110,114,117,121,124,128,132,136,140,144,148,153,157,161,166,170,175,180,184,189,194,199,205,210,215,221,226,232,237,243,249,255],
                CURVATURE_LUT_SCALE: 255.0,
                VELOCITY_LUT_INT: [154,153,153,153,153,152,152,152,152,151,151,151,151,150,150,150,149,149,149,149,148,148,148,148,147,147,147,146,146,146,146,145,145,145,144,144,144,143,143,143,143,142,142,142,141,141,141,140,140,140,139,139,139,138,138,138,137,137,137,136,136,136,135,135,135,134,134,134,133,133,132,132,132,131,131,131,130,130,129,129,129,128,128,127,127,126,126,126,125,125,124,124,123,123,122,122,121,121,120,120,119,119,118,117,117,116,116,115,114,114,113,112,112,111,110,109,108,108,107,106,105,104,102,101,99,98,95,90],
                VELOCITY_LUT_SCALE: 128.0,
                SIN_LUT_INT: [0,572,1144,1715,2286,2856,3425,3993,4560,5126,5690,6252,6813,7371,7927,8481,9032,9580,10126,10668,11207,11743,12275,12803,13328,13848,14364,14876,15383,15886,16384,16877,17364,17846,18323,18795,19260,19720,20174,20621,21063,21497,21926,22347,22762,23170,23571,23965,24351,24730,25101,25465,25821,26169,26509,26842,27165,27481,27788,28087,28377,28659,28932,29196,29451,29697,29935,30163,30381,30591,30791,30982,31164,31336,31498,31651,31794,31928,32051,32165,32270,32364,32449,32523,32588,32643,32688,32723,32748,32763,32768,32763,32748,32723,32688,32643,32588,32523,32449,32364,32270,32165,32051,31928,31794,31651,31498,31336,31164,30982,30791,30591,30381,30163,29935,29697,29451,29196,28932,28659,28377,28087,27788,27481,27165,26842,26509,26169,25821,25465,25101,24730,24351,23965,23571,23170,22762,22347,21926,21497,21063,20621,20174,19720,19260,18795,18323,17846,17364,16877,16384,15886,15383,14876,14364,13848,13328,12803,12275,11743,11207,10668,10126,9580,9032,8481,7927,7371,6813,6252,5690,5126,4560,3993,3425,2856,2286,1715,1144,572,0,-572,-1144,-1715,-2286,-2856,-3425,-3993,-4560,-5126,-5690,-6252,-6813,-7371,-7927,-8481,-9032,-9580,-10126,-10668,-11207,-11743,-12275,-12803,-13328,-13848,-14364,-14876,-15383,-15886,-16384,-16877,-17364,-17846,-18323,-18795,-19260,-19720,-20174,-20621,-21063,-21497,-21926,-22347,-22762,-23170,-23571,-23965,-24351,-24730,-25101,-25465,-25821,-26169,-26509,-26842,-27165,-27481,-27788,-28087,-28377,-28659,-28932,-29196,-29451,-29697,-29935,-30163,-30381,-30591,-30791,-30982,-31164,-31336,-31498,-31651,-31794,-31928,-32051,-32165,-32270,-32364,-32449,-32523,-32588,-32643,-32688,-32723,-32748,-32763,-32767,-32763,-32748,-32723,-32688,-32643,-32588,-32523,-32449,-32364,-32270,-32165,-32051,-31928,-31794,-31651,-31498,-31336,-31164,-30982,-30791,-30591,-30381,-30163,-29935,-29697,-29451,-29196,-28932,-28659,-28377,-28087,-27788,-27481,-27165,-26842,-26509,-26169,-25821,-25465,-25101,-24730,-24351,-23965,-23571,-23170,-22762,-22347,-21926,-21497,-21063,-20621,-20174,-19720,-19260,-18795,-18323,-17846,-17364,-16877,-16384,-15886,-15383,-14876,-14364,-13848,-13328,-12803,-12275,-11743,-11207,-10668,-10126,-9580,-9032,-8481,-7927,-7371,-6813,-6252,-5690,-5126,-4560,-3993,-3425,-2856,-2286,-1715,-1144,-572],
                SIN_LUT_SCALE: 65535,
            },
            
            /**
             * Calculates the animation profile by linearly interpolating between values in the integer LUT.
             * This restores floating-point precision for a smooth animation curve.
             * @param {number} p - The progress of the animation (0.0 to 1.0).
             * @returns {number} The interpolated value from the LUT, maintaining precision.
             */
            animationProfile: (p) => {
                const lut = LogoEngine.PRECALCULATED.EASING_LUT_INT;
                const floatIndex = p * (lut.length - 1); 
                const index1 = floatIndex | 0; // Fast floor
                const fraction = floatIndex - index1;

                if (index1 >= lut.length - 1) {
                    return lut[lut.length - 1];
                }
                
                const value1 = lut[index1];
                const value2 = lut[index1 + 1];
                
                return value1 + (value2 - value1) * fraction;
            },
            
            // --- Core Methods: The Compiler & Renderer ---
            
            reloadWithNewArt: function(svgText) {
                this.state.currentSvgText = svgText;
                this._resetAnimationState();

                const parser = new DOMParser();
                const svgDoc = parser.parseFromString(svgText, "image/svg+xml");
                const svgElement = svgDoc.querySelector('svg');
                if (!svgElement || svgDoc.querySelector('parsererror')) {
                    return;
                }

                this._extractSVGMetadata(svgElement);
                const { animatablePaths, compoundPathMeta } = this._extractAndConvertPathsFromSVG(svgElement);
                const { finalPalette, mappedStrokes, maxStroke } = this._buildPaletteAndMapPaths(animatablePaths);
                this.state.colorPalette = finalPalette;
                this.state.maxGeometricStrokeWidth = maxStroke;
                
                let draftLut = this._generateLookupTable(mappedStrokes);
                this.state.lookupTable = this._resolveCompoundPaths(draftLut, compoundPathMeta);
                
                this.startAnimation();
            },

            startAnimation: function() {
                if (!this.state.canvas || !this.state.ctx) return;
                this._resetAnimationState();
                
                const container = document.getElementById('logo-container');
                if (!container) return;

                const containerRect = container.getBoundingClientRect();
                if (containerRect.width === 0 || containerRect.height === 0) {
                    requestAnimationFrame(() => this.startAnimation());
                    return;
                }
                this._setupCanvas(containerRect);
                this._renderLoop();
            },
            
            // --- Rendering and Animation ---

            _setupCanvas: function(containerRect) {
                const { canvas, viewBox } = this.state;
                const dpr = window.devicePixelRatio || 1;
                
                const padding = (this.state.maxGeometricStrokeWidth * 0.5) + this.config.maxStrokeWidth;
                const effectiveViewBox = {
                    width: viewBox.width + padding * 2,
                    height: viewBox.height + padding * 2
                };

                const scale = (effectiveViewBox.width > 0 && effectiveViewBox.height > 0)
                    ? (containerRect.width / effectiveViewBox.width < containerRect.height / effectiveViewBox.height ? containerRect.width / effectiveViewBox.width : containerRect.height / effectiveViewBox.height)
                    : 1;

                const canvasWidth = effectiveViewBox.width * scale;
                const canvasHeight = effectiveViewBox.height * scale;

                canvas.width = canvasWidth * dpr;
                canvas.height = canvasHeight * dpr;
                canvas.style.width = `${canvasWidth}px`;
                canvas.style.height = `${canvasHeight}px`;
            },
            
            _renderLoop: function() {
                const { ctx, lookupTable, colorPalette, viewBox } = this.state;
                const { INV_ANIMATION_DURATION_MS } = this.PRECALCULATED;
                if (!ctx || !lookupTable) return;

                const totalPoints = lookupTable.reduce((sum, stroke) => sum + (stroke.length > 0 ? stroke.length - 1 : 0), 0);
                if (totalPoints === 0) return;

                let startTime = null;
                let currentPos = {x: 0, y: 0};

                const animationFrame = (timestamp) => {
                    if (!startTime) startTime = timestamp;
                    const elapsedTime = timestamp - startTime;
                    const drawingProgress = (elapsedTime * INV_ANIMATION_DURATION_MS < 1) ? elapsedTime * INV_ANIMATION_DURATION_MS : 1;
                    
                    const targetPointsToDraw = (drawingProgress * totalPoints) | 0;

                    if(targetPointsToDraw > this.state.drawnPointsCount) {
                        ctx.save();
                        const dpr = window.devicePixelRatio || 1;
                        const padding = (this.state.maxGeometricStrokeWidth * 0.5) + this.config.maxStrokeWidth;
                        const effectiveWidth = viewBox.width + padding * 2;
                        const effectiveHeight = viewBox.height + padding * 2;
                        
                        const scaleX = effectiveWidth > 0 ? (ctx.canvas.width / dpr) / effectiveWidth : 1;
                        const scaleY = effectiveHeight > 0 ? (ctx.canvas.height / dpr) / effectiveHeight : 1;
                        
                        const translateX = (-viewBox.x + padding) * scaleX * dpr;
                        const translateY = (-viewBox.y + padding) * scaleY * dpr;

                        ctx.setTransform(scaleX * dpr, 0, 0, scaleY * dpr, translateX, translateY);
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        
                        // OPTIMIZATION: Cache state variables before the hot loop.
                        let drawnPoints = this.state.drawnPointsCount;
                        let strokeIdx = this.state.currentStrokeIndex;
                        let pointIdx = this.state.currentPointInStrokeIndex;

                        while (drawnPoints < targetPointsToDraw) {
                            if (strokeIdx >= lookupTable.length) break;
                            const currentStroke = lookupTable[strokeIdx];
                            
                            if (pointIdx === 0) {
                                if (!currentStroke[0] || typeof currentStroke[0].x === 'undefined') {
                                    strokeIdx++;
                                    continue;
                                }
                                currentPos.x = currentStroke[0].x;
                                currentPos.y = currentStroke[0].y;
                                pointIdx = 1;
                            }

                            if (pointIdx >= currentStroke.length) {
                                pointIdx = 0;
                                strokeIdx++;
                                continue;
                            }

                            const prevPos = { ...currentPos };
                            const deltaPoint = currentStroke[pointIdx];
                            
                            currentPos.x += deltaPoint.dx;
                            currentPos.y += deltaPoint.dy;

                            const colorData = colorPalette[deltaPoint.colorIndex] || {r:0,g:0,b:0,a:1};
                            const colorStr = `rgba(${colorData.r},${colorData.g},${colorData.b},${colorData.a})`;
                            if (ctx.strokeStyle !== colorStr) ctx.strokeStyle = colorStr;
                            
                            ctx.beginPath();
                            ctx.lineWidth = deltaPoint.width;
                            ctx.moveTo(prevPos.x, prevPos.y);
                            ctx.lineTo(currentPos.x, currentPos.y);
                            ctx.stroke();

                            drawnPoints++;
                            pointIdx++;
                        }
                        
                        // OPTIMIZATION: Update state variables after the loop.
                        this.state.drawnPointsCount = drawnPoints;
                        this.state.currentStrokeIndex = strokeIdx;
                        this.state.currentPointInStrokeIndex = pointIdx;

                        ctx.restore();
                    }

                    if (elapsedTime < this.PRECALCULATED.ANIMATION_DURATION_MS + this.config.holdDurationMs) {
                         this.state.animationFrameId = requestAnimationFrame(animationFrame);
                    }
                };
                this.state.animationFrameId = requestAnimationFrame(animationFrame);
            },
            
            // --- LUT Generation & Color Quantization ---
            
            _buildPaletteAndMapPaths: function(animatablePaths) {
                if (!animatablePaths || animatablePaths.length === 0) {
                    return { finalPalette: [this._colorUtils.parseColor(this.config.fallbackStrokeColor, 1)], mappedStrokes: [], maxStroke: 0 };
                }
                const colorWeights = new Map();
                let maxStroke = 0;
                animatablePaths.forEach(p => {
                    const rgba = this._colorUtils.parseColor(p.color, p.opacity);
                    if (rgba.a > 0) {
                        const colorKey = `${rgba.r},${rgba.g},${rgba.b},${rgba.a}`;
                        const metrics = this._getPathMetrics(p.path);
                        const weight = p.type === 'fill' ? metrics.area : metrics.perimeter * p.strokeWidth;
                        if (colorWeights.has(colorKey)) {
                            colorWeights.get(colorKey).weight += weight;
                        } else {
                            colorWeights.set(colorKey, { color: rgba, weight });
                        }
                    }
                    if (p.strokeWidth > maxStroke) maxStroke = p.strokeWidth;
                });

                const weightedColors = Array.from(colorWeights.values());
                let finalPalette;
                if (weightedColors.length <= this.config.maxPaletteSize) {
                    finalPalette = weightedColors.map(item => item.color);
                } else {
                    finalPalette = this._quantizeWithWeightedKMeans(weightedColors, this.config.maxPaletteSize);
                }
                if (finalPalette.length === 0) finalPalette.push(this._colorUtils.parseColor(this.config.fallbackStrokeColor, 1));
                
                const mappedStrokes = animatablePaths.map(stroke => {
                    const strokeRgba = this._colorUtils.parseColor(stroke.color, stroke.opacity);
                    if (strokeRgba.a === 0) return null;
                    let bestMatchIndex = 0, minDistance = Infinity;
                    finalPalette.forEach((paletteRgba, index) => {
                        const distance = this._colorUtils.colorDistanceSq(strokeRgba, paletteRgba);
                        if (distance < minDistance) {
                            minDistance = distance;
                            bestMatchIndex = index;
                        }
                    });
                    return { ...stroke, colorIndex: bestMatchIndex };
                }).filter(Boolean);
                return { finalPalette, mappedStrokes, maxStroke };
            },

            _quantizeWithWeightedKMeans(weightedColors, k) {
                if (weightedColors.length <= k) return weightedColors.map(wc => wc.color);
                let centroids = [];
                let colorsCopy = [...weightedColors];
                
                const totalWeight = colorsCopy.reduce((sum, wc) => sum + wc.weight, 0);
                let rand = this._lcg() * totalWeight;
                let chosenIndex = colorsCopy.findIndex(wc => (rand -= wc.weight) <= 0);
                if (chosenIndex === -1) chosenIndex = colorsCopy.length - 1;
                centroids.push(colorsCopy.splice(chosenIndex, 1)[0].color);
                
                while (centroids.length < k && colorsCopy.length > 0) {
                    let distances = colorsCopy.map(wc => {
                        let minDistanceSq = Infinity;
                        for (let i = 0; i < centroids.length; i++) {
                            const distSq = this._colorUtils.colorDistanceSq(wc.color, centroids[i]);
                            if (distSq < minDistanceSq) {
                                minDistanceSq = distSq;
                            }
                        }
                        return minDistanceSq * wc.weight;
                    });
                    const distSum = distances.reduce((sum, d) => sum + d, 0);
                    rand = this._lcg() * distSum;
                    chosenIndex = distances.findIndex(d => (rand -= d) <= 0);
                    if (chosenIndex === -1) chosenIndex = colorsCopy.length - 1;
                    centroids.push(colorsCopy.splice(chosenIndex, 1)[0].color);
                }

                for (let iter = 0; iter < 20; iter++) {
                    const clusters = Array.from({ length: k }, () => []);
                    weightedColors.forEach(wc => {
                        let closestCentroidIndex = 0;
                        let minDistance = Infinity;
                        for (let i = 0; i < centroids.length; i++) {
                            const dist = this._colorUtils.colorDistanceSq(wc.color, centroids[i]);
                            if (dist < minDistance) {
                                minDistance = dist;
                                closestCentroidIndex = i;
                            }
                        }
                        clusters[closestCentroidIndex].push(wc);
                    });
                    
                    let hasChanged = false;
                    const newCentroids = clusters.map((cluster, i) => {
                        if (cluster.length === 0) return centroids[i];
                        const clusterWeight = cluster.reduce((sum, wc) => sum + wc.weight, 0);
                        if (clusterWeight === 0) return centroids[i];
                        
                        const totalColor = cluster.reduce((acc, wc) => ({
                            r: acc.r + wc.color.r * wc.weight, g: acc.g + wc.color.g * wc.weight,
                            b: acc.b + wc.color.b * wc.weight, a: acc.a + wc.color.a * wc.weight
                        }), {r:0, g:0, b:0, a:0});
                        
                        const invClusterWeight = 1.0 / clusterWeight;
                        const newCentroid = {
                            // Bitwise round: (n + 0.5) | 0
                            r: (totalColor.r * invClusterWeight + 0.5) | 0, 
                            g: (totalColor.g * invClusterWeight + 0.5) | 0,
                            b: (totalColor.b * invClusterWeight + 0.5) | 0, 
                            a: totalColor.a * invClusterWeight
                        };
                        
                        if (!centroids[i] || newCentroid.r !== centroids[i].r || newCentroid.g !== centroids[i].g || newCentroid.b !== centroids[i].b) {
                            hasChanged = true;
                        }
                        return newCentroid;
                    });
                    centroids = newCentroids;
                    if (!hasChanged) break;
                }
                return centroids;
            },

            _generateLookupTable: function(animatablePaths) {
                if (!animatablePaths || animatablePaths.length === 0) return [];
                const draftLut = [];
                const checkCtx = document.createElement('canvas').getContext('2d');
                
                animatablePaths.forEach((pathData) => {
                    const path = this.state.reusablePathForSampling;
                    path.setAttribute('d', pathData.path);
                    const length = path.getTotalLength();
                    if (length === 0) return;

                    let samplingStep = length * 0.002;
                    if (samplingStep > 1.0) samplingStep = 1.0;
                    if (samplingStep < 0.25) samplingStep = 0.25;

                    const clipPath2D = pathData.clipPathId ? this.state.clipPathCache.get(pathData.clipPathId) : null;
                    
                    let currentSegment = [], lastPoint = null;
                    for (let i = 0; i < length; i += samplingStep) {
                        const point = path.getPointAtLength(i);
                        let width;

                        // --- Check if the path is an original stroke to apply dynamic effects ---
                        if (pathData.isOriginalStroke) {
                            let curvatureFactor = 1.0;
                            let velocityFactor = 1.0;

                            // Curvature calculation
                            if (i > 0 && i < length - samplingStep) {
                                const p_prev = path.getPointAtLength(i - samplingStep);
                                const p_curr = point;
                                const p_next = path.getPointAtLength(i + samplingStep);

                                const v1_x = p_curr.x - p_prev.x;
                                const v1_y = p_curr.y - p_prev.y;
                                const v2_x = p_next.x - p_curr.x;
                                const v2_y = p_next.y - p_curr.y;

                                const dot = v1_x * v2_x + v1_y * v2_y;
                                const denominator = samplingStep * samplingStep;

                                if (denominator > 0.001) {
                                    let cosTheta = dot / denominator;
                                    if (cosTheta > 1.0) cosTheta = 1.0;
                                    if (cosTheta < -1.0) cosTheta = -1.0;

                                    const lut = this.PRECALCULATED.CURVATURE_LUT_INT;
                                    const floatIndex = (cosTheta + 1.0) * 0.5 * (lut.length - 1);
                                    const index1 = floatIndex | 0;
                                    const fraction = floatIndex - index1;

                                    let lutValue;
                                    if (index1 >= lut.length - 1) {
                                        lutValue = lut[lut.length - 1];
                                    } else {
                                        const v1 = lut[index1];
                                        const v2 = lut[index1 + 1];
                                        lutValue = v1 + (v2 - v1) * fraction;
                                    }
                                    curvatureFactor = lutValue / this.PRECALCULATED.CURVATURE_LUT_SCALE;
                                }
                            }

                            // Velocity calculation
                            if (lastPoint) {
                                const dx = point.x - lastPoint.x;
                                const dy = point.y - lastPoint.y;
                                const distance = Math.sqrt(dx*dx + dy*dy);
                                
                                const maxDistance = 5.0; // Must match the generator's maxDistance
                                let normalizedDistance = distance / maxDistance;
                                if (normalizedDistance > 1.0) normalizedDistance = 1.0;

                                const lut = this.PRECALCULATED.VELOCITY_LUT_INT;
                                const floatIndex = normalizedDistance * (lut.length - 1);
                                const index1 = floatIndex | 0;
                                const fraction = floatIndex - index1;

                                let lutValue;
                                if (index1 >= lut.length - 1) {
                                    lutValue = lut[lut.length - 1];
                                } else {
                                    const v1 = lut[index1];
                                    const v2 = lut[index1 + 1];
                                    lutValue = v1 + (v2 - v1) * fraction;
                                }
                                velocityFactor = lutValue / this.PRECALCULATED.VELOCITY_LUT_SCALE;
                            }

                            const progress = i / length;
                            const swellFactor = this.animationProfile(progress) / this.PRECALCULATED.EASING_LUT_SCALE;
                            let animatedBaseWidth = pathData.strokeWidth;
                            if (animatedBaseWidth < 1.0) animatedBaseWidth = 1.0;
                            const baseWidth = animatedBaseWidth + swellFactor * (this.config.maxStrokeWidth - animatedBaseWidth);
                            
                            width = this.config.minCurveWidth + (baseWidth - this.config.minCurveWidth) * curvatureFactor;
                            width *= velocityFactor;

                        } else {
                            // --- Logic for Fills and generated strokes (replicates original code) ---
                            const progress = i / length;
                            const swellFactor = this.animationProfile(progress) / this.PRECALCULATED.EASING_LUT_SCALE;
                            
                            if (pathData.type === 'fill') {
                                const animatedBaseWidth = 2.0;
                                const dynamicWidth = swellFactor * (this.config.maxStrokeWidth - animatedBaseWidth);
                                width = animatedBaseWidth + dynamicWidth;
                            } else { // This handles strokes generated from fills
                                width = this.config.maxStrokeWidth;
                            }
                        }


                        if (!clipPath2D || checkCtx.isPointInPath(clipPath2D, point.x, point.y)) {
                             // Clamp the final width to prevent extreme values
                            if (width < 0.5) width = 0.5;
                            if (width > this.config.maxStrokeWidth * 1.5) width = this.config.maxStrokeWidth * 1.5;
                            
                            const pointData = { width, colorIndex: pathData.colorIndex, type: pathData.type, compoundId: pathData.compoundId };
                            
                            if (!lastPoint) {
                                currentSegment.push({ x: point.x, y: point.y, ...pointData });
                            } else {
                                currentSegment.push({ dx: point.x - lastPoint.x, dy: point.y - lastPoint.y, ...pointData });
                            }
                            lastPoint = point;
                        } else {
                            if (currentSegment.length > 1) draftLut.push(currentSegment);
                            currentSegment = [];
                            lastPoint = null;
                        }
                    }
                    if (currentSegment.length > 1) draftLut.push(currentSegment);
                });
                return draftLut;
            },

            _resolveCompoundPaths: function(draftLut, compoundPathMeta) {
                if (compoundPathMeta.size === 0) return draftLut;
                const cleanedLut = [];
                const checkCtx = document.createElement('canvas').getContext('2d');
                const holeGeometries = new Map();
                for (const [id, meta] of compoundPathMeta.entries()) {
                    holeGeometries.set(id, new Path2D(meta.erasePathData));
                }

                draftLut.forEach(segment => {
                    const firstPoint = segment[0];
                    if (firstPoint.type !== 'fill' || !holeGeometries.has(firstPoint.compoundId)) {
                        cleanedLut.push(segment);
                        return;
                    }

                    const hole = holeGeometries.get(firstPoint.compoundId);
                    const absolutePoints = this._convertDeltaToAbsolute(segment);
                    let currentCleanSegment = [];
                    absolutePoints.forEach(absPoint => {
                        if (!checkCtx.isPointInPath(hole, absPoint.absX, absPoint.absY, 'evenodd')) {
                            currentCleanSegment.push(absPoint);
                        } else {
                            if (currentCleanSegment.length > 1) cleanedLut.push(this._convertAbsoluteToDelta(currentCleanSegment));
                            currentCleanSegment = [];
                        }
                    });
                    if (currentCleanSegment.length > 1) cleanedLut.push(this._convertAbsoluteToDelta(currentCleanSegment));
                });
                return cleanedLut;
            },
            
            // --- SVG Parsing and Traversal ---

            _extractAndConvertPathsFromSVG: function(svgNode) {
                const allFoundPaths = [], compoundPathMeta = new Map();
                let compoundPathCounter = 0;
                
                const traverse = (node, inheritedProps) => {
                    if (node.nodeType !== 1 || ['defs', 'mask', 'style', 'title', 'metadata', 'clippath'].includes(node.tagName.toLowerCase())) return;
                    
                    const props = this._getInheritedProps(node, inheritedProps);
                    
                    if (node.tagName.toLowerCase() === 'use') {
                        const href = node.getAttribute('href') || node.getAttribute('xlink:href');
                        if (href?.startsWith('#')) {
                            const referencedNode = svgNode.getRootNode().getElementById(href.substring(1));
                            if (referencedNode) {
                                const useX = +node.getAttribute('x') || 0;
                                const useY = +node.getAttribute('y') || 0;
                                const finalProps = { ...props };
                                if (useX !== 0 || useY !== 0) {
                                    finalProps.transform = this._matrixHelper.multiply(props.transform, this._matrixHelper.translate(useX, useY));
                                }
                                traverse(referencedNode, finalProps);
                            }
                        }
                        return;
                    }
                    this._processPathNode(node, props, allFoundPaths, compoundPathMeta, ++compoundPathCounter);
                    node.childNodes.forEach(child => traverse(child, props));
                };

                const initialProps = {
                    transform: this._matrixHelper.identity(), fill: 'black', 'fill-opacity': 1,
                    stroke: 'none', 'stroke-opacity': 1, 'stroke-width': 1,
                    clipPath: null, fillRule: 'nonzero', color: '#000'
                };
                traverse(svgNode, initialProps);

                const animatablePaths = [];
                const hasStrokesInCollection = allFoundPaths.some(p => p.isOriginalStroke);
                const hasFillsInCollection = allFoundPaths.some(p => p.type === 'fill');

                animatablePaths.push(...allFoundPaths.filter(p => p.type === 'fill'));

                if (hasStrokesInCollection) {
                    animatablePaths.push(...allFoundPaths.filter(p => p.type === 'stroke'));
                } else if (hasFillsInCollection) {
                    const strokesFromFills = allFoundPaths
                        .filter(p => p.type === 'fill')
                        .map(p => ({ 
                            ...p, 
                            type: 'stroke', 
                            strokeWidth: 2, 
                            color: p.color, 
                            opacity: p.opacity,
                            isOriginalStroke: false // Explicitly mark these as not original
                        }));
                    animatablePaths.push(...strokesFromFills);
                }

                return { animatablePaths, compoundPathMeta };
            },

            _processPathNode: function(node, props, allFoundPaths, compoundPathMeta, compoundId) {
                let pathData = this._getPathDataFromNode(node);
                if (!pathData) return;

                const isSolid = (c) => c && c !== 'none' && !c.includes('url(');
                const hasVisibleFill = isSolid(props.fill) && props['fill-opacity'] > 0;
                const hasVisibleStroke = isSolid(props.stroke) && props['stroke-width'] > 0 && props['stroke-opacity'] > 0;

                const subPaths = pathData.trim().split(/(?=M|m)/g).filter(s => s.trim());
                const isCompound = props.fillRule === 'evenodd' && subPaths.length > 1;

                if (hasVisibleFill) {
                    const processFill = (pData, cId) => {
                        const transformedPath = this._applyTransformBySampling(pData, props.transform);
                        allFoundPaths.push({
                            path: transformedPath, clipPathId: props.clipPath, compoundId: cId,
                            type: 'fill', strokeWidth: this.config.maxStrokeWidth,
                            color: props.fill, opacity: props['fill-opacity'],
                            isOriginalStroke: false // Fills are not original strokes
                        });
                    };
                    if (isCompound) {
                        processFill(subPaths[0], compoundId);
                        const holePathsData = subPaths.slice(1).join(' ');
                        const transformedHolePath = this._applyTransformBySampling(holePathsData, props.transform);
                        compoundPathMeta.set(compoundId, { erasePathData: transformedHolePath });
                    } else {
                        subPaths.forEach(subPathData => processFill(subPathData, null));
                    }
                }

                if (hasVisibleStroke) {
                    subPaths.forEach(subPathData => {
                        const transformedPath = this._applyTransformBySampling(subPathData, props.transform);
                        allFoundPaths.push({
                            path: transformedPath, clipPathId: props.clipPath, compoundId: null,
                            type: 'stroke', strokeWidth: props['stroke-width'],
                            color: props.stroke, opacity: props['stroke-opacity'],
                            isOriginalStroke: true // Mark this as an original stroke
                        });
                    });
                }
            },

            _getInheritedProps: function(node, inheritedProps) {
                const props = { ...inheritedProps };
                const styleProps = {};

                const styleAttr = node.getAttribute('style');
                const classAttr = node.getAttribute('class');
                if (classAttr) {
                    classAttr.split(' ').forEach(cls => {
                        const rule = this.state.cssRules.get(`.${cls}`);
                        if (rule) Object.assign(styleProps, rule);
                    });
                }
                if (node.id && this.state.cssRules.has(`#${node.id}`)) {
                    Object.assign(styleProps, this.state.cssRules.get(`#${node.id}`));
                }
                if (styleAttr) Object.assign(styleProps, this._parseStyleAttribute(styleAttr));
                
                Object.assign(props, styleProps);

                const directAttrs = {
                    fill: node.getAttribute('fill'), 'fill-opacity': node.getAttribute('fill-opacity'),
                    'fill-rule': node.getAttribute('fill-rule'), stroke: node.getAttribute('stroke'),
                    'stroke-width': node.getAttribute('stroke-width'), 'stroke-opacity': node.getAttribute('stroke-opacity'),
                    'clip-path': node.getAttribute('clip-path'), color: node.getAttribute('color')
                };
                for (const [key, value] of Object.entries(directAttrs)) {
                    if (value !== null) props[key] = value;
                }

                if (props.fill === 'currentColor') props.fill = props.color;
                if (props.stroke === 'currentColor') props.stroke = props.color;

                let localTransform = this._matrixHelper.identity();
                if (styleProps.transform) localTransform = this._parseTransform(styleProps.transform);
                const attrTransform = node.getAttribute('transform');
                if (attrTransform) localTransform = this._matrixHelper.multiply(localTransform, this._parseTransform(attrTransform));
                props.transform = this._matrixHelper.multiply(inheritedProps.transform, localTransform);
                
                props['stroke-width'] = +props['stroke-width'];
                props['stroke-opacity'] = +props['stroke-opacity'];
                props['fill-opacity'] = +props['fill-opacity'];
                if (props['clip-path']) props.clipPath = props['clip-path'].replace(/url\(#|\)/g, '');
                return props;
            },
            
            _getPathDataFromNode: function(node) {
                const tagName = node.tagName.toLowerCase();
                switch(tagName) {
                    case 'path': return node.getAttribute('d');
                    case 'rect': {
                        const w = +node.getAttribute('width') || 0, h = +node.getAttribute('height') || 0;
                        if (w <= 0 || h <= 0) return '';
                        const x = +node.getAttribute('x') || 0, y = +node.getAttribute('y') || 0;
                        let rx = +node.getAttribute('rx') || 0;
                        let ry = +node.getAttribute('ry') || rx;
                        rx = rx < w * 0.5 ? rx : w * 0.5;
                        ry = ry < h * 0.5 ? ry : h * 0.5;
                        if (rx > 0 || ry > 0) {
                            return `M${x + rx},${y} h${w - 2 * rx} a${rx},${ry} 0 0 1 ${rx},${ry} v${h - 2 * ry} a${rx},${ry} 0 0 1 ${-rx},${ry} h${-(w - 2 * rx)} a${rx},${ry} 0 0 1 ${-rx},${-ry} v${-(h - 2 * ry)} a${rx},${ry} 0 0 1 ${rx},${-ry} Z`;
                        }
                        return `M${x},${y} h${w} v${h} h${-w} Z`;
                    }
                    case 'circle': {
                        const r = +node.getAttribute('r') || 0;
                        if (r <= 0) return '';
                        const cx = +node.getAttribute('cx') || 0, cy = +node.getAttribute('cy') || 0;
                        const r2 = r * 2;
                        return `M ${cx - r},${cy} a ${r},${r} 0 1,0 ${r2},0 a ${r},${r} 0 1,0 -${r2},0`;
                    }
                    case 'ellipse': {
                        const rx = +node.getAttribute('rx') || 0, ry = +node.getAttribute('ry') || 0;
                        if (rx <= 0 || ry <= 0) return '';
                        const cx = +node.getAttribute('cx') || 0, cy = +node.getAttribute('cy') || 0;
                        const rx2 = rx * 2;
                        return `M ${cx - rx},${cy} a ${rx},${ry} 0 1,0 ${rx2},0 a ${rx},${ry} 0 1,0 -${rx2},0`;
                    }
                    case 'line': {
                        const x1 = +node.getAttribute('x1') || 0, y1 = +node.getAttribute('y1') || 0, x2 = +node.getAttribute('x2') || 0, y2 = +node.getAttribute('y2') || 0;
                        return `M ${x1} ${y1} L ${x2} ${y2}`;
                    }
                    case 'polyline': case 'polygon': {
                        const points = (node.getAttribute('points')||'').trim().split(/[\s,]+/).map(p => +p || 0);
                        if (points.length < 2) return '';
                        let d = `M ${points[0]} ${points[1]}`;
                        for(let i=2; i<points.length; i+=2) d += ` L ${points[i]} ${points[i+1]}`;
                        if (tagName === 'polygon') d += ' Z';
                        return d;
                    }
                    default: return '';
                }
            },

            _extractSVGMetadata: function(svgElement) {
                const viewBoxAttr = svgElement.getAttribute('viewBox');
                if (viewBoxAttr) {
                    const vb = viewBoxAttr.split(/[\s,]+/).map(Number);
                    if (vb.length === 4 && !vb.some(isNaN)) this.state.viewBox = { x: vb[0], y: vb[1], width: vb[2], height: vb[3] };
                } else {
                    const w = +svgElement.getAttribute('width'), h = +svgElement.getAttribute('height');
                    this.state.viewBox = { x: 0, y: 0, width: (isNaN(w) ? 400 : w), height: (isNaN(h) ? 225 : h) };
                }
                this.state.cssRules = this._parseStyleSheets(svgElement);
                this.state.clipPathCache.clear();
                this._compileClipPaths(svgElement);
            },

            _compileClipPaths: function(svgNode) {
                svgNode.querySelectorAll('clipPath').forEach(clipNode => {
                    const clipId = clipNode.getAttribute('id');
                    if (!clipId) return;
                    const combinedPath2D = new Path2D();
                    const traverseClipPath = (node, inheritedTransform) => {
                        if (node.nodeType !== 1) return;
                        let currentTransform = inheritedTransform;
                        const transformAttr = node.getAttribute('transform');
                        if (transformAttr) currentTransform = this._matrixHelper.multiply(inheritedTransform, this._parseTransform(transformAttr));
                        
                        if (node.tagName.toLowerCase() === 'use') {
                            const href = node.getAttribute('href') || node.getAttribute('xlink:href');
                            if (href?.startsWith('#')) {
                                const ref = svgNode.getRootNode().getElementById(href.substring(1));
                                if (ref) {
                                    const useX = +node.getAttribute('x')||0, useY = +node.getAttribute('y')||0;
                                    let finalTransform = currentTransform;
                                    if (useX !== 0 || useY !== 0) finalTransform = this._matrixHelper.multiply(currentTransform, this._translate(useX, useY));
                                    traverseClipPath(ref, finalTransform);
                                }
                            }
                        } else {
                            const pathData = this._getPathDataFromNode(node);
                            if (pathData) {
                                const transformedPath = this._applyTransformBySampling(pathData, currentTransform);
                                combinedPath2D.addPath(new Path2D(transformedPath));
                            }
                        }
                        node.childNodes.forEach(child => traverseClipPath(child, currentTransform));
                    };
                    traverseClipPath(clipNode, this._matrixHelper.identity());
                    this.state.clipPathCache.set(clipId, combinedPath2D);
                });
            },
            
            // --- Utility Functions ---

            _resetAnimationState: function() {
                cancelAnimationFrame(this.state.animationFrameId);
                this.state.drawnPointsCount = 0;
                this.state.currentStrokeIndex = 0;
                this.state.currentPointInStrokeIndex = 0;
                if (this.state.ctx && this.state.canvas) {
                    this.state.ctx.reset();
                }
            },

            _parseStyleAttribute: function(s) {
                return s.split(';').reduce((styles, p) => {
                    const parts = p.split(':');
                    if (parts.length === 2) styles[parts[0].trim()] = parts[1].trim();
                    return styles;
                }, {});
            },

            _parseStyleSheets: function(svgNode) {
                const rules = new Map();
                svgNode.querySelectorAll('style').forEach(style => {
                    const ruleRegex = /([^{]+)\s*\{([^}]+)\}/g;
                    let match;
                    while ((match = ruleRegex.exec(style.textContent)) !== null) {
                        const selector = match[1].trim();
                        const properties = this._parseStyleAttribute(match[2].trim());
                        rules.set(selector, properties);
                    }
                });
                return rules;
            },

            // A simple Linear Congruential Generator for pseudo-random numbers.
            _lcg: function() {
                this.state._lcg_seed = (this.state._lcg_seed * 1664525 + 1013904223) | 0;
                return (this.state._lcg_seed >>> 0) * (1.0 / 4294967296.0);
            },
            
            _matrixHelper: {
                identity: () => [1, 0, 0, 1, 0, 0],
                isIdentity: (m) => m.every((val, i) => val === (i === 0 || i === 3 ? 1 : 0)),
                multiply: (m1, m2) => [
                    m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1],
                    m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3],
                    m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]
                ],
                transformPoint: (x, y, m) => ({ x: m[0] * x + m[2] * y + m[4], y: m[1] * x + m[3] * y + m[5] }),
                translate: (tx, ty) => [1, 0, 0, 1, tx, ty],
                scale: (sx, sy) => [sx, 0, 0, sy, 0, 0],
                
                // rotate function uses the integer SIN_LUT with fractional interpolation.
                rotate: function(angle, cx = 0, cy = 0) {
                    const lut = LogoEngine.PRECALCULATED.SIN_LUT_INT;
                    const inv_scale = 1.0 / ((LogoEngine.PRECALCULATED.SIN_LUT_SCALE -1) * 0.5);

                    const getTrigValue = (angleInDegrees) => {
                        const floatIndex = (angleInDegrees % 360 + 360) % 360;
                        const index1 = floatIndex | 0;
                        const fraction = floatIndex - index1;
                        
                        const value1 = lut[index1];
                        const value2 = lut[(index1 + 1) % 360];
                        
                        return (value1 + (value2 - value1) * fraction) * inv_scale;
                    };
                    
                    const sin = getTrigValue(angle);
                    const cos = getTrigValue(angle + 90);

                    const m = [cos, sin, -sin, cos, 0, 0];
                    if (cx !== 0 || cy !== 0) {
                        const m1 = this.translate(cx, cy);
                        const m2 = this.translate(-cx, -cy);
                        return this.multiply(m1, this.multiply(m, m2));
                    }
                    return m;
                }
            },

            _parseTransform: function(transformString) {
                let matrix = this._matrixHelper.identity();
                if (!transformString) return matrix;
                const regex = /(\w+)\s*\(([^)]+)\)/g;
                let match;
                while ((match = regex.exec(transformString)) !== null) {
                    const [_, type, valueStr] = match;
                    const values = valueStr.trim().split(/[\s,]+/).map(v => +v.trim());
                    if (values.some(isNaN)) continue;
                    let transformMatrix;
                    switch (type) {
                        case 'translate': transformMatrix = this._matrixHelper.translate(values[0], values[1] || 0); break;
                        case 'scale': transformMatrix = this._matrixHelper.scale(values[0], values[1] ?? values[0]); break;
                        case 'rotate': transformMatrix = this._matrixHelper.rotate(values[0], values[1] || 0, values[2] || 0); break;
                        case 'matrix': transformMatrix = values.length === 6 ? values : this._matrixHelper.identity(); break;
                        default: transformMatrix = this._matrixHelper.identity();
                    }
                    matrix = this._matrixHelper.multiply(matrix, transformMatrix);
                }
                return matrix;
            },
            
            _applyTransformBySampling: function(pathData, matrix) {
                if (!matrix || this._matrixHelper.isIdentity(matrix)) return pathData;
                const path = this.state.reusablePathForSampling;
                path.setAttribute('d', pathData);
                const len = path.getTotalLength();
                if (len === 0) return '';
                
                const _f2 = (n) => ((n * 100 + 0.5) | 0) * 0.01;

                const p0 = path.getPointAtLength(0);
                const transformedP0 = this._matrixHelper.transformPoint(p0.x, p0.y, matrix);
                let newPath = `M${_f2(transformedP0.x)} ${_f2(transformedP0.y)}`;
                
                const step = (0.5 > len * 0.005) ? 0.5 : len * 0.005;
                for (let i = step; i <= len; i += step) {
                    const p = path.getPointAtLength(i);
                    const transformedP = this._matrixHelper.transformPoint(p.x, p.y, matrix);
                    newPath += ` L${_f2(transformedP.x)} ${_f2(transformedP.y)}`;
                }
                if (pathData.trim().toUpperCase().endsWith('Z')) newPath += ' Z';
                return newPath;
            },
            
            _colorUtils: {
                _colorCanvasCtx: null,
                _initColorCanvas() {
                    if (!this._colorCanvasCtx) {
                        const canvas = document.createElement('canvas');
                        canvas.width = 1; canvas.height = 1;
                        this._colorCanvasCtx = canvas.getContext('2d', { willReadFrequently: true });
                    }
                    return this._colorCanvasCtx;
                },
                parseColor(colorStr, opacity = 1) {
                    if (!colorStr || typeof colorStr !== 'string' || colorStr.toLowerCase() === 'none') {
                        return { r: 0, g: 0, b: 0, a: 0 };
                    }
                    const ctx = this._initColorCanvas();
                    ctx.clearRect(0, 0, 1, 1);
                    ctx.fillStyle = colorStr;
                    ctx.fillRect(0, 0, 1, 1);
                    const [r, g, b, a_255] = ctx.getImageData(0, 0, 1, 1).data;
                    return { r, g, b, a: (a_255 * (1.0/255.0)) * opacity };
                },
                colorDistanceSq(c1, c2) {
                    const dr = c1.r - c2.r, dg = c1.g - c2.g, db = c1.b - c2.b, da = (c1.a - c2.a) * 255;
                    return dr*dr + dg*dg + db*db + da*da;
                }
            },

            _getPathMetrics: function(pathData) {
                const path = this.state.reusablePathForSampling;
                path.setAttribute('d', pathData);
                const perimeter = path.getTotalLength();
                if (perimeter < 1) return { perimeter: 0, area: 0 };
                
                const points = [];
                const sampleCount = 100;
                const invSampleCount = 1.0 / sampleCount;
                for (let i = 0; i < sampleCount; i++) {
                    points.push(path.getPointAtLength(i * invSampleCount * perimeter));
                }
                if (points.length === 0) return { perimeter, area: 0 };
                points.push(points[0]);
                
                let area = 0;
                for (let i = 0; i < points.length - 1; i++) {
                    area += points[i].x * points[i+1].y - points[i+1].x * points[i].y;
                }
                const absArea = (area ^ (area >> 31)) - (area >> 31);
                return { perimeter, area: absArea * 0.5 };
            },

            _convertAbsoluteToDelta: function(abs) {
                if (abs.length < 2) return [];
                const first = abs[0];
                const delta = [{ x: first.absX, y: first.absY, ...first }];
                delete delta[0].absX; delete delta[0].absY;
                for (let i = 1; i < abs.length; i++) {
                    const curr = abs[i], prev = abs[i-1];
                    const p = { dx: curr.absX - prev.absX, dy: curr.absY - prev.absY, ...curr };
                    delete p.absX; delete p.absY;
                    delta.push(p);
                }
                return delta;
            },

            _convertDeltaToAbsolute: function(delta) {
                const abs = [];
                let curr = { x: 0, y: 0 };
                delta.forEach((p, i) => {
                    if (i === 0) curr = { x: p.x, y: p.y };
                    else { curr.x += p.dx; curr.y += p.dy; }
                    abs.push({ ...p, absX: curr.x, absY: curr.y });
                });
                return abs;
            },

            // --- Initialization and Event Handlers ---
            init: function() {
                this.state.canvas = document.getElementById(this.config.canvasId);
                if (!this.state.canvas) return;
                this.state.ctx = this.state.canvas.getContext('2d', { willReadFrequently: true });
                
                this.state.reusablePathForSampling = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                
                const uploader = document.getElementById('svg-uploader');
                
                window.addEventListener('keydown', (e) => {
                    if (e.key.toLowerCase() === 'b') {
                        uploader.click();
                    }
                });

                uploader.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = (event) => this.reloadWithNewArt(event.target.result);
                    reader.readAsText(file);
                    e.target.value = ''; // Reset for re-uploading the same file.
                });

                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => this.reloadWithNewArt(this.state.currentSvgText), 150);
                });

                // Kick off the process with the default SVG.
                requestAnimationFrame(() => { this.reloadWithNewArt(this.config.defaultSvgMarkup); });
            }
        };

        document.addEventListener('DOMContentLoaded', () => LogoEngine.init());
    </script>
</body>
</html>
