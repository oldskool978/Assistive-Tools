<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ImageDiff 100-DPS | Tensor Lab</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="importmap">
        { "imports": { "react": "https://esm.sh/react@18.2.0", "react-dom/client": "https://esm.sh/react-dom@18.2.0/client", "lucide-react": "https://esm.sh/lucide-react@0.263.1" } }
    </script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020617; font-family: 'Inter', system-ui, sans-serif; }
        ::-webkit-scrollbar { display: none; }
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
        canvas { image-rendering: pixelated; } 
        .hud-enter { animation: hud-in 0.2s ease-out forwards; }
        @keyframes hud-in { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .range-slider { -webkit-appearance: none; appearance: none; background: transparent; cursor: pointer; }
        .range-slider::-webkit-slider-runnable-track { background: #1e293b; height: 4px; border-radius: 2px; }
        .range-slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; margin-top: -6px; background-color: #38bdf8; height: 16px; width: 4px; border-radius: 2px; transition: background-color 0.2s; }
        .range-fine::-webkit-slider-runnable-track { background: #1e293b; height: 2px; }
        .range-fine::-webkit-slider-thumb { background-color: #94a3b8; height: 12px; width: 2px; margin-top: -5px; }
        .cursor-crosshair { cursor: crosshair; }
        .scrubbing { cursor: none; background-color: rgba(56, 189, 248, 0.1); border-color: rgba(56, 189, 248, 0.5); }
        .glass-panel { background: rgba(15, 23, 42, 0.95); backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px); }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';
        import { createRoot } from 'react-dom/client';
        import { Activity, Layers, Eye, EyeOff, Target, ShieldCheck, Loader, ScanLine, Microscope, Waves, Binary, BrainCircuit, Upload, MoveHorizontal, Zap, Sun, Compass, FileText, X, ClipboardCheck, Move, ChevronUp, ChevronDown, ChevronLeft, ChevronRight, RotateCcw, Image as ImageIcon, MousePointer2 } from 'lucide-react';

        // --- 1. PRECISION CORE ---
        const PrecisionCore = (() => {
            // <INJECT_PHYSICS>
            const PHYSICS = null;
            // </INJECT_PHYSICS>
            // <INJECT_LUMA_COEFFS>
            const LUMA_COEFFS = null;
            // </INJECT_LUMA_COEFFS>
            // <INJECT_KAISER_13>
            const KAISER_13 = null;
            // </INJECT_KAISER_13>
            // <INJECT_FARID_P>
            const FARID_P = null;
            // </INJECT_FARID_P>
            // <INJECT_FARID_D>
            const FARID_D = null;
            // </INJECT_FARID_D>
            // <INJECT_ENTROPY_LUT>
            const ENTROPY_LUT = null;
            // </INJECT_ENTROPY_LUT>
            // <INJECT_LINEAR_LUT_HQ>
            const LINEAR_LUT_HQ = null;
            // </INJECT_LINEAR_LUT_HQ>
            // <INJECT_KURTOSIS_LUT>
            const KURTOSIS_LUT = null;
            // </INJECT_KURTOSIS_LUT>
            // <INJECT_SIGMA_LUT>
            const SIGMA_LUT = null;
            // </INJECT_SIGMA_LUT>
            // <INJECT_BAYER_LATTICE>
            const BAYER_LATTICE = null;
            // </INJECT_BAYER_LATTICE>
            // <INJECT_TURBO>
            const TURBO = null;
            // </INJECT_TURBO>
            // <INJECT_INFERNO>
            const INFERNO = null;
            // </INJECT_INFERNO>
            // <INJECT_M1>
            const M1 = null;
            // </INJECT_M1>
            // <INJECT_M2>
            const M2 = null;
            // </INJECT_M2>
            // <INJECT_HVS_MASK_LUT>
            const HVS_MASK_LUT = null;
            // </INJECT_HVS_MASK_LUT>

            const estimateRobustSigma = (buffer, width, height) => {
                if (!buffer) return 1e-9;
                const sampleW = width - 2;
                const sampleH = height - 2;
                const step = Math.max(1, Math.floor((sampleW * sampleH) / 10000)); 
                const samples = new Float32Array(10000);
                let sIdx = 0;
                for(let i=0; i<10000; i++) {
                    const offset = i * step;
                    const y = 1 + Math.floor(offset / sampleW);
                    const x = 1 + (offset % sampleW);
                    if (y >= height - 1) break;
                    const idx = Math.imul(y, width) + x;
                    const val = (buffer[idx] * 4.0) - (buffer[idx-1] + buffer[idx+1] + buffer[idx-width] + buffer[idx+width]);
                    samples[sIdx++] = Math.abs(val);
                }
                samples.sort();
                const median = samples[sIdx >> 1];
                const scale = PHYSICS ? PHYSICS[0] : 1.4826;
                return Math.max(1e-13, median * scale);
            };

            const isReady = () => (PHYSICS && KAISER_13 && KURTOSIS_LUT && SIGMA_LUT && BAYER_LATTICE && LUMA_COEFFS && HVS_MASK_LUT);

            return {
                M1, M2, KURTOSIS_LUT, SIGMA_LUT, ENTROPY_LUT, LINEAR_LUT_HQ, TURBO, INFERNO, BAYER_LATTICE, LUMA_COEFFS, HVS_MASK_LUT,
                KAISER_13, FARID_P, FARID_D, PHYSICS,
                estimateRobustSigma, isReady
            };
        })();

        // --- 2. MEMORY VANGUARD ---
        const MemoryVanguard = (() => {
            const registers = [];
            const request = (slot, size) => {
                if (!registers[slot] || registers[slot].length < size) registers[slot] = new Float64Array(Math.ceil(size / 4096) * 4096);
                return registers[slot].subarray(0, size);
            };
            return { request };
        })();

        // --- 3. INGEST ENGINE ---
        const IngestEngine = (() => {
            const process = (imageData, width, height) => {
                const { data } = imageData; const len = width * height; 
                // HIGH PRECISION UPGRADE: Use Float64 for Oklab pipeline
                const ok_l = new Float64Array(len), ok_a = new Float64Array(len), ok_b = new Float64Array(len);
                const { M1, M2, LINEAR_LUT_HQ, BAYER_LATTICE } = PrecisionCore;
                if (!M1 || !M2) return { oklab: {l:ok_l, a:ok_a, b:ok_b}, meta: {w:width, h:height, bitDepth:8} };

                const is16Bit = data instanceof Uint16Array;
                const bitDepth = is16Bit ? 16 : 8;
                const normScale = is16Bit ? 1.0/65535.0 : 1.0/255.0;

                const lutLen = LINEAR_LUT_HQ.length - 1; 
                for(let y=0; y<height; y++) {
                    const rowOffset = Math.imul(y, width); const bayerRow = (y & 7) << 3; 
                    for(let x=0; x<width; x++) {
                        const i = rowOffset + x; const idx = i << 2;
                        const dither = BAYER_LATTICE[bayerRow + (x & 7)] * normScale;
                        const lookup = (v) => {
                            const t = Math.max(0, Math.min(1, v)) * lutLen; const idx = t | 0;
                            return LINEAR_LUT_HQ[idx] + (LINEAR_LUT_HQ[Math.min(idx+1, lutLen)] - LINEAR_LUT_HQ[idx]) * (t - idx);
                        };
                        const r = lookup((data[idx] * normScale) + dither);
                        const g = lookup((data[idx+1] * normScale) + dither);
                        const b = lookup((data[idx+2] * normScale) + dither);
                        const l = M1[0]*r + M1[1]*g + M1[2]*b; const m = M1[3]*r + M1[4]*g + M1[5]*b; const s = M1[6]*r + M1[7]*g + M1[8]*b;
                        const l_ = Math.cbrt(Math.max(0, l)), m_ = Math.cbrt(Math.max(0, m)), s_ = Math.cbrt(Math.max(0, s));
                        ok_l[i] = M2[0]*l_ + M2[1]*m_ + M2[2]*s_; ok_a[i] = M2[3]*l_ + M2[4]*m_ + M2[5]*s_; ok_b[i] = M2[6]*l_ + M2[7]*m_ + M2[8]*s_;
                    }
                }
                return { oklab: { l: ok_l, a: ok_a, b: ok_b }, meta: { w: width, h: height, bitDepth } };
            };
            return { process };
        })();

        // --- 4. ANALYSIS ENGINE ---
        const AnalysisEngine = (() => {
            const convolveSeparable = (input, width, height, kH, kV) => {
                if (!kH || !kV) return new Float64Array(input.length);
                const len = width * height; const temp = MemoryVanguard.request(0, len); 
                // HIGH PRECISION UPGRADE: Output is Float64
                const out = new Float64Array(len);
                const kSzH = kH.length, kHalfH = (kSzH - 1) >> 1; const kSzV = kV.length, kHalfV = (kSzV - 1) >> 1;
                for(let y=0; y<height; y++) { const row = Math.imul(y, width); for(let x=0; x<width; x++) { let sum = 0.0; for(let k=0; k<kSzH; k++) { let px = x - kHalfH + k; if (px < 0) px = -px; else if (px >= width) px = width - 1 - (px - width); sum += input[row + px] * kH[k]; } temp[row + x] = sum; } }
                for(let y=0; y<height; y++) { const row = Math.imul(y, width); for(let x=0; x<width; x++) { let sum = 0.0; for(let k=0; k<kSzV; k++) { let py = y - kHalfV + k; if (py < 0) py = -py; else if (py >= height) py = height - 1 - (py - height); sum += temp[Math.imul(py, width) + x] * kV[k]; } out[row + x] = sum; } }
                return out;
            };

            const getStructureTensor = (oklab, w, h) => {
                const { FARID_P, FARID_D, KAISER_13 } = PrecisionCore; const len = w * h;
                const Ixx = MemoryVanguard.request(1, len).fill(0), Iyy = MemoryVanguard.request(2, len).fill(0), Ixy = MemoryVanguard.request(3, len).fill(0);
                ['l','a','b'].forEach(c => {
                    const Ix = convolveSeparable(oklab[c], w, h, FARID_D, FARID_P); const Iy = convolveSeparable(oklab[c], w, h, FARID_P, FARID_D);
                    for(let i=0; i<len; i++) { Ixx[i] += Ix[i] * Ix[i]; Iyy[i] += Iy[i] * Iy[i]; Ixy[i] += Ix[i] * Iy[i]; }
                });
                const Sxx = convolveSeparable(Ixx, w, h, KAISER_13, KAISER_13); const Syy = convolveSeparable(Iyy, w, h, KAISER_13, KAISER_13); const Sxy = convolveSeparable(Ixy, w, h, KAISER_13, KAISER_13);
                
                // HIGH PRECISION UPGRADE: Float64 for Eigenvalues
                const l1 = new Float64Array(len), l2 = new Float64Array(len), coh = new Float64Array(len);
                for(let i=0; i<len; i++) {
                    const tr = Sxx[i] + Syy[i]; const det = Sxx[i]*Syy[i] - Sxy[i]*Sxy[i]; const term = Math.sqrt(Math.max(0, (tr * 0.5)**2 - det));
                    l1[i] = Math.sqrt(Math.max(0, tr * 0.5 + term)); l2[i] = Math.sqrt(Math.max(0, tr * 0.5 - term));
                    const sum = l1[i] + l2[i]; coh[i] = (sum > 1e-12) ? ((l1[i] - l2[i]) / sum) ** 2 : 0;
                }
                return { l1, l2, coherence: coh };
            };

            const getEntropy = (buf, w, h) => {
                const map = new Float64Array(w*h); const LUT = PrecisionCore.ENTROPY_LUT; if(!LUT) return map;
                let min = Infinity, max = -Infinity; for(let i=0; i<buf.length; i+=10) { if(buf[i]<min) min=buf[i]; if(buf[i]>max) max=buf[i]; }
                const scale = 25.0 / (max - min || 1.0);
                for(let y=2; y<h-2; y++) {
                    const row = Math.imul(y, w);
                    for(let x=2; x<w-2; x++) {
                        const hist = new Uint8Array(26);
                        for(let ky=-2; ky<=2; ky++) { const rOff = Math.imul(y+ky, w); for(let kx=-2; kx<=2; kx++) { const val = buf[rOff + x + kx]; hist[Math.min(25, Math.max(0, ((val - min) * scale) | 0))]++; } }
                        let H = 0.0; for(let k=0; k<=25; k++) if(hist[k] > 0) H += LUT[hist[k]];
                        map[row+x] = H;
                    }
                }
                return map;
            };

            const getSSIM = (ok1, ok2, w, h) => {
                const { KAISER_13, PHYSICS } = PrecisionCore;
                const C1 = PHYSICS ? PHYSICS[1] : 0.0001, C2 = PHYSICS ? PHYSICS[2] : 0.0009;
                const len = w*h;
                // HIGH PRECISION UPGRADE: Float64
                const ssim = new Float64Array(len);
                ['l', 'a', 'b'].forEach(key => {
                    const buf1 = ok1[key]; const buf2 = ok2[key];
                    const mu1 = convolveSeparable(buf1, w, h, KAISER_13, KAISER_13);
                    const mu2 = convolveSeparable(buf2, w, h, KAISER_13, KAISER_13);
                    const t1 = MemoryVanguard.request(1, len); const t2 = MemoryVanguard.request(2, len); const t3 = MemoryVanguard.request(3, len);
                    for(let i=0; i<len; i++) { t1[i] = buf1[i] * buf1[i]; t2[i] = buf2[i] * buf2[i]; t3[i] = buf1[i] * buf2[i]; }
                    const sig1_sq_raw = convolveSeparable(t1, w, h, KAISER_13, KAISER_13);
                    const sig2_sq_raw = convolveSeparable(t2, w, h, KAISER_13, KAISER_13);
                    const sig12_raw = convolveSeparable(t3, w, h, KAISER_13, KAISER_13);
                    for(let i=0; i<len; i++) {
                        const m1 = mu1[i], m2 = mu2[i];
                        const sig1_sq = sig1_sq_raw[i] - m1*m1;
                        const sig2_sq = sig2_sq_raw[i] - m2*m2;
                        const sig12 = sig12_raw[i] - m1*m2;
                        const score = ((2*m1*m2 + C1) * (2*sig12 + C2)) / ((m1*m1 + m2*m2 + C1) * (sig1_sq + sig2_sq + C2));
                        ssim[i] += score;
                    }
                });
                const inv3 = 1.0/3.0;
                for(let i=0; i<len; i++) ssim[i] = Math.max(-1, Math.min(1, ssim[i] * inv3));
                return ssim;
            };

            const getPerceptualDelta = (o1, o2, w, h) => {
                const len = w*h; const d = new Float64Array(len);
                for(let i=0; i<len; i++) d[i] = Math.sqrt((o1.l[i]-o2.l[i])**2 + (o1.a[i]-o2.a[i])**2 + (o1.b[i]-o2.b[i])**2);
                return d;
            };
            return { getStructureTensor, getEntropy, getSSIM, getPerceptualDelta };
        })();

        // --- 5. FORENSIC FILTER ---
        const ForensicFilter = (() => {
            const tasks = {
                geodesic: (mask, width, height, stats, tuning) => {
                    // HIGH PRECISION UPGRADE: Float64 for erosion stability
                    const len = mask.length; const marker = new Float64Array(len);
                    const floor = stats ? Math.max(1e-6, stats.statFloor * tuning.geoScale) : 0.005;
                    for(let i=0; i<len; i++) marker[i] = Math.max(0, mask[i] - floor);
                    for(let k=0; k<5; k++) {
                        for(let i=0; i<len; i++) {
                            let m = marker[i];
                            if(i>=width) m = Math.max(m, marker[i-width]); if(i%width) m = Math.max(m, marker[i-1]);
                            marker[i] = Math.min(m, mask[i]);
                        }
                        for(let i=len-1; i>=0; i--) {
                            let m = marker[i];
                            if(i<len-width) m = Math.max(m, marker[i+width]); if((i+1)%width) m = Math.max(m, marker[i+1]);
                            marker[i] = Math.min(m, mask[i]);
                        }
                    }
                    return marker;
                },
                nlm: (input, width, height, stats, tuning) => {
                    const len = input.length; const output = new Float64Array(input); // EDGE PRESERVATION
                    const sigma = stats ? stats.robustSigma : 0.01; 
                    const h2 = (sigma * sigma) * tuning.nlmDecay;
                    for(let y=3; y<height-3; y++) {
                        const row = Math.imul(y, width);
                        for(let x=3; x<width-3; x++) {
                            const idx = row + x; let wSum = 0.0, vSum = 0.0;
                            for(let dy=-2; dy<=2; dy++) for(let dx=-2; dx<=2; dx++) {
                                let dist = 0.0; const sIdx = idx + Math.imul(dy, width) + dx;
                                for(let py=-1; py<=1; py++) for(let px=-1; px<=1; px++) {
                                    const d = input[idx + Math.imul(py, width) + px] - input[sIdx + Math.imul(py, width) + px]; dist += d*d;
                                }
                                const w = Math.exp(-Math.max(0, dist - 2*h2) / (h2 + 1e-9)); vSum += input[sIdx] * w; wSum += w;
                            }
                            output[idx] = vSum / (wSum + 1e-9);
                        }
                    }
                    return output;
                },
                tukey: (input, width, height, stats, tuning) => {
                    const len = input.length; const u = new Float64Array(input); const u_next = new Float64Array(len);
                    const sigma = stats ? stats.robustSigma : 0.01; 
                    const K = sigma * tuning.tukeyK; const K2 = K * K;
                    u_next.set(u); // EDGE PRESERVATION
                    for(let iter=0; iter<3; iter++) {
                        for(let y=1; y<height-1; y++) {
                            const row = Math.imul(y, width);
                            for(let x=1; x<width-1; x++) {
                                const idx = row + x; const v = u[idx];
                                const n=u[idx-width]-v, s=u[idx+width]-v, e=u[idx+1]-v, w=u[idx-1]-v;
                                const c = (d) => { const d2 = d*d; return (d2 <= K2) ? 0.5 * ((1.0 - d2/K2)**2) : 0.0; };
                                u_next[idx] = v + 0.25 * (c(n)*n + c(s)*s + c(e)*e + c(w)*w);
                            }
                        }
                        u.set(u_next);
                    }
                    return u;
                }
            };
            const generateManifold = async (base, w, h, layerKey, cb) => {
                const manifolds = new Array(8);
                const isSSIM = layerKey === 'ssim';
                // HIGH PRECISION UPGRADE: Float64
                const working = new Float64Array(base.length);
                if (isSSIM) { for(let i=0; i<base.length; i++) working[i] = Math.max(0, 1.0 - base[i]); } 
                else { working.set(base); }
                const robustSigma = PrecisionCore.estimateRobustSigma(working, w, h);
                let floorOverride = 1.0/65535.0;
                if (layerKey === 'entropy') floorOverride = 0.01; if (layerKey === 'coherence') floorOverride = 0.005;
                const stats = { robustSigma: Math.max(robustSigma, floorOverride), statFloor: Math.max(robustSigma, floorOverride) };
                const tuning = { geoScale: 1.5, nlmDecay: 1.5, tukeyK: 3.0 };
                if (layerKey === 'ssim') { tuning.nlmDecay = 0.8; tuning.tukeyK = 2.0; } 
                else if (layerKey === 'grad') { tuning.tukeyK = 4.0; tuning.geoScale = 2.0; } 
                else if (layerKey === 'entropy') { tuning.geoScale = 3.0; tuning.nlmDecay = 1.0; } 
                else if (layerKey === 'coherence') { tuning.tukeyK = 6.0; tuning.nlmDecay = 3.0; } 
                for(let m=0; m<8; m++) {
                    let curr = new Float64Array(working);
                    if(m & 1) curr = tasks.tukey(curr, w, h, stats, tuning);
                    if(m & 2) curr = tasks.nlm(curr, w, h, stats, tuning);
                    if(m & 4) curr = tasks.geodesic(curr, w, h, stats, tuning);
                    manifolds[m] = curr;
                    if(cb) cb(m/8.0); await new Promise(r => setTimeout(r, 0));
                }
                return manifolds;
            };
            return { generateManifold };
        })();

        // --- 6. OPTIMIZATION ENGINE (CASCADE + QUALITY BIAS) ---
        const OptimizationEngine = (() => {
            const solve = (tensor, layerKey, activeMask, viewMode) => {
                const raw = tensor[layerKey].raw; if (!raw) return null; 
                let buf;
                if (layerKey === 'ssim') { 
                    buf = new Float64Array(raw.length); 
                    for(let i=0; i<raw.length; i++) buf[i] = Math.max(0, 1.0 - raw[i]); 
                } else { buf = raw; }
                const len = buf.length; const stride = Math.floor(len / 10000) || 1;
                let n = 0, m1 = 0, m2 = 0, m4 = 0;
                for(let i=0; i<len; i+=stride) { m1 += buf[i]; n++; } const mu = m1 / n;
                const sampleValues = new Float32Array(n); let sIdx = 0;
                for(let i=0; i<len; i+=stride) { const d = buf[i] - mu; m2 += d*d; m4 += d*d*d*d; sampleValues[sIdx++] = buf[i]; }
                const variance = m2 / n; const kurtosis = (variance < 1e-20) ? 3.0 : (m4 / n) / (variance * variance);
                const { KURTOSIS_LUT, SIGMA_LUT } = PrecisionCore; let sigmaCorrection = 1.0;
                if (KURTOSIS_LUT && SIGMA_LUT) { const kClamped = Math.max(1.8, Math.min(10.0, kurtosis)); sigmaCorrection = SIGMA_LUT[Math.floor(((kClamped - 1.8) / 8.2) * 255)]; }
                let estSigma = PrecisionCore.estimateRobustSigma(buf, tensor.meta.w, tensor.meta.h);
                if (layerKey === 'entropy') estSigma = Math.max(estSigma, 0.01);
                
                const bitDepth = tensor.meta.bitDepth || 8;
                const qStep = 1.0 / (Math.pow(2, bitDepth) - 1);
                let sigmaMult = 3.0; let gainBoost = 1.0; let gammaTarget = 1.0;
                switch(layerKey) {
                    case 'entropy': sigmaMult = 5.0; break;
                    case 'ssim': sigmaMult = 2.0; gainBoost = 2.0; break;
                    case 'grad': gammaTarget = 0.8; break;
                    case 'coherence': sigmaMult = 3.5; break;
                    case 'heuristic': gammaTarget = 1.2; sigmaMult = 2.5; break;
                    case 'perceptual': gammaTarget = 1.0; sigmaMult = 2.8; gainBoost = 1.5; break;
                }

                // SUPERIOR REFINEMENT: Explicit quantization floor check
                const trueNoiseFloor = Math.max(estSigma * sigmaCorrection, qStep); 
                sampleValues.sort(); const p99 = sampleValues[Math.floor(n * 0.99)];
                
                // QUALITY BIAS: Distinguish between "Pure Noise" and "Signal"
                // If the signal peak (p99) is barely above noise floor, we assume empty channel.
                // In that case, we target the noise floor to be "visible but dark" (low gain).
                const signalHeadroom = p99 - trueNoiseFloor;
                const isPureNoise = signalHeadroom < trueNoiseFloor;
                
                // If it's pure noise, we map noise floor to 10x quantization step (visible speckle).
                // If it's signal, we map p99 to 0.90 (high visibility).
                const targetLevel = isPureNoise ? trueNoiseFloor * 10.0 : p99; 
                const safeTarget = Math.max(targetLevel, qStep * 10.0); // Absolute safety floor
                
                // Increased dynamic range usage to 90% (was 85%) for superior contrast
                const gain = Math.min(100000, Math.max(1, (0.90 / safeTarget) * gainBoost));
                
                // Gate logic: Allow texture through, but kill the floor.
                // 0.8 factor provides a slightly "softer" gate for forensic texture preservation.
                const gate = trueNoiseFloor * gain * (sigmaMult * 0.8); 
                const threshold = Math.min(255, gate * 255);

                return { gain, threshold, gamma: gammaTarget, softness: threshold * 0.5 };
            };
            return { solve };
        })();

        // --- 7. REGISTRATION ENGINE ---
        const RegistrationEngine = (() => {
            const { FARID_D, FARID_P } = PrecisionCore;
            const convolve1D = (inp, w, h, k) => {
                // HIGH PRECISION UPGRADE
                const out = new Float64Array(inp.length);
                const kLen = k.length, half = kLen>>1;
                for(let y=0; y<h; y++) {
                    const r = y*w;
                    for(let x=0; x<w; x++) {
                        let sum=0; for(let i=0; i<kLen; i++) { const ox = x-half+i; if(ox>=0 && ox<w) sum += inp[r+ox] * k[i]; }
                        out[r+x] = sum;
                    }
                }
                return out;
            };
            const getGradientMap = (luma, w, h) => {
                if (!FARID_D) return luma;
                const gx = convolve1D(luma, w, h, FARID_D); const gy = convolve1D(luma, w, h, FARID_P);
                const mag = new Float64Array(luma.length);
                for(let i=0; i<mag.length; i++) mag[i] = Math.sqrt(gx[i]*gx[i] + gy[i]*gy[i]);
                return mag;
            };
            const computeCoarse = async (buff1, buff2, width, height, cb) => {
                const map1 = getGradientMap(buff1, width, height); const map2 = getGradientMap(buff2, width, height);
                const anchors = []; for(let y=1; y<=3; y++) for(let x=1; x<=3; x++) anchors.push({x: (width*x)/4|0, y: (height*y)/4|0});
                const pSz = 64, hSz = 32, search = 40, step = 2; const votes = [];
                const getPatchStats = (buf, cx, cy, out) => {
                    let sum = 0; for(let y=0; y<pSz; y++) { const r = Math.imul(cy-hSz+y, width); for(let x=0; x<pSz; x++) { const v = buf[r + cx-hSz+x]; out.push(v); sum += v; } }
                    const mean = sum/(pSz*pSz); let sqSum = 0; for(let i=0; i<out.length; i++) { out[i] -= mean; sqSum += out[i]*out[i]; }
                    return Math.sqrt(sqSum);
                };
                for(let i=0; i<anchors.length; i++) {
                    const anc = anchors[i]; const p1=[]; const s1 = getPatchStats(map1, anc.x, anc.y, p1); if(s1 < 1e-5) continue;
                    let localBest = -1, lDx = 0, lDy = 0;
                    for(let dy=-search; dy<=search; dy+=step) for(let dx=-search; dx<=search; dx+=step) {
                        const p2=[]; const s2 = getPatchStats(map2, anc.x-dx, anc.y-dy, p2); if(s2 < 1e-5) continue;
                        let dot = 0; for(let k=0; k<p1.length; k+=2) dot += p1[k]*p2[k];
                        const score = dot / (s1 * s2); if(score > localBest) { localBest = score; lDx = dx; lDy = dy; }
                    }
                    if (localBest > 0.4) votes.push({dx:lDx, dy:lDy, score: localBest});
                    if(cb) cb(i/anchors.length * 0.5); await new Promise(r => setTimeout(r,0));
                }
                const bins = {}; let maxScore=0, consensus={dx:0, dy:0};
                votes.forEach(v => { const k = `${Math.round(v.dx/2)*2},${Math.round(v.dy/2)*2}`; bins[k] = (bins[k]||0) + v.score; if(bins[k]>maxScore) { maxScore=bins[k]; consensus=v; } });
                return maxScore > 0 ? consensus : null;
            };
            const computeFine = async (buff1, buff2, width, height, coarse, cb) => {
                const crop = 256, cx = width >> 1, cy = height >> 1; const ox = coarse.dx, oy = coarse.dy;
                const roi1 = new Float64Array(crop*crop);
                for(let y=0; y<crop; y++) { const r=Math.imul(cy-(crop>>1)+y, width), r2=Math.imul(y, crop); for(let x=0; x<crop; x++) roi1[r2+x]=buff1[r+cx-(crop>>1)+x]; }
                const map1 = getGradientMap(roi1, crop, crop); 
                const searchMargin = 10; const largeCrop = crop + searchMargin*2;
                const roi2Large = new Float64Array(largeCrop*largeCrop);
                for(let y=0; y<largeCrop; y++) { 
                    const r = Math.imul(Math.max(0, Math.min(height-1, (cy-(largeCrop>>1)+y-oy))), width); const r2 = Math.imul(y, largeCrop); 
                    for(let x=0; x<largeCrop; x++) roi2Large[r2+x]=buff2[r + Math.max(0, Math.min(width-1, (cx-(largeCrop>>1)+x-ox)))]; 
                }
                const map2Large = getGradientMap(roi2Large, largeCrop, largeCrop);
                const getError = (dx, dy) => {
                    let err = 0.0;
                    for(let y=0; y<crop; y+=4) {
                        const sy = y + searchMargin + dy; if(sy<0 || sy>=largeCrop-1) continue;
                        for(let x=0; x<crop; x+=4) {
                            const sx = x + searchMargin + dx; if(sx<0 || sx>=largeCrop-1) continue;
                            const ix=sx|0, iy=sy|0, fx=sx-ix, fy=sy-iy;
                            const idx = iy*largeCrop + ix;
                            // Bilinear Interpolation
                            const val = map2Large[idx]*(1-fx)*(1-fy) + map2Large[idx+1]*fx*(1-fy) + map2Large[idx+largeCrop]*(1-fx)*fy + map2Large[idx+largeCrop+1]*fx*fy;
                            
                            // QUALITY UPGRADE: SAD (Sum of Absolute Differences)
                            // More robust to outliers (artifacts/cursors) than SSD (d*d)
                            err += Math.abs(map1[y*crop+x] - val); 
                        }
                    }
                    return err;
                };
                let curX = 0, curY = 0, step = 4.0; let minErr = getError(0,0);
                for(let iter=0; iter<40; iter++) { // Increased iterations
                    let bestE = minErr, bestX = curX, bestY = curY;
                    [[0,-1],[0,1],[-1,0],[1,0]].forEach(d => { const nx = curX + d[0]*step, ny = curY + d[1]*step; const e = getError(nx, ny); if(e < bestE) { bestE = e; bestX = nx; bestY = ny; } });
                    if(bestE < minErr) { minErr = bestE; curX = bestX; curY = bestY; } else { step *= 0.5; }
                    if(step < 0.001) break; // Tighter convergence threshold (was 0.005)
                    if(cb) cb(0.5 + (iter/40)*0.5); await new Promise(r => setTimeout(r,0));
                }
                let finalX = ox + curX, finalY = oy + curY;
                if (Math.abs(finalX) < 0.15) finalX = 0.0; if (Math.abs(finalY) < 0.15) finalY = 0.0;
                return { x: finalX, y: finalY };
            };
            return { computeCoarse, computeFine };
        })();

        // --- 8. QUALITY METRICS ---
        const QualityMetricEngine = (() => {
            const computeNPS_Quant = (heuristic, luma, refEntropy, refCoherence, w, h, bitDepth) => {
                const len = w * h; let sum = 0.0, peak = 0.0, violations = 0;
                
                // 1. Bit-Depth Physics (The Hard Deck)
                const qStep = 1.0 / (Math.pow(2, bitDepth) - 1);
                
                // 2. Sensitivity Baseline (Nyquist-Shannon + Weber Floor)
                // We strictly bind to the derived quantization step.
                // 100-DPS PHILOSOPHY: The noise floor is physical, not arbitrary.
                const physicsFloor = PrecisionCore.PHYSICS ? PrecisionCore.PHYSICS[4] : (1.0/255.0);
                
                // For high bit depths (16-bit), we respect the precision but enforce a biological floor
                // (Visual cortex cannot detect 1/65535 luminance delta in isolation).
                // We use the greater of the format limit (qStep) or the biological limit (~1/1000).
                const baseSensitivity = Math.max(qStep, physicsFloor * 0.25); 
                
                const maxEnt = PrecisionCore.PHYSICS ? PrecisionCore.PHYSICS[5] : 4.64;
                const invMaxEnt = 1.0 / (maxEnt || 4.64);

                // MASKING SATURATION CONSTANTS (Michaelis-Menten)
                // Prevents infinite masking in high-texture areas.
                const MASK_CEILING = 4.0; // Max masking factor (4x tolerance)
                const MASK_KNEE = 0.3;    // Entropy level (0-1) where masking is 50% of max

                for(let i=0; i<len; i++) {
                    const L = luma[i]; 
                    // MAVERICK UPGRADE: Use Reference Content for Masking
                    const H = refEntropy[i] * invMaxEnt; // Normalize to 0-1
                    const C = refCoherence[i];           // Already 0-1

                    // 3. Luminance Masking (Parabolic CSF)
                    // HVS is most sensitive at mid-grey (0.5). Sensitivity drops in deep shadows (0.0) and highlights (1.0).
                    // We increase threshold (tolerance) at the extremes.
                    // Curve: 1.0 at 0.5, rising to 2.0 at 0.0 and 1.0.
                    const maskL = 1.0 + Math.pow((L - 0.5) * 2.0, 2.0); 

                    // 4. Texture & Geometric Masking (Psychovisual Saturation)
                    // SUPERIOR UPGRADE: Michaelis-Menten Kinetics
                    // Instead of linear growth (1 + H*3), we saturate.
                    // This prevents "Texture Blindness" where high entropy hides forensic artifacts.
                    const entropyMask = (MASK_CEILING * H) / (H + MASK_KNEE);
                    
                    // Coherence Penalty: Clean edges (High C) reduce masking (Higher Sensitivity).
                    // We dampen the entropy mask by the coherence factor.
                    const maskT = 1.0 + (entropyMask * (1.0 - C * 0.8));

                    // Composite Threshold: The "Just Noticeable Difference" at this pixel.
                    const threshold = baseSensitivity * maskL * maskT;

                    // 5. Normalized Error Ratio
                    const ratio = heuristic[i] / (threshold + 1e-12);
                    
                    if (ratio > peak) peak = ratio; 
                    if (ratio > 1.0) violations++; 
                    
                    // L4 Norm Pooling (emphasizes severe artifacts over low-level noise)
                    sum += ratio * ratio * ratio * ratio;
                }
                
                // Final Metrics
                const nps = Math.pow(sum / len, 0.25);
                return { nps, peak, mean: nps, visible_pct: (violations/len)*100 };
            };
            const computeSignalMetrics = (buf, w, h, bitDepth) => {
                const sig = PrecisionCore.estimateRobustSigma(buf, w, h);
                const qStep = 1.0 / (Math.pow(2, bitDepth) - 1);
                const minNoise = qStep * 0.5; // Physics Floor: 0.5 LSB
                const effectiveNoise = Math.max(sig, minNoise);
                const snr = (effectiveNoise > 0) ? Math.min(140, 20 * Math.log10(1.0 / effectiveNoise)) : 0;
                return { snr, ebd: Math.max(0, (snr - 1.76) / 6.02), noise: effectiveNoise };
            };
            return { computeNPS_Quant, computeSignalMetrics };
        })();

        // --- UI COMPONENTS ---
        const AuditModal = ({ isOpen, onClose, tensor, scoreData, metaNames, physics }) => {
            if(!isOpen || !scoreData || !physics) return null;
            const { nps, peak, visible_pct } = scoreData;
            const { snr, ebd, noise } = tensor.source_metrics;
            const grade = nps<0.5 ? {t:'S (Lab)', c:'text-emerald-400'} : nps<1.0 ? {t:'A (Pro)', c:'text-cyan-400'} : {t:'C (Fail)', c:'text-rose-400'};
            const copy = () => {
                const report = `[ 100-DPS FORENSIC AUDIT REPORT ]
----------------------------------------
DATE: ${new Date().toLocaleString()}
REF:  ${metaNames.ref}
TGT:  ${metaNames.tgt}
DIMS: ${tensor.meta.w}x${tensor.meta.h} (${tensor.meta.bitDepth}-bit)

[ SIGNAL ANALYSIS ]
SNR:   ${snr.toFixed(2)} dB
EBD:   ${ebd.toFixed(2)} bits
Noise: ${noise.toExponential(4)} (σ)

[ INTEGRITY METRICS ]
NPS Score:   ${nps.toFixed(4)} [${grade.t}]
Peak Dev:    ${peak.toFixed(4)}
Visible:     ${visible_pct.toFixed(2)}%
----------------------------------------
100-DPS Engine | Float64 Precision`;
                navigator.clipboard.writeText(report);
            };
            return (
                <div className="fixed inset-0 z-50 bg-black/80 backdrop-blur-sm flex items-center justify-center p-4">
                    <div className="glass-panel border border-slate-700/50 rounded-xl p-6 w-full max-w-md shadow-2xl relative overflow-hidden">
                        <div className="absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-slate-800 via-cyan-500/50 to-slate-800"></div>
                        <div className="flex justify-between items-center mb-6"><h2 className="text-xl font-bold text-white flex items-center gap-2"><ClipboardCheck className="w-5 h-5 text-cyan-400"/> Audit Report</h2><button onClick={onClose}><X className="text-slate-500 hover:text-white transition-colors"/></button></div>
                        <div className="text-center mb-8 relative">
                            <div className="text-[10px] font-bold text-slate-500 uppercase tracking-widest mb-2">Normalized Perceptual Score</div>
                            <div className={`text-7xl font-black font-mono tracking-tighter ${grade.c} drop-shadow-[0_0_15px_rgba(0,0,0,0.5)]`}>{nps.toFixed(3)}</div>
                            <div className={`inline-block px-4 py-1 mt-2 rounded-full border border-slate-700 bg-slate-800/50 text-xs font-bold uppercase tracking-widest ${grade.c}`}>{grade.t} GRADE</div>
                        </div>
                        <div className="grid grid-cols-2 gap-4 mb-6">
                            <div className="bg-slate-800/40 p-4 rounded-lg border border-slate-700/30 text-center"><div className="text-[10px] uppercase text-slate-500 font-bold mb-1">Peak Error</div><div className="text-xl font-mono text-white tracking-tight">{peak.toFixed(3)}</div></div>
                            <div className="bg-slate-800/40 p-4 rounded-lg border border-slate-700/30 text-center"><div className="text-[10px] uppercase text-slate-500 font-bold mb-1">Visible Surface</div><div className="text-xl font-mono text-white tracking-tight">{visible_pct.toFixed(2)}%</div></div>
                        </div>
                        <button onClick={copy} className="w-full py-3 bg-gradient-to-r from-slate-800 to-slate-700 hover:from-slate-700 hover:to-slate-600 border border-slate-600 text-cyan-400 font-bold rounded shadow-lg flex items-center justify-center gap-2 transition-all group"><FileText className="w-4 h-4 group-hover:scale-110 transition-transform"/> Copy Forensic Report</button>
                    </div>
                </div>
            );
        };

        const Histogram = ({ data, cutoff, height=60 }) => {
            const ref = useRef(null);
            useEffect(() => {
                if(!ref.current || !data) return;
                const ctx = ref.current.getContext('2d'), w = ref.current.width, h = ref.current.height;
                ctx.clearRect(0,0,w,h);
                let max = 0; for(let i=0; i<data.length; i++) if(data[i]>max) max=data[i];
                const logMax = Math.log(max+1), barW = w/data.length;
                ctx.fillStyle = "#0ea5e9";
                for(let i=0; i<data.length; i++) { const val = Math.log(data[i]+1); const barH = (val/logMax)*h; ctx.fillRect(i*barW, h-barH, Math.max(0.5, barW), barH); }
                if (cutoff >= 0 && cutoff <= 1) { 
                    const threshX = cutoff * w; ctx.beginPath(); ctx.strokeStyle = "#ef4444"; ctx.lineWidth = 2; ctx.moveTo(threshX, 0); ctx.lineTo(threshX, h); ctx.stroke(); 
                }
            }, [data, cutoff]);
            return <canvas ref={ref} width={300} height={height} className="w-full opacity-80" />;
        };

        const ChannelRow = ({ label, active, onClick, icon: Icon, special }) => (
            <button onClick={onClick} className={`w-full flex items-center gap-3 p-3 rounded-lg border transition-all ${active ? (special ? 'bg-indigo-950/50 border-indigo-500/50 text-indigo-400 shadow-[0_0_15px_rgba(99,102,241,0.2)]' : 'bg-cyan-950/30 border-cyan-500/50 text-cyan-400 shadow-[0_0_15px_rgba(6,182,212,0.1)]') : 'bg-slate-900/50 border-slate-800 text-slate-500 hover:border-slate-600 hover:text-slate-300'}`}>
                <Icon className={`w-4 h-4 ${special && active ? 'animate-pulse' : ''}`} />
                <span className="text-xs font-bold uppercase tracking-wider">{label}</span>
            </button>
        );

        const DualSlider = ({ label, displayValue, value, onChange, minCoarse, maxCoarse, stepCoarse, minFine, maxFine, stepFine }) => (
            <div className="bg-slate-900/30 border border-slate-800/60 p-2 rounded-lg space-y-2 hover:border-slate-700/60 transition-colors group">
                <div className="flex justify-between items-baseline"><div className="flex items-center gap-2"><span className="text-[10px] font-bold text-slate-500 uppercase tracking-widest group-hover:text-slate-400 transition-colors">{label}</span>{value.fine !== 0 && <span className="text-[8px] font-mono text-cyan-500/70 animate-pulse">•</span>}</div><span className="text-xs font-mono font-bold text-cyan-400 bg-cyan-950/20 px-1.5 py-0.5 rounded border border-cyan-900/30">{displayValue}</span></div>
                <div className="relative h-5 flex items-center"><input type="range" min={minCoarse} max={maxCoarse} step={stepCoarse} value={value.coarse} onChange={(e)=>onChange({...value, coarse: Number(e.target.value)})} className="absolute inset-0 w-full h-1.5 bg-slate-800 rounded-full appearance-none accent-cyan-500 cursor-pointer hover:bg-slate-700 transition-all range-slider"/></div>
                <div className="flex items-center gap-2 pl-1"><span className="text-[8px] font-mono text-slate-600 uppercase tracking-tight w-4">Trim</span><div className="relative flex-1 h-4 flex items-center"><div className="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 w-px h-2 bg-slate-700 pointer-events-none"></div><input type="range" min={minFine} max={maxFine} step={stepFine} value={value.fine} onChange={(e)=>onChange({...value, fine: Number(e.target.value)})} className="w-full h-0.5 bg-slate-800 rounded appearance-none accent-slate-500 hover:accent-cyan-300/80 cursor-col-resize transition-all range-fine"/></div><button onClick={()=>onChange({...value, fine: 0})} className={`p-1 rounded hover:bg-rose-950/30 hover:text-rose-400 transition-colors ${value.fine !== 0 ? 'text-slate-500' : 'text-slate-800 pointer-events-none'}`}><RotateCcw className="w-3 h-3"/></button></div>
            </div>
        );

        const Scrubber = ({ value, onChange, axis }) => {
            const scrubRef = useRef({ active: false, startY: 0, startVal: 0, startX: 0 });
            const handleWheel = (e) => {
                e.preventDefault(); e.stopPropagation();
                const delta = -Math.sign(e.deltaY);
                let step = 0.1;
                if (e.shiftKey) step = 1.0; if (e.altKey) step = 0.01;
                onChange(parseFloat((value + delta * step).toFixed(2)));
            };
            const handlePointerDown = (e) => {
                e.preventDefault(); e.stopPropagation();
                e.target.setPointerCapture(e.pointerId);
                scrubRef.current = { active: true, startY: e.clientY, startVal: value, startX: e.clientX };
                e.target.classList.add('scrubbing');
            };
            const handlePointerMove = (e) => {
                if (!scrubRef.current.active) return;
                e.preventDefault();
                const deltaY = scrubRef.current.startY - e.clientY; 
                const deltaX = Math.abs(e.clientX - scrubRef.current.startX); 
                const damping = 1.0 + (deltaX * 0.05);
                const sensitivity = 0.1 / damping; 
                const diff = deltaY * sensitivity;
                onChange(parseFloat((scrubRef.current.startVal + diff).toFixed(2)));
            };
            const handlePointerUp = (e) => {
                scrubRef.current.active = false;
                e.target.classList.remove('scrubbing');
            };
            return (
                <div className="w-20 h-12 bg-slate-950 border border-slate-800 rounded flex flex-col items-center justify-center cursor-ns-resize hover:border-cyan-500/50 transition-colors select-none touch-none relative overflow-hidden"
                     style={{ touchAction: 'none' }}
                     onWheel={handleWheel} onPointerDown={handlePointerDown} onPointerMove={handlePointerMove} onPointerUp={handlePointerUp} onPointerLeave={handlePointerUp}>
                    <span className="font-mono text-xs text-cyan-400 pointer-events-none relative z-10">{axis}: {value.toFixed(2)}</span>
                    <div className="text-[7px] text-slate-600 pointer-events-none relative z-10 uppercase tracking-tight mt-0.5">Slide Y / Pull X</div>
                </div>
            );
        };

        const Legend = ({ physics, type }) => {
            const ref=useRef(null);
            useEffect(() => {
                if(!ref.current) return;
                const isEntropy = type === 'entropy';
                const LUT = isEntropy && PrecisionCore.INFERNO ? PrecisionCore.INFERNO : PrecisionCore.TURBO;
                if (!LUT) return;
                const ctx=ref.current.getContext('2d'), w=256, h=12;
                const imgData = ctx.createImageData(w,h);
                const d = imgData.data;
                const lutLen = LUT.length/3;
                for(let i=0; i<w; i++) { 
                    const t = i/(w-1); const rawIdx = t * (lutLen-1); const i0 = Math.floor(rawIdx); const i1 = Math.min(lutLen-1, i0+1); const f = rawIdx - i0;
                    const r = LUT[i0*3]*(1-f) + LUT[i1*3]*f; const g = LUT[i0*3+1]*(1-f) + LUT[i1*3+1]*f; const b = LUT[i0*3+2]*(1-f) + LUT[i1*3+2]*f;
                    for(let y=0;y<h;y++) { const p=(y*w+i)*4; d[p]=r*255; d[p+1]=g*255; d[p+2]=b*255; d[p+3]=255; }
                }
                ctx.putImageData(imgData,0,0);
            }, [type, PrecisionCore.TURBO, PrecisionCore.INFERNO]); 
            return <div className="bg-slate-900/50 p-2 rounded border border-slate-700 mt-4"><div className="flex justify-between text-[9px] text-slate-500 font-mono uppercase mb-1"><span>Min</span><span>Max</span></div><canvas ref={ref} width={256} height={12} className="w-full rounded-sm opacity-90"/><div className="text-[9px] text-center text-slate-600 font-mono mt-1">{type === 'entropy' ? 'INFERNO (Log)' : 'TURBO (JND)'}</div></div>;
        };

        const ImageDiff = () => {
            const [isReady, setIsReady] = useState(false);
            const [img1, setImg1] = useState(null);
            const [img2, setImg2] = useState(null);
            const [meta, setMeta] = useState({ref:'', tgt:''});
            const [tensor, setTensor] = useState(null);
            const [activeTab, setActiveTab] = useState('analysis');
            const [activeLayer, setActiveLayer] = useState('heuristic');
            const [viewMode, setViewMode] = useState('raw');
            const [repairSettings, setRepairSettings] = useState({ chroma: false, ringing: false, geodesic: false });
            const [displayData, setDisplayData] = useState(null);
            const [transform, setTransform] = useState({k:1, x:0, y:0});
            const [offset, setOffset] = useState({x:0, y:0});
            const [debouncedOffset, setDebouncedOffset] = useState({x:0,y:0});
            const dragRef = useRef({active:false, x:0, y:0});
            const touchRef = useRef({active: false, x:0, y:0, dist:0}); 
            const probeModeRef = useRef(false); // false=Std, true=Precision
            const lastMouseRef = useRef({x:0, y:0});
            const [gainState, setGainState] = useState({coarse:45, fine:0});
            const [gateState, setGateState] = useState({coarse:0.5, fine:0});
            const [gammaState, setGammaState] = useState({coarse:1.0, fine:0});
            const [softState, setSoftState] = useState({coarse:10, fine:0});
            const [status, setStatus] = useState("Idle");
            const [progress, setProgress] = useState(0);
            const [isProcessing, setIsProcessing] = useState(false);
            const [showAudit, setShowAudit] = useState(false);
            const [isAligning, setIsAligning] = useState(false);
            const [alignStatus, setAlignStatus] = useState("");
            const [mix, setMix] = useState(0);
            const [opacity, setOpacity] = useState(1);
            const [showMap, setShowMap] = useState(true);
            const [showSource, setShowSource] = useState(true);
            const [flicker, setFlicker] = useState(false);
            const [flickerState, setFlickerState] = useState(0);
            const [regMode, setRegMode] = useState('difference');
            const canvasRef = useRef(null); const containerRef = useRef(null); const viewRef = useRef(null); const displayBufferRef = useRef(null); const offscreenCanvasRef = useRef(null); const hudRef = useRef(null);
            const [stats, setStats] = useState(null);

            useEffect(() => { const t = setInterval(() => { if (PrecisionCore.isReady()) { setIsReady(true); clearInterval(t); } }, 100); return () => clearInterval(t); }, []);
            useEffect(() => { const t = setTimeout(() => setDebouncedOffset(offset), 300); return () => clearTimeout(t); }, [offset]);
            useEffect(() => { let t; if(flicker) t = setInterval(() => setFlickerState(s => s===0?1:0), 120); else setFlickerState(0); return () => clearInterval(t); }, [flicker]);

            const physics = useMemo(() => {
                const logBase = -4 + (gainState.coarse/100.0)*10;
                const gain = Math.pow(10, logBase + gainState.fine);
                const bitDepth = tensor?.meta?.bitDepth || 8;
                const qStep = 1.0 / (Math.pow(2, bitDepth) - 1);
                
                // MAVERICK UPGRADE: DECOUPLE GATE FROM QUANTIZATION
                // The slider (0-255) now represents "Visual Threshold" (0.0 - 1.0)
                // This ensures the gate works for 16-bit high-gain scenarios where noise >> qStep.
                const threshold = Math.max(0, gateState.coarse + gateState.fine);
                const signalGate = threshold / 255.0; // Normalized Visual Gate (0-1)
                
                const gamma = Math.max(0.1, Math.min(3.0, gammaState.coarse + gammaState.fine));
                const softness = Math.max(0, Math.min(100, softState.coarse + softState.fine));
                return { gain, signalGate, gamma, softness, threshold };
            }, [gainState, gateState, gammaState, softState, tensor]);

            // Safe display value calculation (physics is defined above)
            const gateDisplayVal = useMemo(() => {
                const raw = physics.threshold; // 0-255
                if(tensor?.meta?.bitDepth === 16) return Math.round(raw * 257); // Scale 255 -> 65535
                return raw.toFixed(2);
            }, [physics.threshold, tensor]);

            // KEYBOARD LISTENER FOR 'P'
            useEffect(() => {
                const handler = (e) => { if(e.key.toLowerCase() === 'p') { probeModeRef.current = !probeModeRef.current; updateHUD(lastMouseRef.current.x, lastMouseRef.current.y); } };
                window.addEventListener('keydown', handler); return () => window.removeEventListener('keydown', handler);
            }, [tensor]); 

            const updateHUD = (clientX, clientY) => {
                if(!img1 || !viewRef.current || !hudRef.current) return;
                const rect = viewRef.current.getBoundingClientRect();
                const x = (clientX - rect.left - transform.x) / transform.k;
                const y = (clientY - rect.top - transform.y) / transform.k;
                
                if(x >= 0 && x < img1.width && y >= 0 && y < img1.height) {
                    const ix = x | 0, iy = y | 0;
                    hudRef.current.style.display = "block"; 
                    hudRef.current.style.left = `${clientX + 15}px`; 
                    hudRef.current.style.top = `${clientY + 15}px`;
                    if(tensor) {
                        const idx = iy * tensor.meta.w + ix; 
                        const v = (k) => tensor[k]?.raw ? tensor[k].raw[idx] : 0;
                        const isPrecise = probeModeRef.current;
                        const fmt = (val) => {
                            if (val === 0) return isPrecise ? "0.000000000000000000" : "0.00000 "; 
                            if (isPrecise) return val.toFixed(18); // Full length, no truncation
                            return val.toFixed(5) + " "; // Standard fixed length
                        };
                        hudRef.current.innerHTML = `<div class="space-y-1"><div class="flex justify-between text-[10px] font-bold text-slate-400 border-b border-slate-700 pb-1"><span>XY [${ix}, ${iy}]</span><span class="text-slate-500">${tensor.meta.bitDepth}-BIT ${isPrecise?'[RAW]':'[STD]'}</span></div><div class="grid grid-cols-2 gap-x-4 gap-y-0.5 text-[9px] font-mono leading-tight"><span class="text-indigo-400">COMP</span><span class="text-slate-200 text-right">${fmt(v('heuristic'))}</span><span class="text-emerald-400">SSIM</span><span class="text-slate-200 text-right">${fmt(v('ssim'))}</span><span class="text-cyan-400">GRAD</span><span class="text-slate-200 text-right">${fmt(v('grad'))}</span><span class="text-amber-400">ENTR</span><span class="text-slate-200 text-right">${fmt(v('entropy'))}</span><span class="text-rose-400">COHER</span><span class="text-slate-200 text-right">${fmt(v('coherence'))}</span><span class="text-blue-400">DELTA</span><span class="text-slate-200 text-right">${fmt(v('perceptual'))}</span></div></div>`;
                    }
                } else {
                    hudRef.current.style.display = "none";
                }
            };

            const lastTapRef = useRef(0);
            const handleTouchStart = (e) => {
                const now = Date.now();
                if (now - lastTapRef.current < 300) { probeModeRef.current = !probeModeRef.current; if(e.touches[0]) updateHUD(e.touches[0].clientX, e.touches[0].clientY); }
                lastTapRef.current = now;
                if(e.touches.length === 1) { touchRef.current = { x: e.touches[0].clientX, y: e.touches[0].clientY, dist: 0, active: true }; dragRef.current.active = true; } 
                else if (e.touches.length === 2) { const t1 = e.touches[0], t2 = e.touches[1]; const dist = Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY); touchRef.current = { ...touchRef.current, dist, active: true }; dragRef.current.active = false; }
            };
            
            const handleTouchMove = (e) => {
                if (!touchRef.current.active) return;
                if (e.touches.length === 1 && dragRef.current.active) {
                    const dx = e.touches[0].clientX - touchRef.current.x; const dy = e.touches[0].clientY - touchRef.current.y;
                    setTransform(p => ({ ...p, x: p.x + dx, y: p.y + dy })); 
                    touchRef.current.x = e.touches[0].clientX; touchRef.current.y = e.touches[0].clientY;
                    lastMouseRef.current = {x: e.touches[0].clientX, y: e.touches[0].clientY};
                    updateHUD(e.touches[0].clientX, e.touches[0].clientY);
                } 
                else if (e.touches.length === 2) {
                    const t1 = e.touches[0], t2 = e.touches[1]; 
                    const dist = Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY); 
                    const scaleFactor = dist / (touchRef.current.dist + 1e-9);
                    if (Math.abs(scaleFactor - 1.0) > 0.005) { 
                        const rect = viewRef.current.getBoundingClientRect(); 
                        const mx = (t1.clientX + t2.clientX) / 2 - rect.left; 
                        const my = (t1.clientY + t2.clientY) / 2 - rect.top;
                        setTransform(p => { 
                            const newK = Math.max(0.1, Math.min(100, p.k * scaleFactor)); 
                            const newX = mx - ((mx - p.x) / p.k) * newK; 
                            const newY = my - ((my - p.y) / p.k) * newK; 
                            return { k: newK, x: newX, y: newY }; 
                        }); 
                        touchRef.current.dist = dist;
                    }
                }
            };

            const handleTouchEnd = () => { touchRef.current.active = false; dragRef.current.active = false; if(hudRef.current) hudRef.current.style.display="none"; };
            
            const handleCanvasWheel = (e) => {
                e.preventDefault(); e.stopPropagation();
                const rect = viewRef.current.getBoundingClientRect();
                const mx = e.clientX - rect.left; 
                const my = e.clientY - rect.top;
                const s = e.deltaY > 0 ? 0.9 : 1.1;
                setTransform(p => ({ k: p.k * s, x: mx - (mx - p.x) * s, y: my - (my - p.y) * s }));
            };

            const handleCanvasDown = (e) => { dragRef.current = { active: true, x: e.clientX, y: e.clientY }; };
            
            const handleCanvasMove = (e) => {
                lastMouseRef.current = {x: e.clientX, y: e.clientY};
                if(dragRef.current.active){
                    const dx = e.clientX - dragRef.current.x; const dy = e.clientY - dragRef.current.y;
                    setTransform(t => ({...t, x: t.x + dx, y: t.y + dy}));
                    dragRef.current = { active: true, x: e.clientX, y: e.clientY };
                } else { updateHUD(e.clientX, e.clientY); }
            };
            
            const handleCanvasUp = () => { dragRef.current.active = false; };
            const handleDoubleClick = (e) => { probeModeRef.current = !probeModeRef.current; updateHUD(e.clientX, e.clientY); };


            const buildTensor = useCallback(async () => {
                if(!img1 || !img2 || activeTab !== 'analysis' || !isReady) return;
                setStatus("Manifold Projection..."); setIsProcessing(true); setProgress(0); await new Promise(r=>setTimeout(r,10));
                try {
                    const w = img1.width, h = img1.height; const size = w * h;
                    const getBytes = (img, ox, oy) => { 
                        const c = document.createElement('canvas'); c.width=w; c.height=h; const ctx = c.getContext('2d'); 
                        ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high';
                        ctx.drawImage(img, ox, oy); 
                        return ctx.getImageData(0,0,w,h); 
                    };
                    const t1 = IngestEngine.process(getBytes(img1,0,0), w, h); setProgress(20);
                    const t2 = IngestEngine.process(getBytes(img2, debouncedOffset.x, debouncedOffset.y), w, h); setProgress(40);
                    const st1 = AnalysisEngine.getStructureTensor(t1.oklab, w, h);
                    const st2 = AnalysisEngine.getStructureTensor(t2.oklab, w, h);
                    const ssim = AnalysisEngine.getSSIM(t1.oklab, t2.oklab, w, h);
                    const deltaE = AnalysisEngine.getPerceptualDelta(t1.oklab, t2.oklab, w, h);
                    const ent1 = AnalysisEngine.getEntropy(t1.oklab.l, w, h); const ent2 = AnalysisEngine.getEntropy(t2.oklab.l, w, h); setProgress(60);
                    const layers = { perceptual: {raw: deltaE}, ssim: {raw: ssim}, grad: {raw: new Float64Array(size)}, coherence: {raw: new Float64Array(size)}, entropy: {raw: new Float64Array(size)}, heuristic: {raw: new Float64Array(size)}, latent: {} };
                    const INV_LOG_25 = 1.0 / 4.64;
                    const HVS_MASK = PrecisionCore.HVS_MASK_LUT; const HVS_LEN = HVS_MASK ? HVS_MASK.length - 1 : 0;
                    for(let i=0; i<size; i++) {
                        const gDiff = Math.abs(st1.l1[i] - st2.l1[i]); const cDiff = Math.abs(st1.coherence[i] - st2.coherence[i]); const eDiff = Math.abs(ent1[i] - ent2[i]);
                        layers.grad.raw[i] = gDiff; layers.coherence.raw[i] = cDiff; layers.entropy.raw[i] = eDiff;
                        const localCoh = Math.max(st1.coherence[i], st2.coherence[i]); const flatWeight = 1.0 - (localCoh * 0.5); const edgeWeight = 0.5 + (localCoh * 2.0);
                        const termPercep = deltaE[i]; const termStruct = Math.log1p(gDiff) * 2.0; const termSSIM = Math.max(0, 1.0 - ssim[i]); const termEnt = eDiff * INV_LOG_25;
                        
                        // FORENSIC UPGRADE: HVS STRUCTURAL MASKING
                        // If gradient is low (flat), weight -> 1.0 (Preserve Banding/Subtle Splicing)
                        // If gradient is high (texture/edge), weight -> 0.0 (Suppress Ringing/Quantization)
                        let maskWeight = 1.0;
                        if (HVS_MASK) {
                           const structureRef = st1.l1[i]; // Reference Structure Intensity
                           
                           // 100-DPS PRECISION: Use Linear Interpolation for LUT lookup
                           // Avoids quantization steps in the sensitivity mask
                           const rawIdx = Math.max(0, structureRef * HVS_LEN);
                           const idxLo = Math.floor(rawIdx);
                           const idxHi = Math.min(HVS_LEN, idxLo + 1);
                           const t = rawIdx - idxLo;
                           
                           // Boundary safe lookup (clamped to LUT size)
                           // If rawIdx exceeds LUT, we clamp to the last value (max masking)
                           const valLo = HVS_MASK[Math.min(HVS_LEN, idxLo)];
                           const valHi = HVS_MASK[idxHi]; // idxHi is already clamped via min above
                           
                           maskWeight = valLo * (1.0 - t) + valHi * t;
                        }
                        
                        layers.heuristic.raw[i] = Math.sqrt((termPercep * flatWeight)**2 + (termStruct * edgeWeight)**2 + (termSSIM * edgeWeight)**2 + (termEnt * flatWeight * 0.5)**2 + (cDiff * 0.25)**2) * maskWeight;
                    }
                    const keys = ['heuristic', 'perceptual', 'grad', 'ssim', 'entropy', 'coherence']; let d = 0;
                    for(const key of keys) { layers.latent[key] = await ForensicFilter.generateManifold(layers[key].raw, w, h, key, (p) => setProgress(70 + (d/6 + p/6)*30)); d++; }
                    const sm = QualityMetricEngine.computeSignalMetrics(t1.oklab.l, w, h, t1.meta.bitDepth); // Pass bitDepth
                    // MAVERICK UPGRADE: Pass Reference Entropy (ent1) and Coherence (st1.coherence) for masking
                    const scores = QualityMetricEngine.computeNPS_Quant(layers.heuristic.raw, t1.oklab.l, ent1, st1.coherence, w, h, t1.meta.bitDepth);
                    setTensor({ ...layers, meta: { w, h, bitDepth: t1.meta.bitDepth }, source_metrics: sm, scores: scores }); setStatus("Ready"); setProgress(100);
                } catch(e) { console.error(e); setStatus("Error"); } finally { setIsProcessing(false); }
            }, [img1, img2, debouncedOffset, activeTab, isReady]);

            const runAutoTune = useCallback(async () => {
                if(!tensor) return; setStatus("GGD Solving..."); await new Promise(r=>setTimeout(r,10));
                const mask = (repairSettings.chroma?1:0) | (repairSettings.ringing?2:0) | (repairSettings.geodesic?4:0);
                const s = OptimizationEngine.solve(tensor, activeLayer, mask, viewMode);
                if(s) {
                    const logG = Math.log10(s.gain); const cG = Math.max(0, Math.min(100, ((logG+4)/10)*100));
                    setGainState({coarse: cG, fine: 0}); setGateState({coarse: s.threshold, fine: 0}); setGammaState({coarse: s.gamma, fine: 0}); setSoftState({coarse: s.softness/255*100, fine: 0}); setStatus(`Locked: ${s.gain.toFixed(1)}x`);
                }
            }, [tensor, activeLayer, viewMode, repairSettings]);

            const runAutoAlign = async () => {
                if(!img1 || !img2) return; setIsAligning(true); setAlignStatus("Analysing...");
                const getRawL = (img) => { const c = document.createElement('canvas'); c.width=img.width; c.height=img.height; const ctx = c.getContext('2d'); ctx.drawImage(img, 0, 0); const d = ctx.getImageData(0,0,img.width,img.height).data; const l = new Float32Array(d.length/4); 
                const { LUMA_COEFFS } = PrecisionCore;
                if (LUMA_COEFFS) { for(let i=0; i<l.length; i++) l[i] = d[i*4]*LUMA_COEFFS[0] + d[i*4+1]*LUMA_COEFFS[1] + d[i*4+2]*LUMA_COEFFS[2]; }
                else { for(let i=0; i<l.length; i++) l[i] = d[i*4]*0.2126 + d[i*4+1]*0.7152 + d[i*4+2]*0.0722; }
                return l; };
                
                const b1 = getRawL(img1); const b2 = getRawL(img2);
                setAlignStatus("ZNCC Voting..."); await new Promise(r => setTimeout(r,10));
                const coarse = await RegistrationEngine.computeCoarse(b1, b2, img1.width, img1.height, (p)=>setProgress(p*40));
                if(coarse) { 
                    setAlignStatus("LoG Descent..."); await new Promise(r => setTimeout(r,10));
                    const fine = await RegistrationEngine.computeFine(b1, b2, img1.width, img1.height, coarse, (p)=>setProgress(40 + p*60)); 
                    setOffset({x: parseFloat(fine.x.toFixed(2)), y: parseFloat(fine.y.toFixed(2))}); setAlignStatus("Locked"); 
                } else { setAlignStatus("Failed"); }
                setIsAligning(false); setProgress(0);
            };

            const updateDisplay = useCallback(() => {
                if(!tensor || !img1 || !PrecisionCore.TURBO) return;
                const w = tensor.meta.w, h = tensor.meta.h, len = w*h; let layer;
                if(viewMode === 'clean' && tensor.latent[activeLayer]) { 
                    const mask = (repairSettings.chroma?1:0) | (repairSettings.ringing?2:0) | (repairSettings.geodesic?4:0); 
                    layer = tensor.latent[activeLayer][mask]; 
                } else { layer = tensor[activeLayer].raw; } 
                if(!layer) return;
                if(!displayBufferRef.current || displayBufferRef.current.length !== len*4) { displayBufferRef.current = new Uint8ClampedArray(len*4); }
                const output = displayBufferRef.current; const LUT = (activeLayer === 'entropy') && PrecisionCore.INFERNO ? PrecisionCore.INFERNO : PrecisionCore.TURBO; const lutLen = (LUT.length/3) - 1; const vGate = physics.signalGate * 255.0; const vSoft = Math.max(0.1, physics.softness); const invSoft = 1.0 / vSoft; const { BAYER_LATTICE } = PrecisionCore;
                const hist = new Uint32Array(256);
                
                for(let i=0; i<len; i++) {
                    let val = layer[i];
                    if (activeLayer === 'ssim' && viewMode === 'raw') val = Math.max(0, 1.0 - val);
                    const pVal = val * 255.0 * physics.gain; 
                    let alpha = 0.0;
                    const histIdx = Math.min(255, Math.max(0, pVal|0)); hist[histIdx]++;
                    if(pVal < vGate) alpha = 0.0; else if(pVal >= vGate + vSoft) alpha = 1.0; else { const t = (pVal - vGate) * invSoft; alpha = t * t * (3.0 - 2.0 * t); }
                    const idx = i << 2;
                    if(alpha > 0) {
                        let nVal = pVal / 255.0; if(physics.gamma !== 1.0 && nVal > 0) nVal = Math.pow(nVal, 1.0/physics.gamma);
                        const y = (i / w) | 0; const x = i % w; const dither = BAYER_LATTICE ? BAYER_LATTICE[((y & 7) << 3) + (x & 7)] * (1.0/lutLen) : 0; nVal = Math.max(0, Math.min(1, nVal + dither));
                        const rawIdx = nVal * lutLen; const i0 = Math.floor(rawIdx); const i1 = Math.min(lutLen, i0+1); const f = rawIdx - i0;
                        const r = LUT[i0*3]*(1-f) + LUT[i1*3]*f; const g = LUT[i0*3+1]*(1-f) + LUT[i1*3+1]*f; const b = LUT[i0*3+2]*(1-f) + LUT[i1*3+2]*f;
                        output[idx] = r * 255; output[idx+1] = g * 255; output[idx+2] = b * 255; output[idx+3] = alpha * 255 * opacity;
                    } else { output[idx+3] = 0; }
                }
                setStats({hist});
                setDisplayData(new ImageData(output, w, h));
            }, [tensor, activeLayer, viewMode, repairSettings, physics, opacity, isReady]);

            useEffect(() => { buildTensor(); }, [buildTensor]); useEffect(() => { updateDisplay(); }, [updateDisplay]);
            useEffect(() => { const cvs = canvasRef.current; if(!cvs || !img1) return; const ctx = cvs.getContext('2d'); cvs.width = img1.width; cvs.height = img1.height; ctx.fillStyle = "#000"; ctx.fillRect(0,0,cvs.width, cvs.height); if(activeTab === 'registration') { ctx.globalAlpha = 1.0; ctx.drawImage(img1, 0, 0); if(img2) { ctx.globalCompositeOperation = regMode === 'difference' ? 'difference' : 'source-over'; ctx.globalAlpha = regMode === 'difference' ? 1.0 : 0.5; ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high'; ctx.drawImage(img2, offset.x, offset.y); } } else { if(showSource) { ctx.globalAlpha = 1.0; if(flicker) { if(flickerState === 0) ctx.drawImage(img1, 0, 0); else if(img2) ctx.drawImage(img2, offset.x, offset.y); } else { ctx.drawImage(img1, 0, 0); if(img2 && mix > 0) { ctx.globalAlpha = mix; ctx.drawImage(img2, offset.x, offset.y); } } } if(displayData && showMap) { let t = offscreenCanvasRef.current; if(!t) { t = document.createElement('canvas'); offscreenCanvasRef.current = t; } t.width = cvs.width; t.height = cvs.height; t.getContext('2d').putImageData(displayData, 0, 0); ctx.globalCompositeOperation = 'source-over'; ctx.globalAlpha = 1.0; ctx.drawImage(t, 0, 0); } } }, [displayData, img1, img2, activeTab, offset, regMode, mix, showSource, showMap, flicker, flickerState]);

            const handleUpload = (isRef) => (e) => { const f = e.target.files[0]; if(f) createImageBitmap(f).then(b => { if(isRef) { setImg1(b); setMeta(m=>({...m, ref:f.name})); if(viewRef.current) { const r = viewRef.current.getBoundingClientRect(); const s = Math.min(r.width/b.width, r.height/b.height)*0.9; setTransform({k:s, x:(r.width-b.width*s)/2, y:(r.height-b.height*s)/2}); } } else { setImg2(b); setMeta(m=>({...m, tgt:f.name})); } }); };
            const handleWheelControl = (axis, e) => { e.stopPropagation(); e.preventDefault(); const delta = -Math.sign(e.deltaY); let step = 1.0; if(e.shiftKey) step = 10.0; else if(e.altKey) step = 0.1; setOffset(p => ({...p, [axis]: parseFloat((p[axis] + delta*step).toFixed(2))})); };
            const formatName = (n) => n ? (n.length>12?n.substr(0,8)+'...'+n.substr(-4):n) : 'N/A';

            if(!isReady) return <div className="h-screen w-screen bg-slate-950 flex flex-col items-center justify-center text-slate-500 font-mono animate-pulse"><Activity className="w-12 h-12 mb-4 text-rose-500 opacity-50"/><h1 className="text-xl font-bold">MANIFOLD UNINITIALIZED</h1><p className="text-xs mt-2">Run THECALC.py to inject math kernel.</p></div>;

            return (
                <div className="w-screen h-screen bg-slate-950 text-slate-300 flex flex-col md:flex-row overflow-hidden font-sans select-none">
                    <AuditModal isOpen={showAudit} onClose={()=>setShowAudit(false)} tensor={tensor} scoreData={tensor?.scores} metaNames={meta} physics={physics} />
                    <div className="w-full md:w-80 shrink-0 bg-slate-900 border-r border-slate-800 flex flex-col z-20 shadow-2xl h-1/2 md:h-full order-2 md:order-1">
                        <div className="p-4 border-b border-slate-800 bg-slate-900 flex justify-between items-center"><div><h1 className="text-cyan-400 font-bold text-lg flex items-center gap-2"><Activity className="w-5 h-5"/> ImageDiff 64</h1><div className="text-[10px] text-slate-500 mt-1 font-mono uppercase tracking-widest">100-DPS Engine</div></div>
                            <div className="flex gap-2">
                                <button onClick={()=>window.location.reload()} className="p-2 hover:bg-slate-800 rounded text-slate-500 hover:text-rose-400"><RotateCcw className="w-4 h-4"/></button>
                            </div>
                        </div>
                        <div className="flex border-b border-slate-800"><button onClick={()=>setActiveTab('analysis')} className={`flex-1 py-3 text-xs font-bold ${activeTab==='analysis'?'text-cyan-400 border-b-2 border-cyan-400 bg-slate-800/30':'text-slate-500'}`}>ANALYSIS</button><button onClick={()=>setActiveTab('registration')} className={`flex-1 py-3 text-xs font-bold ${activeTab==='registration'?'text-cyan-400 border-b-2 border-cyan-400 bg-slate-800/30':'text-slate-500'}`}>ALIGNMENT</button></div>
                        <div className="flex-1 overflow-y-auto p-4 space-y-6 scrollbar-hide">
                            <div className="space-y-2">
                                <div className="flex justify-between items-center mb-2">
                                    <span className="text-[10px] font-bold text-slate-500 uppercase tracking-widest flex items-center gap-2"><Layers className="w-3 h-3"/> Sources</span>
                                    <button onClick={()=>setShowSource(!showSource)} className={`p-1 rounded hover:bg-slate-800 transition-colors ${showSource?'text-cyan-400':'text-slate-600'}`}>{showSource ? <Eye className="w-4 h-4"/> : <EyeOff className="w-4 h-4"/>}</button>
                                </div>
                                <label className="block p-2 border border-slate-700 border-dashed rounded hover:border-cyan-500/50 cursor-pointer transition-colors bg-slate-900/50"><div className="flex justify-between text-xs font-bold"><span>REF (A)</span><span className="text-cyan-400 font-mono">{formatName(meta.ref)}</span></div><input type="file" className="hidden" accept="image/*" onChange={handleUpload(true)}/></label><label className="block p-2 border border-slate-700 border-dashed rounded hover:border-cyan-500/50 cursor-pointer transition-colors bg-slate-900/50"><div className="flex justify-between text-xs font-bold"><span>TGT (B)</span><span className="text-cyan-400 font-mono">{formatName(meta.tgt)}</span></div><input type="file" className="hidden" accept="image/*" onChange={handleUpload(false)}/></label>
                            </div>
                            {activeTab === 'registration' && (<div className="space-y-4 animate-in fade-in"><div className="p-3 bg-slate-800/50 rounded border border-slate-700 font-mono text-xs"><div className="grid grid-cols-3 gap-1 text-center"><button onClick={()=>setOffset(p=>({...p,x:p.x-1}))} className="bg-slate-700 hover:bg-slate-600 rounded py-2">←</button><div className="grid gap-1"><button onClick={()=>setOffset(p=>({...p,y:p.y-1}))} className="bg-slate-700 hover:bg-slate-600 rounded py-1">↑</button><button onClick={()=>setOffset(p=>({...p,y:p.y+1}))} className="bg-slate-700 hover:bg-slate-600 rounded py-1">↓</button></div><button onClick={()=>setOffset(p=>({...p,x:p.x+1}))} className="bg-slate-700 hover:bg-slate-600 rounded py-2">→</button></div></div><div className="flex flex-col gap-2 p-3 bg-slate-800/50 border border-slate-700 rounded items-center justify-center"><div className="text-[9px] text-slate-500 font-bold uppercase mb-1">Kinetic Tuner</div><div className="flex gap-2"><Scrubber axis="X" value={offset.x} onChange={(v)=>setOffset(p=>({...p, x:v}))} /><Scrubber axis="Y" value={offset.y} onChange={(v)=>setOffset(p=>({...p, y:v}))} /></div></div><button onClick={runAutoAlign} disabled={isAligning} className="w-full py-3 bg-indigo-600 hover:bg-indigo-500 text-white font-bold text-xs rounded flex items-center justify-center gap-2 transition-all shadow-lg shadow-indigo-900/20">{isAligning?<Loader className="w-3 h-3 animate-spin"/>:<Target className="w-3 h-3"/>} {alignStatus||"Autolock"}</button><div className="flex gap-2"><button onClick={()=>setRegMode('difference')} className={`flex-1 py-2 text-[10px] font-bold border rounded transition-all ${regMode==='difference'?'bg-slate-700 text-white':'bg-slate-900 text-slate-500'}`}>DIFF</button><button onClick={()=>setRegMode('mix')} className={`flex-1 py-2 text-[10px] font-bold border rounded transition-all ${regMode==='mix'?'bg-slate-700 text-white':'bg-slate-900 text-slate-500'}`}>MIX</button></div></div>)}
                            {activeTab === 'analysis' && tensor && (<div className="space-y-4 animate-in fade-in">
                                <div className="p-3 bg-slate-800/50 rounded border border-slate-700 space-y-3"><div className="space-y-1"><div className="flex justify-between text-[10px] font-bold text-slate-500 uppercase"><span>Opacity</span><span className="text-cyan-400">{Math.round(opacity*100)}%</span></div><input type="range" min="0" max="1" step="0.01" value={opacity} onChange={e=>setOpacity(parseFloat(e.target.value))} className="w-full h-1 bg-slate-700 rounded appearance-none accent-cyan-500"/></div><div className="space-y-1"><div className="flex justify-between text-[10px] font-bold text-slate-500 uppercase"><span>Mix</span><span className="text-cyan-400">{Math.round(mix*100)}%</span></div><input type="range" min="0" max="1" step="0.01" value={mix} onChange={e=>setMix(parseFloat(e.target.value))} className="w-full h-1 bg-slate-700 rounded appearance-none accent-cyan-500"/></div><button onClick={()=>setFlicker(!flicker)} className={`w-full py-1.5 text-[10px] font-bold rounded border transition-all flex items-center justify-center gap-2 ${flicker ? 'bg-amber-900/30 border-amber-500 text-amber-400' : 'bg-slate-900 border-slate-700 text-slate-500 hover:border-slate-600'}`}><Zap className={`w-3 h-3 ${flicker?'fill-current':''}`}/> {flicker ? 'FLICKER ACTIVE' : 'ENABLE FLICKER'}</button></div>
                                <div className="flex justify-between items-center mb-2">
                                    <span className="text-[10px] font-bold text-slate-500 uppercase flex items-center gap-1"><Eye className="w-3 h-3"/> Tensor Field</span>
                                    <button onClick={()=>setShowMap(!showMap)} className={`p-1 rounded hover:bg-slate-800 transition-colors ${showMap?'text-cyan-400':'text-slate-600'}`}>{showMap ? <Eye className="w-4 h-4"/> : <EyeOff className="w-4 h-4"/>}</button>
                                </div>
                                <div className="space-y-1"><ChannelRow label="Composite" active={activeLayer==='heuristic'} onClick={()=>setActiveLayer('heuristic')} icon={BrainCircuit} special={true}/><ChannelRow label="Structure" active={activeLayer==='grad'} onClick={()=>setActiveLayer('grad')} icon={ScanLine}/><ChannelRow label="Delta-E" active={activeLayer==='perceptual'} onClick={()=>setActiveLayer('perceptual')} icon={Sun}/><ChannelRow label="SSIM" active={activeLayer==='ssim'} onClick={()=>setActiveLayer('ssim')} icon={Binary}/><ChannelRow label="Entropy" active={activeLayer==='entropy'} onClick={()=>setActiveLayer('entropy')} icon={Waves}/><ChannelRow label="Geometric" active={activeLayer==='coherence'} onClick={()=>setActiveLayer('coherence')} icon={Compass}/></div>
                                <button onClick={runAutoTune} className="w-full py-2 bg-indigo-900/30 border border-indigo-500/30 text-indigo-300 text-[10px] font-bold rounded flex items-center justify-center gap-2 hover:bg-indigo-900/50 transition-all"><Target className="w-3 h-3"/> GGD Auto-Tune</button>
                                <div className="p-3 bg-slate-800/50 rounded border border-slate-700"><div className="flex justify-between mb-2 items-center"><span className="text-[10px] font-bold text-slate-500 uppercase flex items-center gap-1"><ShieldCheck className="w-3 h-3"/> Forensics</span><div className="flex bg-slate-950 rounded p-0.5 border border-slate-800"><button onClick={()=>setViewMode('raw')} className={`px-2 py-0.5 text-[10px] rounded font-bold ${viewMode==='raw'?'bg-slate-700 text-white':'text-slate-500'}`}>RAW</button><button onClick={()=>setViewMode('clean')} className={`px-2 py-0.5 text-[10px] rounded font-bold ${viewMode==='clean'?'bg-emerald-600 text-white shadow-lg':'text-slate-500'}`}>FILTER</button></div></div><div className="grid grid-cols-3 gap-1"><button onClick={()=>setRepairSettings(p=>({...p, chroma:!p.chroma}))} className={`py-1.5 text-[9px] font-bold rounded border transition-all ${repairSettings.chroma?'bg-cyan-900/40 border-cyan-500 text-cyan-400':'bg-slate-900 border-slate-800 text-slate-500 hover:border-slate-600'}`}>Tukey</button><button onClick={()=>setRepairSettings(p=>({...p, ringing:!p.ringing}))} className={`py-1.5 text-[9px] font-bold rounded border transition-all ${repairSettings.ringing?'bg-cyan-900/40 border-cyan-500 text-cyan-400':'bg-slate-900 border-slate-800 text-slate-500 hover:border-slate-600'}`}>NLM</button><button onClick={()=>setRepairSettings(p=>({...p, geodesic:!p.geodesic}))} className={`py-1.5 text-[9px] font-bold rounded border transition-all ${repairSettings.geodesic?'bg-rose-900/40 border-rose-500 text-rose-400':'bg-slate-900 border-slate-800 text-slate-500 hover:border-slate-600'}`}>Geo</button></div></div>
                                <div className="space-y-2"><DualSlider label="Gain" displayValue={`${physics.gain.toFixed(0)}x`} value={gainState} onChange={setGainState} minCoarse={1} maxCoarse={100} stepCoarse={1} minFine={-1.0} maxFine={1.0} stepFine={0.001}/><DualSlider label="Gamma" displayValue={physics.gamma.toFixed(2)} value={gammaState} onChange={setGammaState} minCoarse={0.1} maxCoarse={3} stepCoarse={0.1} minFine={-0.2} maxFine={0.2} stepFine={0.001}/><DualSlider label="Gate" displayValue={gateDisplayVal} value={gateState} onChange={setGateState} minCoarse={0} maxCoarse={255} stepCoarse={tensor?.meta?.bitDepth===16 ? 0.001 : 0.1} minFine={-10} maxFine={10} stepFine={tensor?.meta?.bitDepth===16 ? 0.001 : 0.01}/><DualSlider label="Soft" displayValue={physics.softness.toFixed(0)} value={softState} onChange={setSoftState} minCoarse={0} maxCoarse={100} stepCoarse={1} minFine={-5} maxFine={5} stepFine={0.1}/></div>
                                {stats && (<div className="pt-4 border-t border-slate-800 space-y-3"><Histogram data={stats.hist} cutoff={physics.threshold/255.0}/><Legend physics={physics} type={activeLayer}/></div>)}
                                <button onClick={()=>setShowAudit(true)} className="w-full py-3 bg-emerald-600 hover:bg-emerald-500 text-white font-bold text-xs rounded uppercase tracking-wider flex items-center justify-center gap-2 shadow-lg shadow-emerald-900/20 transition-all"><ClipboardCheck className="w-4 h-4"/> View Audit</button></div>)}
                        </div>
                    </div>
                    <div className="flex-1 bg-black relative overflow-hidden flex items-center justify-center cursor-crosshair order-1 md:order-2 h-1/2 md:h-full" ref={viewRef} onWheel={handleCanvasWheel} onMouseDown={handleCanvasDown} onMouseMove={handleCanvasMove} onMouseUp={handleCanvasUp} onTouchStart={handleTouchStart} onTouchMove={handleTouchMove} onTouchEnd={handleTouchEnd} onDoubleClick={handleDoubleClick} onMouseLeave={() => { if(hudRef.current) hudRef.current.style.display="none"; }}>
                        <div ref={hudRef} className="fixed z-50 bg-slate-900/90 border border-slate-700 p-2 rounded shadow-xl pointer-events-none hidden backdrop-blur-sm hud-enter text-left"></div>
                        {isProcessing && <div className="absolute inset-0 bg-black/80 z-50 flex items-center justify-center flex-col backdrop-blur-sm"><Loader className="w-10 h-10 text-cyan-400 animate-spin mb-4"/><span className="text-cyan-400 text-xs font-mono tracking-widest uppercase">{status}</span><div className="w-64 h-1 bg-slate-800 rounded mt-4 overflow-hidden"><div className="h-full bg-cyan-500 transition-all duration-100 ease-out" style={{width: `${progress}%`}}></div></div></div>}
                        <div ref={containerRef} className="absolute top-0 left-0 origin-top-left" style={{transform:`translate(${transform.x}px,${transform.y}px) scale(${transform.k})`, imageRendering:'pixelated'}}><canvas ref={canvasRef}/></div>
                        {!img1 && <div className="absolute inset-0 flex items-center justify-center pointer-events-none opacity-50"><Upload className="w-24 h-24 text-slate-800"/></div>}
                    </div>
                </div>
            );
        };
        const root = createRoot(document.getElementById('root')); root.render(<ImageDiff />);
    </script>
</body>
</html>
